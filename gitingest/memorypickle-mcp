Directory structure:
└── justar96-memory-pickle-mcp/
    ├── README.md
    ├── agent-instructions-simplified.md
    ├── CLAUDE.md
    ├── clear-cache-and-test.bat
    ├── debug_tools.js
    ├── jest.config.js
    ├── LICENSE
    ├── mcp.json
    ├── package.json
    ├── tsconfig.json
    ├── docs/
    │   ├── CHANGELOG.md
    │   ├── TOOLS.md
    │   └── USAGE.md
    ├── scripts/
    │   └── update-version.mjs
    ├── src/
    │   ├── index.ts
    │   ├── config/
    │   │   └── constants.ts
    │   ├── core/
    │   │   └── MemoryPickleCore.ts
    │   ├── handlers/
    │   │   └── RequestHandlers.ts
    │   ├── server/
    │   │   └── ServerConfig.ts
    │   ├── services/
    │   │   ├── ExportService.ts
    │   │   ├── index.ts
    │   │   ├── InMemoryStore.ts
    │   │   ├── MemoryService.ts
    │   │   ├── ProjectService.ts
    │   │   ├── RecallService.ts
    │   │   └── TaskService.ts
    │   ├── tools/
    │   │   └── index.ts
    │   ├── types/
    │   │   ├── index.ts
    │   │   └── schemas.ts
    │   └── utils/
    │       ├── errors.ts
    │       ├── idGenerator.ts
    │       ├── ValidationUtils.ts
    │       └── version.ts
    └── test/
        ├── jest.config.js
        ├── fixtures/
        │   └── sample-projects.json
        ├── helpers/
        │   └── TestCoreUtils.ts
        ├── integration/
        │   └── workflows/
        │       └── ProjectWorkflows.test.ts
        ├── setup/
        │   ├── e2e.ts
        │   ├── global.ts
        │   ├── integration.ts
        │   ├── performance.ts
        │   └── unit.ts
        └── unit/
            └── services/
                └── ProjectService.test.ts


Files Content:

================================================
FILE: README.md
================================================
# Memory Pickle MCP

**Project management and session memory for AI agents.** Provides 13 comprehensive MCP tools for tracking projects, tasks, and context during AI coding sessions.

### suggestion
*for kilo , cline , roo perform best with code mode your agent will not lose track. there are some struggle with HITL*

## Quick Start

### Stable Version
```json
{
  "mcpServers": {
    "memory-pickle": {
      "command": "npx",
      "args": ["-y", "@cabbages/memory-pickle-mcp"]
    }
  }
}
```
## Compatibility

**Extensively Tested & Optimized For:**
- **Cursor** , **Windsurf** , **Cline, Roo, Kilo Mode Code**

**Additional Support:**
- Claude Desktop (direct MCP integration)
- VS Code with MCP extensions

## Architecture Overview

**Memory-Only Storage Architecture:**
- All data exists only during the current chat session
- No files created on disk - zero filesystem dependencies
- Data automatically cleared when session ends
- Blazing fast performance with in-memory operations
- Complete session isolation for security

**13-Tool Comprehensive System:**
- **4 Read Tools:** State recall, task listing, project overview, detailed task info
- **5 Write Tools:** Project/task creation and updates, context switching
- **2 Memory Tools:** Information storage and contextual search
- **2 Session Tools:** Data export and handoff summary generation

## Features

### **Hierarchical Task Organization**
```yaml
# Create parent task
create_task:
  title: "Build Authentication System"
  priority: "high"

# Create subtasks
create_task:
  title: "Implement login API"
  parent_id: "task_123"  # Links to parent
  
create_task:
  title: "Add password reset flow"
  parent_id: "task_123"
```

### **Progress Tracking & Blockers**
```yaml
# Comprehensive task updates
update_task:
  task_id: "task_123"
  progress: 75
  notes: ["API endpoints complete", "Working on validation"]
  blockers: ["Waiting for security review", "Database schema pending"]
  completed: false
```

### **Memory System with Importance**
```yaml
# Store critical decisions
remember_this:
  content: "Switched from JWT to session cookies for security"
  importance: "critical"
  project_id: "proj_auth"

# Search by importance level
recall_context:
  query: "security decision"
  importance: "critical"
  limit: 5
```

## Workflow

### **Session Handoff**
```yaml
# Generate clean transition summary
generate_handoff_summary:
  format: "detailed"
  project_id: "current"

# Export for permanent storage
export_session:
  format: "markdown"
  include_handoff: true
  raw_markdown: true  # Clean output for processing
```

### **Integration Notes**
- **Context switching:** Agents may lose context between tool calls (in some case)
- **State synchronization:** Use `recall_state` to refresh context
- **Error handling:** Tools provide detailed error information
  *send me issues <3*

## Requirements
- **Node.js:** 16.0.0 or higher

## Links & Resources

- **Official Website:** [pickle.cabbages.work](https://pickle.cabbages.work)
- **GitHub Repository:** [Justar96/memory-pickle-mcp](https://github.com/Justar96/memory-pickle-mcp)
- **NPM Package:** [@cabbages/memory-pickle-mcp](https://www.npmjs.com/package/@cabbages/memory-pickle-mcp)
- **Pre-release:** [@cabbages-pre/memory-pickle-mcp-pre](https://www.npmjs.com/package/@cabbages-pre/memory-pickle-mcp-pre)

### Local Development
```json
{
  "mcpServers": {
    "memory-pickle-dev": {
      "command": "node",
      "args": ["build/index.js"],
      "cwd": "/path/to/your/memory-pickle-mcp"
    }
  }
}
```
### Pre-release Version (Latest Development)
```json
{
  "mcpServers": {
    "memory-pickle-pre": {
      "command": "npx",
      "args": ["-y", "@cabbages-pre/memory-pickle-mcp-pre@latest"]
    }
  }
}
```

## Documentation

- [Complete Tools Reference](docs/TOOLS.md) - All 13 tools with examples
- [Usage Guide](docs/USAGE.md) - Workflows and best practices
- [Changelog](docs/CHANGELOG.md) - Version history and updates

## Troubleshooting

### **Tools Not Working**
1. Update to latest version: `npx -y @cabbages/memory-pickle-mcp` Use `@latest` flag
2. Verify MCP client configuration in settings
3. Check Node.js version: `node --version`
4. Restart MCP server for complete reset

### **Data Loss Prevention**
1. Tell Agent to use `generate_handoff_summary` before ending sessions
2. Export critical data with `export_session`
3. Save important decisions as markdown files
4. Document project state in external files

## Version Information

**Current Version:** 1.3.9

**Recent Changes:**
- **13 comprehensive tools** for complete project management
- Advanced hierarchical task organization with parent-child relationships
- Code location linking for development context
- Importance-based memory classification system
- Comprehensive session export and handoff capabilities
- Optimized for modern AI coding assistants (Cursor, Cline, Roo, etc.)

## License

Apache 2.0 - See [LICENSE](LICENSE) for details



================================================
FILE: agent-instructions-simplified.md
================================================
# Memory Pickle MCP Agent Instructions

## Overview
Memory Pickle provides 13 project management tools for AI agents. The system maintains session-based data for project organization, task tracking, and information storage.

## Core Workflow Patterns

### 📊 **Session Context Understanding**
The `recall_state` tool provides comprehensive project context including:
- Current project status and active tasks
- Recent memories and session activity
- Progress summaries and statistics
- Project completion percentages

### 📝 **Task Management**
- `create_task`: Creates new tasks with hierarchical organization support
- `update_task`: Modifies task properties, progress, and completion status
- `list_tasks`: Returns filtered task lists with pagination
- `get_task`: Provides detailed task information including subtasks and notes

### 📁 **Project Organization**
- `create_project`: Establishes new projects and sets them as current context
- `update_project`: Modifies project properties and status
- `list_projects`: Returns project overviews with completion statistics
- `set_current_project`: Changes active project context for task operations

### 🧠 **Information Storage**
- `remember_this`: Stores important information with importance classification
- `recall_context`: Searches stored memories with filtering capabilities

### 📄 **Session Management**
- `export_session`: Generates complete session data in markdown or JSON format
- `generate_handoff_summary`: Creates session summaries for continuity

## Tool Usage Guidelines

### **Data Relationship Structure**
```
Projects (top-level containers)
├── Tasks (can have parent-child relationships)
├── Memories (linked to projects/tasks)
└── Session Activity (tracks operations)
```

### **Common Parameter Patterns**
- **dry_run**: Available on modification tools for preview without changes
- **project_id**: Links items to specific projects (defaults to current project)
- **line_range**: Associates tasks/memories with code locations
- **importance**: Classifies memory relevance (critical, high, medium, low)

### **Data Validation**
- String inputs are sanitized for security
- Required fields are validated before processing
- Array parameters support both single values and lists
- Pagination limits prevent excessive data retrieval

### **Status Management**
- **Projects**: planning → in_progress → completed/blocked/archived
- **Tasks**: active (completed: false) → completed (completed: true)
- **Progress**: 0-100 percentage tracking with timestamped notes

## Response Format Guidelines

### **Successful Operations**
Tools return structured responses with:
- Success indicators ([OK], [INFO])
- Relevant data summaries
- Next-step suggestions when appropriate

### **Error Handling**
- Validation errors with specific field information
- Not-found errors with available alternatives
- Permission/context errors with resolution guidance

### **Dry Run Results**
Preview responses indicate:
- What changes would be made
- No actual data modification
- Safe testing of operations

## Security Considerations

### **Input Validation**
- All user inputs are sanitized and validated
- String length limits prevent data overflow
- Enum values are strictly validated
- Required fields are enforced

### **Data Integrity**
- Orphaned data cleanup available through internal methods
- Referential integrity maintained between projects, tasks, and memories
- Transaction-safe operations with rollback capability

### **Session Isolation**
- Data exists only during session lifetime
- No persistent storage or external data access
- Memory-only operations with controlled resource usage

## Integration Notes

### **Current Project Context**
Most operations default to current project when project_id is not specified. The system tracks:
- Active project for new task creation
- Project switching history
- Session activity within project contexts

### **Hierarchical Organization**
- Tasks can have parent-child relationships via parent_id
- Memories can link to both projects and specific tasks
- Code locations can be referenced through line_range objects

### **Search and Filtering**
- Text search across memory content and titles
- Multi-criteria task and project filtering
- Pagination for large result sets
- Importance-based memory organization

This instruction set provides clear operational guidance without behavioral conditioning or system prompt interference, maintaining security best practices for MCP tool integration. 


================================================
FILE: CLAUDE.md
================================================
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Development Commands

### Build and Development
```bash
npm run build          # Compile TypeScript and make executable
npm run watch          # Watch mode for development
npm run prepare        # Pre-publish build (runs automatically)
```

### Testing
```bash
npm test               # Run all tests with Jest
npm run test:coverage  # Run tests with coverage report
npm test -- --testNamePattern="pattern"  # Run specific test by name pattern
npm test -- test/taskService.test.ts     # Run specific test file
```

### Debugging and Inspection
```bash
npm run inspector      # Launch MCP inspector at http://localhost:6274
node build/index.js    # Run server directly for testing
```

### Version Management
```bash
npm run update-version    # Update version across all config files
npm version patch|minor|major  # Standard npm version bump (auto-syncs)
```

## Architecture Overview

### Core Design Pattern
This is an **MCP (Model Context Protocol) server** that provides AI agents with project management and memory tools. The system uses **in-memory storage only** - no files are persisted to disk.

### Service-Oriented Architecture
```
src/
├── core/MemoryPickleCore.ts     # Main business logic orchestration
├── handlers/RequestHandlers.ts  # MCP protocol request handling
├── services/                    # Domain services
│   ├── InMemoryStore.ts        # Transaction-safe memory storage
│   ├── ProjectService.ts       # Project management logic
│   ├── TaskService.ts          # Task management logic
│   └── MemoryService.ts        # Context/memory management
├── tools/index.ts              # 12 MCP tools with enhanced prompts
└── types/schemas.ts            # Zod validation schemas
```

### Key Architectural Decisions

1. **In-Memory Only Storage**: All data exists only during the session. No file persistence eliminates concurrency issues and simplifies deployment.

2. **Transaction Safety**: InMemoryStore uses snapshot-based transactions to ensure data integrity without file locking complexity.

3. **Service Separation**: Clear boundaries between projects, tasks, and memories with dedicated services for each domain.

4. **MCP Protocol Compliance**: Strict adherence to MCP standards with proper error handling and clean text output.

### Data Flow
1. MCP client calls tool → RequestHandlers 
2. RequestHandlers validates input → MemoryPickleCore methods
3. MemoryPickleCore coordinates services → InMemoryStore transactions
4. Results flow back with clean text formatting

## Tool Architecture

The system provides **12 essential MCP tools** organized in clean categories:

**Read Tools:**
- `recall_state` - Get current project context with tasks, memories, and stats in one call
- `list_tasks` - List and filter tasks with pagination
- `list_projects` - List projects with completion stats  
- `get_task` - Get detailed info for a single task including subtasks and notes

**Write Tools:**
- `create_project` - Create new project and set as current
- `update_project` - Update project name, description, or status
- `set_current_project` - Switch active project context
- `create_task` - Create task in current or specified project
- `update_task` - Update task progress, completion, notes, or blockers

**Memory Tools:**
- `remember_this` - Store important information linked to current project/task

**Session Management:**
- `export_session` - Export session data as markdown or JSON for permanent storage
- `generate_handoff_summary` - Generate session summary for handoff between sessions

### Tool Design Principles
- **Action-oriented descriptions** with clear usage triggers
- **Auto-detection patterns** for priority and context
- **Proactive behavior hints** for AI agents
- **Single responsibility** per tool

## Session Memory Model

### Memory Lifecycle
- Data created at session start
- All tools share the same in-memory database
- Data destroyed when session ends
- **Handoff summaries** provide continuity between sessions

### Session Tracking
The core tracks comprehensive session activity:
- Tasks created/updated/completed
- Memories stored
- Project switches
- Tool usage patterns
- Key decisions made

## Development Practices

### Type Safety
- All data validated with **Zod schemas** at runtime
- TypeScript strict mode enforced
- Comprehensive error handling with specific error types

### Testing Strategy
- **16 comprehensive test files** covering all services and edge cases
- Test utilities in `test/utils/testHelpers.ts`
- Integration tests for MCP protocol compliance
- Coverage reporting available

### Error Handling
- Defensive programming throughout
- Clean error messages for MCP clients
- Graceful degradation when data not found
- No console.error output to prevent MCP stdio interference

## Version Management

The project uses **centralized version management**:
- Single source of truth in `package.json`
- `src/utils/version.ts` reads version dynamically
- `scripts/update-version.mjs` syncs configuration files
- Use `npm version patch` for automated version bumps

## Clean Text Output Philosophy

The system uses **clean text only** (no emojis) for:
- Universal compatibility across environments
- Screen reader accessibility
- Professional appearance in corporate settings
- Clean logs and automation output

Output uses standardized prefixes:
- `[OK]` - Successful operations
- `[ERROR]` - Failed operations
- `[INFO]` - Status information
- `[CURRENT]` - Active project indicators
- `[DONE]` - Completed items

## MCP Integration

### Local Development
```json
{
  "mcpServers": {
    "memory-pickle-dev": {
      "command": "node",
      "args": ["build/index.js"],
      "cwd": "/path/to/this/repository"
    }
  }
}
```

### Production Configuration
```json
{
  "mcpServers": {
    "memory-pickle": {
      "command": "npx",
      "args": ["-y", "@cabbages/memory-pickle-mcp"]
    }
  }
}
```

The server automatically provides all 12 tools to MCP clients with comprehensive documentation and usage examples.

## MCP Agent Awareness Features

This codebase implements advanced MCP agent awareness patterns following industry best practices:

### 1. Enhanced Tool Specifications
- **Concrete examples**: Every tool includes 2-3 realistic usage examples with actual user quotes
- **Trigger patterns**: Natural language patterns that should activate each tool
- **Priority detection**: Automatic mapping from user urgency language to priority levels
- **Dry-run support**: All mutating operations support `dry_run: true` for safe testing

### 2. Structured Error Handling
- **Specific error classes**: 9 custom error types with clear error codes
- **Self-correction hints**: Error messages include suggestions for valid alternatives
- **Validation feedback**: Structured validation with field-specific guidance
- **Clean text format**: All errors use `[ERROR_CODE]` prefixes for easy parsing

### 3. Proactive Behavior Patterns
- **Auto-detection**: Tools automatically detect priority from user language ("urgent" → critical)
- **Context awareness**: Session tracking provides rich context for handoff summaries
- **Smart defaults**: Tools work together automatically (current project linking)
- **Decision routing**: Clear if/then patterns for when to use each tool

### 4. Testing and Validation
- **Dry-run mode**: `dry_run: true` parameter validates inputs without changes
- **Error simulation**: Test error conditions safely with structured error responses
- **Integration testing**: Comprehensive test suite covers all tool interactions and edge cases
- **Schema validation**: Runtime validation with Zod ensures type safety

### Example Error Responses
```
[TASK_NOT_FOUND] Task 'auth_task' not found. Available tasks: login_ui, jwt_setup, oauth_flow...
[VALIDATION_ERROR] Validation failed for field 'priority': Must be one of: critical, high, medium, low. Received: urgent
[DRY_RUN] create_project: Would create project 'E-commerce Site' and set it as current project. No changes made.
```

### Agent Integration Patterns
The tools follow these patterns for optimal agent adoption:

1. **Session initialization**: Always start with `recall_state`
2. **Natural triggers**: Listen for action words ("need to" → `create_task`)
3. **Progress tracking**: Detect completion phrases ("I finished" → `update_task`)
4. **Memory storage**: Auto-trigger on importance keywords ("remember that")
5. **Error recovery**: Specific error codes enable intelligent retry strategies


================================================
FILE: clear-cache-and-test.bat
================================================
@echo off
echo Clearing NPX cache...
npm cache clean --force
npx clear-npx-cache

echo Testing latest version...
npx -y @cabbages-pre/memory-pickle-mcp-pre@1.3.9

pause



================================================
FILE: debug_tools.js
================================================
import { MemoryPickleCore } from './build/core/MemoryPickleCore.js';

async function debugTools() {
  try {
    console.log('Creating MemoryPickleCore instance...');
    const core = await MemoryPickleCore.create();
    
    console.log('Testing with hardcoded IDs (like the failing tests)...');
    
    // Test set_current_project with non-existent ID (simulating test failure)
    console.log('\nTesting set_current_project with non-existent project_id...');
    try {
      const result = await core.set_current_project({ project_id: 'proj_test_123' });
      console.log('Unexpected success:', result.content[0].text);
    } catch (error) {
      console.log('Expected error:', error.message);
    }
    
    // Test update_task with non-existent ID (simulating test failure)
    console.log('\nTesting update_task with non-existent task_id...');
    try {
      const result = await core.update_task({ task_id: 'task_test_123', progress: 50 });
      console.log('Unexpected success:', result.content[0].text);
    } catch (error) {
      console.log('Expected error:', error.message);
    }
    
    console.log('\nNow testing with realistic scenario...');
    // Create a project first
    await core.create_project({ name: 'Test Project' });
    const db1 = core.getDatabase();
    const project = db1.projects[0];
    console.log('Created project ID:', project.id);
    
    // Create a task
    await core.create_task({ title: 'Test Task' });
    const db2 = core.getDatabase();
    const task = db2.tasks[0];
    console.log('Created task ID:', task.id);
    
    // Test set_current_project with real ID
    console.log('\nTesting set_current_project with real project_id...');
    const result1 = await core.set_current_project({ project_id: project.id });
    console.log('Success:', result1.content[0].text.substring(0, 50) + '...');
    
    // Test update_task with real ID
    console.log('\nTesting update_task with real task_id...');
    const result2 = await core.update_task({ task_id: task.id, progress: 50 });
    console.log('Success:', result2.content[0].text.substring(0, 50) + '...');
    
  } catch (error) {
    console.error('Error:', error);
  }
}

debugTools();


================================================
FILE: jest.config.js
================================================
/** @type {import('ts-jest').JestConfigWithTsJest} */
export default {
  preset: 'ts-jest/presets/default-esm',
  testEnvironment: 'node',

  // Performance optimizations
  maxWorkers: '50%',
  testTimeout: 30000,

  // Force Jest to exit even with hanging timers/intervals
  forceExit: true,
  detectOpenHandles: true,

  // Modern ts-jest configuration (avoiding deprecated globals)
  extensionsToTreatAsEsm: ['.ts'],
  transform: {
    '^.+\\.ts$': ['ts-jest', {
      useESM: true,
    }],
  },

  // Use the organized test structure - find all test files in test directory
  testMatch: ['**/test/**/*.test.ts'],

  // Module resolution
  moduleNameMapper: {
    '^(\\.{1,2}/.*)\\.js$': '$1',
  },

  // Coverage configuration
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/index.ts',
  ],
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html'],

  // Test organization
  testPathIgnorePatterns: [
    '/node_modules/',
    '/build/',
    '/coverage/',
  ],

  // Setup files for global configuration
  setupFilesAfterEnv: ['<rootDir>/test/setup/global.ts'],

  // Verbose output for CI
  verbose: process.env.CI === 'true',

  // Fail fast in development
  bail: process.env.NODE_ENV === 'development' ? 1 : 0,
};


================================================
FILE: LICENSE
================================================
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.



================================================
FILE: mcp.json
================================================
{
  "mcpServers": {
    "memory-pickle-pre": {
      "command": "npx",
      "args": ["-y", "@cabbages-pre/memory-pickle-mcp-pre"]
    }
  }
}


================================================
FILE: package.json
================================================
{
  "name": "@cabbages/memory-pickle-mcp",
  "version": "1.3.9",
  "description": "MCP server for AI agent project management - 13 tools for session memory and task tracking",
  "keywords": [
    "mcp",
    "model-context-protocol",
    "project-management",
    "task-tracking",
    "ai-memory",
    "agent-memory",
    "checklist",
    "todo",
    "session-memory",
    "session-continuity",
    "in-memory"
  ],
  "author": "Cabbages Code",
  "license": "Apache-2.0",
  "type": "module",
  "bin": {
    "memory-pickle": "build/index.js"
  },
  "files": [
    "build",
    "agent-instructions-simplified.md",
    "README.md",
    "docs"
  ],
  "scripts": {
    "build": "tsc && node -e \"require('fs').chmodSync('build/index.js', '755')\"",
    "prepare": "npm run build",
    "watch": "tsc --watch",
    "inspector": "npx @modelcontextprotocol/inspector build/index.js",
    "test": "cross-env NODE_OPTIONS=--experimental-vm-modules jest",
    "test:coverage": "cross-env NODE_OPTIONS=--experimental-vm-modules jest --coverage",
    "update-version": "node scripts/update-version.mjs",
    "version": "npm run update-version && git add ."
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Justar96/memory-pickle-mcp.git"
  },
  "homepage": "https://pickle.cabbages.work",
  "mcp": {
    "instructions": "agent-instructions-simplified.md"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^0.6.0",
    "axios": "^1.9.0",
    "zod": "^3.25.64"
  },
  "devDependencies": {
    "@types/jest": "^29.5.14",
    "@types/node": "^20.19.1",
    "cross-env": "^7.0.3",
    "jest": "^29.7.0",
    "ts-jest": "^29.4.0",
    "typescript": "^5.8.3"
  },
  "engines": {
    "node": ">=16.0.0"
  }
}



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "moduleResolution": "Node16",
    "outDir": "./build",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "isolatedModules": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}



================================================
FILE: docs/CHANGELOG.md
================================================
# Changelog

All notable changes to Memory Pickle MCP will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [1.3.9] - 2025-06-20

### Changed
- Complete documentation rewrite to accurately reflect 13-tool system instead of incorrect 8-tool references. Added comprehensive AI assistant integration guide for Cursor, Cline, Roo, Kilo mode code.

### Fixed  
- Corrected tool documentation mismatch between docs and actual codebase implementation. Enhanced technical specifications with performance metrics and caution warnings.

## [1.3.8] - 2025-06-16

### Changed
- Updated all version references across codebase to 1.3.8 with centralized version management. Aligned documentation to reflect current in-memory-only system.

### Fixed
- Resolved inconsistent version references and replaced emoji examples with clean text format. Removed outdated file storage references from documentation.

## [1.3.1] - 2025-06-15

### Changed
- Removed all emoji functionality and environment variables for maximum simplicity and compatibility. Streamlined codebase to single clean text output format for universal accessibility.

## [1.3.0] - 2025-06-14

### Changed
- Simplified tool structure from 17 to 13 comprehensive tools with consolidated functionality. Enhanced `update_task` to handle completion, progress, notes, and blockers in single tool.

### Removed
- Removed redundant tools like `toggle_task`, `get_tasks`, and data integrity utilities for simplicity. Consolidated overlapping functionality to eliminate redundancy and improve agent understanding.

## [1.1.0] - 2025-06-13

### Added
- Configurable emoji support and clean text mode for corporate environments. Multi-platform integration guides for Claude Desktop, Cursor, Windsurf, VS Code.

### Fixed
- Critical bug where tool names caused "Unknown tool" errors making v1.0.0 unusable. All 13 tools now work correctly with proper snake_case naming convention.

## [1.0.0] - 2025-06-13

### Added
- Initial public release with 13 comprehensive MCP tools for project management and memory storage. Complete TypeScript rewrite with modular architecture and in-memory data storage for session-based operation.

## [Unreleased]

### Planned
- Multi-agent collaboration features
- Visual dashboard integration
- Git integration for code-aware task tracking
- Advanced search with semantic understanding
- Task templates marketplace
- Memory lifecycle management (archival, cleanup)
- WebSocket support for real-time updates
- Plugin system for custom extensions

---

## Version History

- **v1.0.0** - First public release (June 2025)
- **v2.0.0** - Internal development version (never published)
- **v1.x** - Legacy memory-only system (deprecated)

## Migration Notes

### From Previous Versions
**Important:** Starting with v1.3.0, Memory Pickle uses in-memory-only storage:
- No data persistence between sessions
- No file system dependencies
- Use `generate_handoff_summary` to create session summaries
- Save important information as markdown files for permanent storage

### Session Continuity
- During session: All data shared across tools
- Between sessions: Use handoff summaries for context transfer

## Support

For issues, feature requests, or questions:
- GitHub Issues: https://github.com/Justar96/memory-pickle-mcp/issues
- NPM Package: https://www.npmjs.com/package/@cabbages/memory-pickle-mcp

## Contributors

- Initial development and architecture
- Modular refactoring and optimization
- Documentation and publishing setup


================================================
FILE: docs/TOOLS.md
================================================
# Complete Tools Reference (v1.3.9)

Memory Pickle MCP provides **13 comprehensive tools** for advanced project management and session memory. This reference covers all tools with technical specifications, examples, and integration patterns.

## Tool Categories Overview

### **📊 Read Tools (4)**
- `recall_state` - Universal session context and project overview
- `list_tasks` - Filtered task listing with pagination  
- `list_projects` - Project overview with completion statistics
- `get_task` - Detailed single task information

### **📝 Write Tools (5)**
- `create_project` - Project creation and initialization
- `update_project` - Project modification and status updates
- `set_current_project` - Active project context switching
- `create_task` - Task creation with hierarchical support
- `update_task` - Comprehensive task modification tool

### **🧠 Memory Tools (2)**
- `remember_this` - Information storage with classification
- `recall_context` - Memory search and retrieval

### **📄 Session Tools (2)**
- `export_session` - Complete session data export
- `generate_handoff_summary` - Session transition summaries

---

## Read Tools

### `recall_state`
**Universal session context and project overview.** Auto-called at session start.

**Purpose:** Provides comprehensive session state including current project, active tasks, recent memories, and progress statistics.

```yaml
# Parameters (all optional)
limit: 20  # Maximum items per category
project_id: "proj_123"  # Focus on specific project
include_completed: false  # Include completed tasks
focus: "all"  # "tasks", "projects", "memories", or "all"
```

**Returns:**
- Current project information and progress
- Active task hierarchy with completion status
- Recent memories and decisions
- Session activity summary
- Progress statistics and recommendations

**Example Response:**
```
## Current Session Context

**Active Project:** Authentication System (75% complete)
- [DONE] Database schema design
- [ ] API endpoint implementation (60% progress)
  - [DONE] Login endpoint
  - [ ] Registration endpoint
- [BLOCKED] Security audit (waiting for external review)

**Recent Memories:** 3 critical decisions stored
**Session Activity:** 8 tasks created, 5 completed, 12 tool calls

**Next Steps:**
1. Complete registration endpoint
2. Address security audit blockers
3. Begin integration testing
```

### `list_tasks`
**Filtered task listing with pagination and status filtering.**

**Purpose:** Retrieve tasks with precise filtering, sorting, and pagination for efficient task management.

```yaml
# Filtering options
status: "active"  # "active" or "completed"
priority: "high"  # "critical", "high", "medium", "low"
project_id: "proj_123"  # Filter by project
completed: false  # Boolean completion filter

# Pagination
limit: 50  # Maximum tasks (1-200)
offset: 0  # Skip tasks for pagination
```

**Returns:**
- Filtered task list with metadata
- Task hierarchy (parent-child relationships)
- Progress indicators and completion status
- Priority levels and blocker information
- Pagination information (total count, has_more)

### `list_projects`
**Project overview with completion statistics and filtering.**

**Purpose:** Get comprehensive project list with progress metrics and status information.

```yaml
# Filtering
status: "in_progress"  # "planning", "in_progress", "blocked", "completed", "archived"

# Pagination
limit: 50  # Maximum projects (1-200)
offset: 0  # Skip projects for pagination
```

**Returns:**
- Project list with completion percentages
- Task counts (total, completed, active)
- Status information and timestamps
- Current project indicator

### `get_task`
**Detailed single task information with full context.**

**Purpose:** Retrieve comprehensive task details including subtasks, notes, blockers, and linked memories.

```yaml
# Required parameter
task_id: "task_123"  # Task identifier
```

**Returns:**
- Complete task information (title, description, priority)
- Subtask hierarchy and relationships
- Progress notes with timestamps
- Blocker list and resolution status
- Linked memories and code locations
- Parent task relationship information

---

## Write Tools

### `create_project`
**Project creation and initialization. Automatically becomes current project.**

**Purpose:** Create new project containers for organizing tasks and context. Sets as active project automatically.

```yaml
# Required
name: "Authentication System"  # Project name (1-200 chars)

# Optional
description: "Complete user authentication with JWT tokens"  # Detailed description
status: "planning"  # "planning", "in_progress", "blocked", "completed", "archived"
dry_run: false  # Preview without creating
```

**Returns:**
- Created project information with unique ID
- Automatic current project assignment confirmation
- Initial project structure setup

### `update_project`
**Project modification and status updates.**

**Purpose:** Modify existing project properties, status, and metadata.

```yaml
# Required
project_id: "proj_123"  # Project to update

# Optional updates
name: "Updated Project Name"
description: "New description"
status: "in_progress"  # Status transition
dry_run: false  # Preview changes
```

**Returns:**
- Updated project information
- Change summary and validation results
- Status transition confirmation

### `set_current_project`
**Active project context switching.**

**Purpose:** Change the active project context. New tasks will default to this project.

```yaml
# Required
project_id: "proj_123"  # Project to activate

# Optional
dry_run: false  # Preview switch without changing
```

**Returns:**
- Current project change confirmation
- Project context information
- Impact on future task creation

### `create_task`
**Task creation with hierarchical support and code linking.**

**Purpose:** Create tasks with full organizational features including subtasks, priority, and code location linking.

```yaml
# Required
title: "Implement login API endpoint"  # Task title (1-200 chars)

# Optional
description: "Create POST /login with JWT response"  # Detailed description
priority: "high"  # "critical", "high", "medium", "low"
project_id: "proj_123"  # Use specific project (defaults to current)
parent_id: "task_456"  # Create as subtask
dry_run: false  # Preview creation

# Code location linking
line_range:
  start_line: 45
  end_line: 62
  file_path: "src/auth/login.ts"
```

**Returns:**
- Created task information with unique ID
- Hierarchical placement confirmation
- Project assignment details
- Code location link validation

### `update_task`
**Comprehensive task modification tool.**

**Purpose:** Unified tool for all task updates including completion, progress, notes, and blockers.

```yaml
# Required
task_id: "task_123"  # Task to update

# Optional updates
title: "Updated task title"
description: "New description"
priority: "critical"  # Priority change
completed: true  # Mark complete/incomplete
progress: 75  # Progress percentage (0-100)
dry_run: false  # Preview changes

# Progress tracking
notes: "API implementation complete, testing in progress"
# OR multiple notes
notes: 
  - "Completed endpoint logic"
  - "Added input validation"
  - "Started unit tests"

# Blocker management
blockers:
  - "Waiting for security review"
  - "Database migration pending"
```

**Returns:**
- Updated task information
- Progress change summary
- Blocker status and resolution tracking
- Timestamped note additions

---

## Memory Tools

### `remember_this`
**Information storage with importance classification and linking.**

**Purpose:** Store important decisions, context, and information with proper categorization and project/task linking.

```yaml
# Required
content: "Switched authentication from JWT to session cookies for enhanced security"

# Optional
title: "Authentication Method Decision"  # Auto-generated if not provided
importance: "critical"  # "critical", "high", "medium", "low"
project_id: "proj_123"  # Link to project (uses current if not specified)
task_id: "task_456"  # Link to specific task
dry_run: false  # Preview storage

# Code location linking
line_range:
  start_line: 12
  end_line: 25
  file_path: "src/config/auth.ts"
```

**Returns:**
- Stored memory confirmation with unique ID
- Importance classification and linking details
- Search indexing confirmation

### `recall_context`
**Memory search and retrieval with filtering.**

**Purpose:** Search stored memories with importance filtering and project context.

```yaml
# Optional parameters
query: "authentication security decision"  # Search term (title + content)
project_id: "proj_123"  # Filter by project
importance: "critical"  # Filter by importance level
limit: 10  # Maximum memories (1-100)
```

**Returns:**
- Relevant memories with content and metadata
- Importance levels and timestamps
- Project and task links
- Search relevance scoring

---

## Session Tools

### `export_session`
**Complete session data export in multiple formats.**

**Purpose:** Generate comprehensive session exports for permanent storage and analysis.

```yaml
# Optional parameters
format: "markdown"  # "markdown" or "json"
include_handoff: true  # Include handoff summary
raw_markdown: false  # Clean markdown without MCP wrapper
```

**Formats:**
- **Markdown:** Human-readable session summary with project structure
- **JSON:** Machine-readable complete data dump
- **Raw Markdown:** Clean text without MCP response formatting

**Returns:**
- Complete session data in requested format
- Project hierarchies and task relationships
- Memory collections with importance levels
- Session activity logs and statistics

### `generate_handoff_summary`
**Session transition summaries for continuity.**

**Purpose:** Create clean, focused summaries for transitioning between sessions or agents.

```yaml
# Optional parameters
project_id: "proj_123"  # Focus on specific project
format: "detailed"  # "detailed" or "brief"
```

**Summary Levels:**
- **Detailed:** Comprehensive project state, active tasks, blockers, progress
- **Brief:** Key accomplishments, next steps, critical blockers

**Returns:**
- Clean markdown summary without MCP wrapper
- Current progress and completion status
- Active blockers and resolution requirements
- Recommended next steps and priorities

---

## Advanced Integration Patterns

### **Tool Chaining Examples**

**Project Setup Workflow:**
```yaml
1. create_project: name="New Feature"
2. create_task: title="Design database schema", priority="high"
3. create_task: title="Implement API", parent_id=<schema_task_id>
4. remember_this: content="Using PostgreSQL for ACID compliance"
```

**Progress Tracking Workflow:**
```yaml
1. update_task: task_id="123", progress=50, notes="Half complete"
2. remember_this: content="Performance optimization needed", task_id="123"
3. update_task: task_id="123", blockers=["Waiting for performance review"]
```

**Session Handoff Workflow:**
```yaml
1. export_session: format="markdown", include_handoff=true
2. generate_handoff_summary: format="detailed"
3. # Save outputs as markdown files for next session
```

### **Error Handling Patterns**

All tools support comprehensive error handling:

- **Validation Errors:** Field-specific error messages with resolution guidance
- **Not Found Errors:** Clear identification of missing resources with suggestions
- **Permission Errors:** Context-aware error messages with resolution steps
- **Dry Run Results:** Safe preview functionality without data modification

### **Performance Optimization**

**Efficient Data Access:**
- Use pagination on list operations for large datasets
- Filter results with specific criteria to reduce payload
- Leverage `recall_state` for comprehensive context instead of multiple tool calls

**Memory Management:**
- Set appropriate importance levels for memory prioritization
- Use project-specific queries to reduce search scope
- Regular session exports prevent data loss and enable performance resets

---

## Tool Integration Best Practices

### **For AI Agents**
1. **Start with `recall_state`** to understand current context
2. **Use dry_run** to preview changes before execution
3. **Leverage hierarchical tasks** for complex project organization
4. **Store important decisions** with appropriate importance levels
5. **Generate handoffs** before ending sessions

### **For Development Workflows**
1. **Link tasks to code locations** using line_range
2. **Track progress with timestamped notes** for accountability
3. **Document blockers explicitly** for team coordination
4. **Use importance levels** to prioritize critical information
5. **Export data regularly** for permanent project records

### **For Team Collaboration**
1. **Maintain project status** with regular updates
2. **Share handoff summaries** between team members
3. **Document decision rationale** in memories
4. **Track dependencies** through task hierarchies
5. **Export session data** for meeting preparation

This comprehensive tool reference enables full utilization of Memory Pickle MCP's capabilities for advanced project management and session continuity in AI-powered development workflows.


================================================
FILE: docs/USAGE.md
================================================
# Comprehensive Usage Guide

Memory Pickle MCP provides 13 advanced tools for AI-powered project management. This guide covers practical workflows, AI assistant integration, and advanced usage patterns.

## AI Assistant Integration

### **Cursor (Recommended)**
**Excellent MCP integration with Claude 3.5 Sonnet**

```json
// .cursor-settings.json
{
  "mcpServers": {
    "memory-pickle": {
      "command": "npx",
      "args": ["-y", "@cabbages/memory-pickle-mcp"]
    }
  }
}
```

**Optimal Workflow:**
- Agent automatically calls `recall_state` on session start
- Natural task creation through conversation
- Excellent context preservation between tool calls
- Seamless code location linking with file references

### **Cline, Roo, Kilo Mode Code**
**Advanced autonomous coding support**

**Configuration:** Standard MCP setup works perfectly
**Strengths:**
- Autonomous task breakdown and creation
- Excellent hierarchical task organization
- Automatic progress tracking during code changes
- Strong integration with git workflows and file modifications

**Best Practices:**
```yaml
# Link tasks to code changes automatically
create_task:
  title: "Refactor authentication middleware"
  line_range:
    start_line: 45
    end_line: 78
    file_path: "src/middleware/auth.ts"

# Track autonomous progress
update_task:
  task_id: "task_123"
  progress: 75
  notes: "Completed refactoring, running tests"
```

### **Windsurf**
**Seamless project tracking across sessions**

**Benefits:**
- Excellent session handoff capabilities
- Strong project context awareness  
- Natural integration with development workflows

### **Augment Remote Agent**
**Full tool support and context awareness**

**Optimizations:**
- Use `recall_state` for comprehensive context loading
- Leverage memory system for decision tracking
- Export session data for cross-session continuity

## Getting Started Workflows

### **New Project Setup**

**Step 1: Natural Project Creation**
```
You: "I'm building a REST API for a task management app"
Agent: Creating project and initial structure...
```

**Behind the scenes:**
```yaml
create_project:
  name: "Task Management REST API"
  description: "Complete API with authentication, CRUD operations, and data validation"
  status: "planning"

# Auto-becomes current project
# Agent may suggest initial tasks
```

**Step 2: Task Breakdown**
```
You: "I need authentication, user management, and task CRUD operations"
Agent: Breaking down the project into manageable tasks...
```

**Result:**
```yaml
create_task:
  title: "Authentication System"
  priority: "high"
  description: "JWT-based auth with login/register endpoints"

create_task:
  title: "User Management"
  priority: "medium"
  parent_id: "auth_task_id"  # Subtask of authentication

create_task:
  title: "Task CRUD Operations"
  priority: "high"
  description: "Create, read, update, delete for task entities"
```

### **Ongoing Development**

**Progress Updates:**
```
You: "Finished the login endpoint, starting on user registration"
Agent: Updating progress and tracking next steps...
```

**Automatic tracking:**
```yaml
update_task:
  task_id: "login_task"
  completed: true
  notes: "Implemented with JWT token generation and validation"

update_task:
  task_id: "registration_task"  
  progress: 20
  notes: "Started implementation, working on input validation"
```

**Decision Documentation:**
```
You: "I decided to use bcrypt for password hashing instead of plain SHA256"
Agent: Recording this important security decision...
```

```yaml
remember_this:
  content: "Using bcrypt for password hashing (cost factor 12) instead of SHA256 for better security against rainbow table attacks"
  importance: "critical"
  task_id: "auth_task_id"
```

## Advanced Workflow Patterns

### **Hierarchical Task Management**

**Complex Feature Development:**
```yaml
# Main feature
create_task:
  title: "User Dashboard Implementation"
  priority: "high"
  description: "Complete user dashboard with analytics and settings"

# UI Components (subtasks)
create_task:
  title: "Dashboard Analytics Widget"
  parent_id: "dashboard_task_id"
  line_range:
    start_line: 1
    end_line: 50
    file_path: "src/components/Dashboard/Analytics.tsx"

create_task:
  title: "User Settings Panel" 
  parent_id: "dashboard_task_id"
  line_range:
    start_line: 1
    end_line: 75
    file_path: "src/components/Dashboard/Settings.tsx"

# Backend API (subtasks)
create_task:
  title: "Dashboard Data API Endpoint"
  parent_id: "dashboard_task_id"
  line_range:
    start_line: 15
    end_line: 45
    file_path: "src/routes/dashboard.ts"
```

### **Code Location Linking**

**Development Task with Context:**
```yaml
create_task:
  title: "Fix authentication middleware bug"
  description: "Token validation fails for refresh tokens"
  priority: "critical"
  line_range:
    start_line: 67
    end_line: 89
    file_path: "src/middleware/auth.ts"

# Link decision to same code
remember_this:
  content: "Bug caused by JWT library version mismatch. Downgraded to v8.5.1 for compatibility with refresh token validation"
  importance: "high"
  task_id: "bug_fix_task_id"
  line_range:
    start_line: 67
    end_line: 89  
    file_path: "src/middleware/auth.ts"
```

### **Progress Tracking with Blockers**

**Complex Task Management:**
```yaml
update_task:
  task_id: "deployment_task"
  progress: 60
  notes: 
    - "Docker configuration complete"
    - "CI/CD pipeline setup done"
    - "Working on SSL certificate configuration"
  blockers:
    - "Waiting for SSL certificate from IT team"
    - "Production database credentials pending"
    - "Security review required before deployment"
```

### **Session Handoff Patterns**

**End of Development Session:**
```yaml
# Generate comprehensive handoff
generate_handoff_summary:
  format: "detailed"
  project_id: "current"

# Export for permanent storage
export_session:
  format: "markdown"
  include_handoff: true
  raw_markdown: true
```

**Result:**
```markdown
## Development Session Summary

### Completed Today
- ✅ Authentication middleware implementation
- ✅ User registration endpoint with validation  
- ✅ JWT token generation and refresh logic

### In Progress (60% complete)
- 🔄 Dashboard analytics widget
  - Backend API complete
  - Frontend components 60% done
  - Blocked: Waiting for design review

### Next Session Priorities
1. Complete dashboard frontend components
2. Address SSL certificate configuration
3. Begin integration testing

### Critical Decisions Made
- Switched to bcrypt for password hashing (security improvement)
- Using Redis for session storage (performance optimization)

### Active Blockers
- SSL certificate approval (blocking deployment)
- Design review for dashboard (blocking UI completion)
```

## Memory Management Strategies

### **Decision Tracking**

**Architecture Decisions:**
```yaml
remember_this:
  content: "Chose PostgreSQL over MongoDB for ACID compliance and complex relational queries in reporting features"
  title: "Database Technology Decision"
  importance: "critical"
  project_id: "current"
```

**Technical Solutions:**
```yaml
remember_this:
  content: "Implemented rate limiting using Redis sliding window algorithm (100 requests per minute per user)"
  importance: "high"
  task_id: "rate_limiting_task"
  line_range:
    start_line: 23
    end_line: 45
    file_path: "src/middleware/rateLimit.ts"
```

### **Context Retrieval**

**Finding Previous Decisions:**
```yaml
recall_context:
  query: "database choice postgresql"
  importance: "critical"
  limit: 5
```

**Project-Specific Search:**
```yaml
recall_context:
  query: "authentication security"
  project_id: "current_project_id"
  importance: "high"
```

## Data Management Best Practices

### **⚠️ Session Persistence Strategy**

**Critical Understanding:**
- All data exists only during current session
- Session ends = complete data loss
- No automatic backups or file persistence

**Essential Practices:**

**1. Regular Exports:**
```yaml
# Every 1-2 hours during long sessions
export_session:
  format: "markdown"
  include_handoff: true
```

**2. Decision Documentation:**
```yaml
# Document important decisions immediately
remember_this:
  content: "Critical architectural decision with rationale"
  importance: "critical"
```

**3. Handoff Summaries:**
```yaml
# Before ending any session
generate_handoff_summary:
  format: "detailed"
```

### **Performance Optimization**

**Efficient Data Access:**
```yaml
# Use limits on large datasets
list_tasks:
  status: "active"
  limit: 20
  offset: 0

# Filter by project for focused results
recall_context:
  query: "search_term"
  project_id: "specific_project"
  limit: 10
```

**Memory Management:**
```yaml
# Use appropriate importance levels
remember_this:
  content: "Minor implementation detail"
  importance: "low"  # Won't clutter high-priority searches

remember_this:
  content: "Critical security configuration"
  importance: "critical"  # Easy to find later
```

## Collaborative Workflows

### **Team Handoffs**

**Preparing for Team Member:**
```yaml
# Generate detailed project state
export_session:
  format: "markdown"
  include_handoff: true

# Create focused handoff summary
generate_handoff_summary:
  format: "detailed"
  project_id: "shared_project_id"
```

**Result for Team Sharing:**
```markdown
## Project Handoff: Authentication System

### Current Status (78% Complete)
- ✅ Core authentication logic implemented
- ✅ JWT token generation and validation
- 🔄 Password reset flow (85% complete)
- ❌ Two-factor authentication (not started)

### Active Blockers
1. Security audit scheduled for next week
2. Email service integration pending approval
3. Database migration requires DBA review

### Key Decisions & Context
- Using JWT with 15-minute access tokens + 7-day refresh tokens
- Implemented rate limiting: 5 login attempts per 15 minutes
- Password requirements: 12+ chars, mixed case, numbers, symbols

### Next Steps
1. Complete password reset email templates
2. Implement 2FA using TOTP (Google Authenticator)
3. Add audit logging for all auth events

### Code Locations
- Main auth logic: `src/auth/AuthService.ts` (lines 45-180)
- JWT middleware: `src/middleware/auth.ts` (lines 12-67)
- Rate limiting: `src/middleware/rateLimit.ts` (lines 23-45)
```

### **Cross-Project Context**

**Managing Multiple Projects:**
```yaml
# List all projects with status
list_projects:
  limit: 10

# Switch context between projects
set_current_project:
  project_id: "mobile_app_project"

# Project-specific task management
create_task:
  title: "Implement push notifications"
  project_id: "mobile_app_project"
```

## Troubleshooting & Recovery

### **Data Loss Prevention**

**Session Backup Strategy:**
```bash
# Every hour during development
export_session -> save as timestamped markdown file
generate_handoff_summary -> save as project_status.md
```

**Critical Decision Backup:**
```yaml
# Immediately after important decisions
remember_this:
  content: "Decision with full context and rationale"
  importance: "critical"
  
# Then export
export_session:
  format: "markdown"
  raw_markdown: true  # Clean format for external storage
```

### **Context Recovery**

**After Session Restart:**
1. Load previous handoff summary
2. Reference exported session data
3. Use `recall_state` to understand current context
4. Recreate critical project structure if needed

### **Performance Issues**

**Large Dataset Management:**
```yaml
# Use pagination for large task lists
list_tasks:
  limit: 50
  offset: 100  # Skip first 100 tasks

# Filter aggressively
list_tasks:
  status: "active"
  priority: "high"
  project_id: "current_project"
```

**Memory Optimization:**
```yaml
# Focus searches by project
recall_context:
  query: "specific_term"
  project_id: "target_project"
  
# Use importance filtering
recall_context:
  importance: "critical"
  limit: 5
```

## Integration Examples

### **With Git Workflows**

**Code Change Tracking:**
```yaml
# Before making changes
create_task:
  title: "Refactor user authentication"
  line_range:
    start_line: 45
    end_line: 120
    file_path: "src/auth/UserAuth.ts"

# During development
update_task:
  task_id: "refactor_task"
  progress: 50
  notes: "Extracted common validation logic to separate function"

# After completion
update_task:
  task_id: "refactor_task"
  completed: true
  notes: "Refactoring complete, all tests passing, ready for PR"

# Document architectural changes
remember_this:
  content: "Extracted authentication validation into reusable AuthValidator class to reduce code duplication across login/register/reset flows"
  importance: "high"
  task_id: "refactor_task"
```

### **With Testing Workflows**

**Test-Driven Development:**
```yaml
# Plan testing strategy
create_task:
  title: "Unit tests for authentication service"
  parent_id: "auth_feature_task"
  
create_task:
  title: "Integration tests for auth endpoints"
  parent_id: "auth_feature_task"

# Track test coverage
update_task:
  task_id: "unit_tests_task"
  progress: 75
  notes: "Completed tests for login/register, working on password reset tests"

# Document test decisions
remember_this:
  content: "Using Jest with supertest for API testing. Mocking external email service to avoid dependencies in test environment"
  importance: "medium"
  task_id: "integration_tests_task"
```

This comprehensive usage guide enables full utilization of Memory Pickle MCP's 13-tool system for advanced project management, session continuity, and collaborative development workflows across different AI assistant platforms.


================================================
FILE: scripts/update-version.mjs
================================================
#!/usr/bin/env node

/**
 * Automated version synchronization script
 * Updates version references in configuration files to match package.json
 */

import { readFileSync, writeFileSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const rootDir = join(__dirname, '..');

// Get version from package.json
const packageJsonPath = join(rootDir, 'package.json');
const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8'));
const currentVersion = packageJson.version;

console.log(`🔄 Updating version references to ${currentVersion}...`);

// Files that need version updates
const filesToUpdate = [
  {
    path: 'mcp.json',
    pattern: /@cabbages-pre\/memory-pickle-mcp-pre@[\d.]+/g,
    replacement: `@cabbages-pre/memory-pickle-mcp-pre@${currentVersion}`
  },
  {
    path: 'clear-cache-and-test.bat',
    pattern: /@cabbages-pre\/memory-pickle-mcp-pre@[\d.]+/g,
    replacement: `@cabbages-pre/memory-pickle-mcp-pre@${currentVersion}`
  },
  {
    path: 'README.md',
    pattern: /Current: [\d.]+/g,
    replacement: `Current: ${currentVersion}`
  },
  {
    path: 'docs/TOOLS.md',
    pattern: /# Available Tools \(v[\d.]+\)/g,
    replacement: `# Available Tools (v${currentVersion})`
  },
  {
    path: 'docs/TOOLS.md',
    pattern: /## Summary of Changes in v[\d.]+/g,
    replacement: `## Summary of Changes in v${currentVersion}`
  },
  {
    path: 'INTEGRATION-GUIDE.md',
    pattern: /Memory Pickle MCP server v[\d.]+ running/g,
    replacement: `Memory Pickle MCP server v${currentVersion} running`
  }
];

let updatedFiles = 0;

for (const file of filesToUpdate) {
  const filePath = join(rootDir, file.path);
  
  try {
    const content = readFileSync(filePath, 'utf-8');
    const updatedContent = content.replace(file.pattern, file.replacement);
    
    if (content !== updatedContent) {
      writeFileSync(filePath, updatedContent, 'utf-8');
      console.log(`✅ Updated ${file.path}`);
      updatedFiles++;
    } else {
      console.log(`⏭️  No changes needed in ${file.path}`);
    }
  } catch (error) {
    console.warn(`⚠️  Could not update ${file.path}: ${error.message}`);
  }
}

console.log(`\n🎉 Version update complete! Updated ${updatedFiles} files to version ${currentVersion}`);
console.log(`\n💡 Note: Source code now uses getVersion() utility for automatic version sync.`);



================================================
FILE: src/index.ts
================================================
#!/usr/bin/env node

/**
 * Memory Pickle MCP Server
 *
 * A high-performance, in-memory project management system for AI agents that provides:
 * - Project and task management with hierarchical organization
 * - Session-based memory storage for context and notes
 * - Intelligent recall and handoff capabilities
 * - Comprehensive export functionality
 * - Real-time data synchronization with transaction safety
 *
 * Features:
 * - 8 essential MCP tools for streamlined project lifecycle management
 * - In-memory storage with atomic transaction safety
 * - Mutex-based concurrency control for data integrity
 * - Automatic task priority detection and progress tracking
 * - Session activity tracking and analytics
 * - Enhanced handoff summaries for session continuity
 * - Intelligent context recall with semantic search
 * - Memory limits and size monitoring for stability
 *
 * Architecture:
 * - Service-oriented design with clear separation of concerns
 * - Transaction-safe in-memory storage with deep snapshots
 * - Robust error handling with defensive programming
 * - Comprehensive test coverage (261 tests, 16 test suites)
 * - Type-safe operations with Zod schemas
 * - Performance optimized for single-client MCP usage
 *
 * Performance:
 * - Ultra-fast operations (85 items created in ~22ms)
 * - Efficient memory usage with configurable limits
 * - Concurrent operation support with proper serialization
 * - Real-time data consistency without file I/O overhead
 */

import { MemoryPickleCore } from './core/MemoryPickleCore.js';
import { setupRequestHandlers } from './handlers/RequestHandlers.js';
import { createServer, createTransport, startServer } from './server/ServerConfig.js';

/**
 * Initializes and launches the Memory Pickle MCP Server.
 *
 * Sets up the core logic, configures the server, registers request handlers, establishes the transport layer, and starts the server process.
 *
 * @remark
 * If startup fails, the process exits with code 1 without logging to standard output or error to prevent interference with MCP standard I/O.
 */
async function main(): Promise<void> {
  try {
    // Create the core business logic instance
    const core = await MemoryPickleCore.create();

    // Create and configure the MCP server
    const server = createServer();

    // Set up all request handlers
    setupRequestHandlers(server, core);

    // Create transport and start server
    const transport = createTransport();
    await startServer(server, transport);

  } catch (error) {
    console.error("Server startup error:", error);
    process.exit(1);
  }
}

// Start the server
main();



================================================
FILE: src/config/constants.ts
================================================
/**
 * Minimal constants for in-memory operation
 * All file system dependencies removed for pure in-memory mode
 */

import { getVersion } from '../utils/version.js';

// Server configuration
export const SERVER_CONFIG = {
  name: "memory-pickle",
  version: getVersion(),
} as const;


================================================
FILE: src/core/MemoryPickleCore.ts
================================================
import type { ProjectDatabase, Project, Task } from '../types/index.js';
import { InMemoryStore, ProjectService, TaskService, MemoryService, RecallService, ExportService } from '../services/index.js';
import { ValidationUtils } from '../utils/ValidationUtils.js';
import { DryRunResult, formatErrorResponse, ProjectNotFoundError, TaskNotFoundError, ValidationError } from '../utils/errors.js';

/**
 * Core business logic for Memory Pickle MCP Server with robust error handling
 * Contains all the business methods without MCP-specific concerns
 * Implements defensive programming practices and comprehensive validation
 */
export class MemoryPickleCore {
  private inMemoryStore: InMemoryStore;
  private projectService: ProjectService;
  private taskService: TaskService;
  private memoryService: MemoryService;
  private sessionStartTime: Date;
  private taskIndex: Map<string, Task>;
  private isShuttingDown: boolean = false;

  // Enhanced session tracking
  private sessionActivity: {
    tasksCreated: string[];
    tasksUpdated: string[];
    tasksCompleted: string[];
    memoriesCreated: string[];
    projectsCreated: string[];
    projectSwitches: string[];
    lastActiveProject?: string;
    keyDecisions: string[];
    toolUsageCount: Map<string, number>;
  };

  constructor(
    inMemoryStore: InMemoryStore,
    projectService: ProjectService,
    taskService: TaskService,
    memoryService: MemoryService
  ) {
    this.inMemoryStore = inMemoryStore;
    this.projectService = projectService;
    this.taskService = taskService;
    this.memoryService = memoryService;
    this.sessionStartTime = new Date();
    this.taskIndex = new Map();
    this.sessionActivity = {
      tasksCreated: [],
      tasksUpdated: [],
      tasksCompleted: [],
      memoriesCreated: [],
      projectsCreated: [],
      projectSwitches: [],
      keyDecisions: [],
      toolUsageCount: new Map()
    };
    this.buildTaskIndex();
  }

  static async create(): Promise<MemoryPickleCore> {
    const inMemoryStore = new InMemoryStore();
    const projectService = new ProjectService();
    const taskService = new TaskService();
    const memoryService = new MemoryService();

    return new MemoryPickleCore(inMemoryStore, projectService, taskService, memoryService);
  }

  private buildTaskIndex(): void {
    if (this.isShuttingDown) return;

    const database = this.inMemoryStore.getDatabase();
    this.taskIndex.clear();
    for (const task of database.tasks) {
      this.taskIndex.set(task.id, task);
    }
  }

  /**
   * Recalculates and updates project completion percentage based on current tasks
   */
  private async _recalculateProjectCompletion(projectId: string): Promise<void> {
    await this.inMemoryStore.runExclusive(async (db) => {
      const project = this.projectService.findProjectById(db.projects, projectId);
      if (!project) {
        return { result: undefined, commit: false };
      }

      // Use the existing ProjectService logic for consistency
      this.projectService.updateProjectCompletion(project, db.tasks);

      return {
        result: undefined,
        commit: true,
        changedParts: new Set(['projects'] as const)
      };
    });
  }



  /**
   * Safely executes operations with comprehensive error handling
   */
  private async safeExecute<T>(
    operation: string,
    executor: () => Promise<T>
  ): Promise<T> {
    if (this.isShuttingDown) {
      throw new Error(`${operation}: System is shutting down`);
    }

    try {
      return await executor();
    } catch (error) {
      // Log error details for debugging (without console output)
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';

      // Re-throw with operation context
      throw new Error(`${operation}: ${errorMessage}`);
    }
  }

  /**
   * Validates that the current project exists and is accessible
   */
  private validateCurrentProject(): string {
    // Always get fresh database reference to avoid stale data
    const currentDatabase = this.inMemoryStore.getDatabase();
    const currentProjectId = currentDatabase.meta?.current_project_id;

    if (!currentProjectId) {
      throw new ValidationError('current_project_id', undefined, 'No current project set. Use set_current_project or provide project_id parameter.');
    }

    const project = this.projectService.findProjectById(currentDatabase.projects, currentProjectId);
    if (!project) {
      // Auto-fix: clear invalid current project
      currentDatabase.meta.current_project_id = undefined;
      const availableProjects = currentDatabase.projects.map(p => p.id);
      throw new ProjectNotFoundError(currentProjectId, availableProjects);
    }

    return currentProjectId;
  }

  // Project Management Methods
  async create_project(args: any): Promise<any> {
    return this.safeExecute('create_project', async () => {
      this.trackToolUsage('create_project');

      // Basic input validation (MCP schemas handle structure, but we need null checks)
      if (!args || typeof args !== 'object') {
        throw new Error('Invalid arguments - expected object');
      }

      const { name, description = '', status = 'planning', dry_run = false } = args;

      // Check required fields and sanitize
      if (name === undefined || name === null) {
        throw new Error("Missing required field 'name'");
      }

      const sanitizedName = ValidationUtils.sanitizeString(name);
      const sanitizedDescription = ValidationUtils.sanitizeString(description);

      if (!sanitizedName) {
        throw new Error("Field 'name' cannot be empty");
      }
      if (sanitizedName.length > 200) {
        throw new Error('Project name cannot exceed 200 characters');
      }
      if (sanitizedDescription.length > 20000) {
        throw new Error('Project description cannot exceed 20000 characters');
      }
      if (status && !['planning', 'in_progress', 'blocked', 'completed', 'archived'].includes(status)) {
        throw new Error('Invalid project status');
      }

      // Handle dry run
      if (dry_run) {
        return {
          content: [{
            type: "text",
            text: `[DRY RUN] create_project: Would create project '${sanitizedName}' with description '${sanitizedDescription}' and set it as current project. No changes made.`
          }],
          isError: false
        };
      }

      const result = await this.inMemoryStore.runExclusive(async (db) => {
        const newProject = this.projectService.createProject({
          name: sanitizedName,
          description: sanitizedDescription,
          status: status
        });

        db.projects.push(newProject);

        // Automatically set this as the current project
        if (!db.meta) {
          db.meta = {
            last_updated: new Date().toISOString(),
            version: "2.0.0",
            session_count: 0,
            current_project_id: newProject.id
          };
        } else {
          db.meta.current_project_id = newProject.id;
          db.meta.last_updated = new Date().toISOString();
        }

        return {
          result: newProject,
          commit: true,
          changedParts: new Set(['projects', 'meta'] as const)
        };
      });

      // Track session activity
      this.trackToolUsage('create_project', 'project_created', result.id);


      return {
        content: [{
          type: "text",
          text: `[OK] **Project Created Successfully!**\n\n**Name:** ${result.name}\n**ID:** ${result.id}\n**Status:** ${result.status}\n**Description:** ${result.description || 'No description provided'}\n\n[OK] **This project is now your current project.** You can add tasks using the \`create_task\` tool without specifying a project_id.\n\n[INFO] **Note:** Data is stored in memory only. Consider creating markdown files to document your project progress for future reference.`
        }]
      };
    });
  }

  async get_project_status(args: any): Promise<any> {
    const { project_id } = args;

    // Always get fresh database reference
    const currentDatabase = this.inMemoryStore.getDatabase();
    
    // If no project_id provided, try to use the current project from meta
    let targetProjectId = project_id;
    if (!targetProjectId && currentDatabase.meta?.current_project_id) {
      targetProjectId = currentDatabase.meta.current_project_id;
    }

    // If still no project_id, show all projects
    if (!targetProjectId) {
      return this.getAllProjectsStatus();
    }

    const project = this.projectService.findProjectById(currentDatabase.projects, targetProjectId);
    if (!project) {
      throw new Error(`Project not found: ${targetProjectId}`);
    }

    const projectTasks = currentDatabase.tasks.filter(task => task.project_id === targetProjectId);
    const completedTasks = projectTasks.filter(task => task.completed);
    const activeTasks = projectTasks.filter(task => !task.completed);

    // Calculate completion percentage for display (read-only, no side effects)
    const displayCompletion = projectTasks.length > 0
      ? Math.round((completedTasks.length / projectTasks.length) * 100)
      : 0;

    let statusText = `# Project Status: **${project.name}**\n\n`;
    statusText += `**ID:** ${project.id}\n`;
    statusText += `**Status:** ${project.status}\n`;
    statusText += `**Completion:** ${displayCompletion}%\n`;
    statusText += `**Description:** ${project.description || 'No description'}\n\n`;

    statusText += `## Tasks Summary\n`;
    statusText += `- **Total Tasks:** ${projectTasks.length}\n`;
    statusText += `- **Completed:** ${completedTasks.length}\n`;
    statusText += `- **Active:** ${activeTasks.length}\n\n`;

    if (activeTasks.length > 0) {
      statusText += `### Active Tasks:\n`;
      activeTasks.slice(0, 5).forEach(task => {
        statusText += `- **${task.title}** (${task.priority} priority)\n`;
      });
      if (activeTasks.length > 5) {
        statusText += `- ... and ${activeTasks.length - 5} more\n`;
      }
    }

    return {
      content: [{
        type: "text",
        text: statusText
      }]
    };
  }

  /**
   * Get status for all projects when no specific project is requested
   */
  private getAllProjectsStatus(): any {
    const currentDatabase = this.inMemoryStore.getDatabase();
    const projects = currentDatabase.projects;

    if (projects.length === 0) {
      return {
        content: [{
          type: "text",
          text: `[INFO] **No Projects Found**\n\nYou haven't created any projects yet. Use the \`create_project\` tool to get started!`
        }]
      };
    }

    let statusText = `[INFO] **All Projects Overview**\n\n`;

    projects.forEach(project => {
      const projectTasks = currentDatabase.tasks.filter(task => task.project_id === project.id);
      const completedTasks = projectTasks.filter(task => task.completed);
      const completion = projectTasks.length > 0
        ? Math.round((completedTasks.length / projectTasks.length) * 100)
        : 0;

      const isCurrentProject = currentDatabase.meta?.current_project_id === project.id;
      const currentMarker = isCurrentProject ? ' [CURRENT]' : '';

      statusText += `**${project.name}**${currentMarker}\n`;
      statusText += `- Status: ${project.status}\n`;
      statusText += `- Tasks: ${projectTasks.length} total, ${completedTasks.length} completed (${completion}%)\n`;
      statusText += `- ID: ${project.id}\n\n`;
    });

    statusText += `Use \`get_project_status\` with a specific project_id for detailed information.`;

    return {
      content: [{
        type: "text",
        text: statusText
      }]
    };
  }

  async update_project(args: any): Promise<any> {
    const { project_id, name, description, status, dry_run = false } = args;

    if (!project_id) {
      throw new Error('Project ID is required');
    }

    // Handle dry run
    if (dry_run) {
      return {
        content: [{
          type: "text",
          text: `[DRY RUN] update_project: Would update project '${project_id}' with provided changes. No changes made.`
        }],
        isError: false
      };
    }

    const result = await this.inMemoryStore.runExclusive(async (db) => {
      const project = this.projectService.findProjectById(db.projects, project_id);
      if (!project) {
        throw new Error(`Project not found: ${project_id}`);
      }

      const updates: Partial<Project> = {};
      if (name !== undefined) updates.name = name.trim();
      if (description !== undefined) updates.description = description.trim();
      if (status !== undefined) updates.status = status;

      const updatedProject = this.projectService.updateProject(db.projects, project_id, updates);

      return {
        result: updatedProject,
        commit: true,
        changedParts: new Set(['projects'] as const)
      };
    });


    return {
      content: [{
        type: "text",
        text: `[OK] **Project Updated Successfully!**\n\n**Name:** ${result.name}\n**Status:** ${result.status}\n**Description:** ${result.description || 'No description'}`
      }]
    };
  }



  // Task Management Methods
  async create_task(args: any): Promise<any> {
    return this.safeExecute('create_task', async () => {
      this.trackToolUsage('create_task');

      // Basic input validation (MCP schemas handle structure, but we need null checks)
      if (!args || typeof args !== 'object') {
        throw new Error('Invalid arguments - expected object');
      }

      const { title, description = '', priority = 'medium', project_id, parent_id, line_range, dry_run = false } = args;

      // Check required fields and sanitize
      if (title === undefined || title === null) {
        throw new Error("Missing required field 'title'");
      }

      const sanitizedTitle = ValidationUtils.sanitizeString(title);
      const sanitizedDescription = ValidationUtils.sanitizeString(description);

      if (!sanitizedTitle) {
        throw new Error("Field 'title' cannot be empty");
      }
      if (sanitizedTitle.length > 200) {
        throw new Error('Task title cannot exceed 200 characters');
      }
      if (sanitizedDescription.length > 2000) {
        throw new Error('Task description cannot exceed 2000 characters');
      }
      if (priority && !['low', 'medium', 'high', 'critical'].includes(priority)) {
        throw new Error('Invalid task priority');
      }

      // If no project_id provided, try to use the current project from meta
      let targetProjectId = project_id;
      if (!targetProjectId) {
        targetProjectId = this.validateCurrentProject();
      }

      // Handle dry run
      if (dry_run) {
        return {
          content: [{
            type: "text",
            text: `[DRY RUN] create_task: Would create task '${sanitizedTitle}' with priority '${priority}' in project '${targetProjectId}'. No changes made.`
          }],
          isError: false
        };
      }

      const result = await this.inMemoryStore.runExclusive(async (db) => {
        // Verify project exists
        const project = this.projectService.findProjectById(db.projects, targetProjectId);
        if (!project) {
          throw new Error(`Project not found: ${targetProjectId}`);
        }

        // Verify parent task exists if provided
        if (parent_id) {
          const parentTask = this.taskService.findTaskById(db.tasks, parent_id);
          if (!parentTask) {
            throw new Error(`Parent task not found: ${parent_id}`);
          }
          if (parentTask.project_id !== targetProjectId) {
            throw new Error('Parent task must be in the same project');
          }
        }

        const newTask = this.taskService.createTask({
          title: sanitizedTitle,
          description: sanitizedDescription,
          priority,
          project_id: targetProjectId,
          parent_id,
          line_range
        });

        db.tasks.push(newTask);

        return {
          result: newTask,
          commit: true,
          changedParts: new Set(['tasks'] as const)
        };
      });

      this.buildTaskIndex();

      // Recalculate project completion since we added a new task
      await this._recalculateProjectCompletion(targetProjectId);

      // Track session activity
      this.trackToolUsage('create_task', 'task_created', result.id);

      const database = this.inMemoryStore.getDatabase();
      const project = this.projectService.findProjectById(database.projects, targetProjectId);

      return {
        content: [{
          type: "text",
          text: `[OK] **Task Created Successfully!**\n\n**Title:** ${result.title}\n**ID:** ${result.id}\n**Project:** ${project?.name}\n**Priority:** ${result.priority}\n**Description:** ${result.description || 'No description provided'}\n\nTask is ready to be worked on!`
        }]
      };
    });
  }

  async update_task(args: any): Promise<any> {
    return this.safeExecute('update_task', async () => {
      this.trackToolUsage('update_task');

      // Basic input validation (MCP schemas handle structure, but we need null checks)
      if (!args || typeof args !== 'object') {
        throw new Error('Invalid arguments - expected object');
      }

      const { task_id, title, description, priority, completed, progress, notes, blockers, dry_run = false } = args;

      // Check required fields
      if (task_id === undefined || task_id === null) {
        throw new Error("Missing required field 'task_id'");
      }

      const sanitizedTitle = title !== undefined ? ValidationUtils.sanitizeString(title) : undefined;
      const sanitizedDescription = description !== undefined ? ValidationUtils.sanitizeString(description) : undefined;

      if (sanitizedTitle !== undefined && sanitizedTitle.length > 200) {
        throw new Error('Task title cannot exceed 200 characters');
      }
      if (sanitizedDescription !== undefined && sanitizedDescription.length > 2000) {
        throw new Error('Task description cannot exceed 2000 characters');
      }
      if (priority !== undefined && !['low', 'medium', 'high', 'critical'].includes(priority)) {
        throw new Error('Invalid task priority');
      }

      // Handle dry run
      if (dry_run) {
        return {
          content: [{
            type: "text",
            text: `[DRY RUN] update_task: Would update task '${task_id}' with provided changes. No changes made.`
          }],
          isError: false
        };
      }

      const result = await this.inMemoryStore.runExclusive(async (db) => {
      const task = this.taskService.findTaskById(db.tasks, task_id);
      if (!task) {
        throw new Error(`Task not found: ${task_id}`);
      }

      const updates: Partial<Task> = {};
      if (sanitizedTitle !== undefined) updates.title = sanitizedTitle;
      if (sanitizedDescription !== undefined) updates.description = sanitizedDescription;
      if (priority !== undefined) updates.priority = priority;
      if (completed !== undefined) {
        updates.completed = completed;
        if (completed) {
          updates.completed_date = new Date().toISOString();
        }
      }
      if (progress !== undefined) updates.progress = progress;

      const updatedTask = this.taskService.updateTask(db.tasks, task_id, updates);

      // Add notes and blockers if provided
      if (notes) {
        if (!updatedTask.notes) updatedTask.notes = [];

        if (Array.isArray(notes)) {
          // Handle array of notes
          for (const note of notes) {
            if (note?.trim()) {
              updatedTask.notes.push(`${new Date().toISOString()}: ${note.trim()}`);
            }
          }
        } else if (typeof notes === 'string' && notes.trim()) {
          // Handle single note string
          updatedTask.notes.push(`${new Date().toISOString()}: ${notes.trim()}`);
        }
      }

      if (blockers && Array.isArray(blockers)) {
        updatedTask.blockers = [...(updatedTask.blockers || []), ...blockers];
      }

      // Add progress note as memory if provided
      const noteContent = Array.isArray(notes) ? notes.join('; ') : notes;
      if (noteContent?.trim()) {
        this.memoryService.addMemory(db.memories, {
          title: `Progress: ${task.title}`,
          content: noteContent.trim(),
          importance: 'medium',
          project_id: task.project_id,
          task_id: task.id
        });
      }

      return {
        result: updatedTask,
        commit: true,
        changedParts: new Set(['tasks', 'memories'] as const)
      };
    });

    this.buildTaskIndex();

    // Recalculate project completion if task completion status changed
    if (completed !== undefined) {
      await this._recalculateProjectCompletion(result.project_id);
    }

    // Track session activity
    this.trackToolUsage('update_task', 'task_updated', result.id);
    if (completed === true) {
      this.trackToolUsage('update_task', 'task_completed', result.id);
    }

    let response = `[OK] **Task Updated Successfully!**\n\n**${result.title}**\n`;
    if (completed !== undefined) {
      response += `Status: ${result.completed ? 'Completed [DONE]' : 'Active [ACTIVE]'}\n`;
    }
    if (priority !== undefined) {
      response += `Priority: ${result.priority}\n`;
    }
    if (progress !== undefined) {
      response += `Progress: ${progress}%\n`;
    }
    const noteContent = Array.isArray(notes) ? notes.join('; ') : notes;
    if (noteContent?.trim()) {
      response += `Progress note saved.\n`;
    }
    if (blockers && blockers.length > 0) {
      response += `Blockers added: ${blockers.join(', ')}\n`;
    }

      return {
        content: [{
          type: "text",
          text: response
        }]
      };
    });
  }







  // Memory Management Methods
  async remember_this(args: any): Promise<any> {
    return this.safeExecute('remember_this', async () => {
      this.trackToolUsage('remember_this');

      // Basic input validation (MCP schemas handle structure, but we need null checks)
      if (!args || typeof args !== 'object') {
        throw new Error('Invalid arguments - expected object');
      }

      const { content, title, importance = 'medium', project_id, task_id, line_range, dry_run = false } = args;

      // Check required fields and sanitize
      if (content === undefined || content === null) {
        throw new Error("Missing required field 'content'");
      }

      const sanitizedContent = ValidationUtils.sanitizeString(content);
      const sanitizedTitle = title ? ValidationUtils.sanitizeString(title) : undefined;

      if (!sanitizedContent) {
        throw new Error("Field 'content' cannot be empty");
      }

      // Use InMemoryStore validation for memory data
      const memoryData = {
        content: sanitizedContent,
        title: sanitizedTitle,
        importance,
        project_id,
        task_id,
        line_range
      };

      const validatedMemory = this.inMemoryStore.validateAndSanitizeInput('memory', memoryData);

      // Handle dry run
      if (dry_run) {
        return {
          content: [{
            type: "text",
            text: `[DRY RUN] remember_this: Would store memory '${sanitizedTitle || 'Untitled'}' with importance '${importance}'. No changes made.`
          }],
          isError: false
        };
      }

      const result = await this.inMemoryStore.runExclusive(async (db) => {
        const newMemory = this.memoryService.addMemory(db.memories, {
          title: validatedMemory.title || `Memory from ${new Date().toLocaleDateString()}`,
          content: validatedMemory.content,
          importance: validatedMemory.importance,
          project_id: validatedMemory.project_id,
          task_id: validatedMemory.task_id,
          line_range: validatedMemory.line_range
        });

        return {
          result: newMemory,
          commit: true,
          changedParts: new Set(['memories'] as const)
        };
      });

      // Track session activity
      this.trackToolUsage('remember_this', 'memory_created', result.id);

      // Generate markdown suggestion for critical/high importance memories
      let markdownSuggestion = '';
      if (result.importance === 'critical' || result.importance === 'high') {
        const filename = result.title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '') + '.md';
        markdownSuggestion = `\n\n[INFO] **Suggestion:** Since this is ${result.importance} importance, consider creating a markdown file:\n\`\`\`markdown\n# ${result.title}\n\n${result.content}\n\n*Created: ${new Date().toLocaleDateString()}*\n*Importance: ${result.importance}*\n\`\`\`\n\nSave as: \`${filename}\``;
      }

      return {
        content: [{
          type: "text",
          text: `[OK] **Memory Saved!**\n\n**Title:** ${result.title}\n**Importance:** ${result.importance}\n**Content:** ${result.content.substring(0, 100)}${result.content.length > 100 ? '...' : ''}${markdownSuggestion}`
        }]
      };
    });
  }

  /**
   * Universal state recall - replaces recall_context with comprehensive state overview
   */
  async recall_state(args: any = {}): Promise<any> {
    this.trackToolUsage('recall_state');
    const { 
      limit = 20, 
      project_id, 
      include_completed = false, 
      memory_importance,
      focus = 'all',
      format = 'text' 
    } = args;

    const database = this.inMemoryStore.getDatabase();
    
    // Generate comprehensive state data
    const stateData = RecallService.generateStateRecall(database, {
      limit,
      project_id,
      include_completed,
      memory_importance,
      focus
    });

    if (format === 'json') {
      return {
        content: [{
          type: "text",
          text: JSON.stringify(stateData, null, 2)
        }]
      };
    }

    // Default: formatted text response
    const formattedText = RecallService.formatStateRecall(stateData);
    
    return {
      content: [{
        type: "text",
        text: formattedText
      }]
    };
  }

  async recall_context(args: any = {}): Promise<any> {
    const { query, project_id, importance, limit = 10 } = args;

    // Always get fresh database reference
    const database = this.inMemoryStore.getDatabase();
    let memories = database.memories;

    // Apply filters
    if (project_id) {
      memories = memories.filter(memory => memory.project_id === project_id);
    }
    if (importance) {
      memories = memories.filter(memory => memory.importance === importance);
    }

    // Simple text search if query provided
    if (query?.trim()) {
      const searchTerm = query.trim().toLowerCase();
      memories = memories.filter(memory =>
        memory.title.toLowerCase().includes(searchTerm) ||
        memory.content.toLowerCase().includes(searchTerm)
      );
    }

    // Sort by creation date (newest first) and limit
    memories = memories
      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())
      .slice(0, limit);

    if (memories.length === 0) {
      return {
        content: [{
          type: "text",
          text: `[INFO] **No Memories Found**\n\nNo memories match your search criteria.`
        }]
      };
    }

    let response = `# Recalled Memories\n\n`;

    memories.forEach((memory, index) => {
      response += `## ${index + 1}. ${memory.title}\n`;
      response += `**Importance:** ${memory.importance}\n`;
      response += `**Date:** ${new Date(memory.timestamp).toLocaleDateString()}\n`;
      if (memory.project_id) {
        const project = this.projectService.findProjectById(database.projects, memory.project_id);
        response += `**Project:** ${project?.name || 'Unknown'}\n`;
      }
      response += `**Content:** ${memory.content}\n\n`;
    });

    return {
      content: [{
        type: "text",
        text: response
      }]
    };
  }





  async generate_handoff_summary(args: any = {}): Promise<any> {
    this.trackToolUsage('generate_handoff_summary');
    const { project_id, format = 'detailed' } = args;

    // Always get fresh database reference
    const database = this.inMemoryStore.getDatabase();
    let projects = database.projects;
    if (project_id) {
      const project = this.projectService.findProjectById(projects, project_id);
      if (!project) {
        throw new Error(`Project not found: ${project_id}`);
      }
      projects = [project];
    }

    // Get session activity data
    const sessionActivity = this.getSessionActivity();

    let summary = `# [HANDOFF] Enhanced Session Summary\n\n`;
    summary += `**Generated:** ${new Date().toLocaleString()}\n`;
    summary += `**Session Duration:** ${sessionActivity.sessionDuration} minutes\n`;
    summary += `**Session Activity:** ${Object.values(sessionActivity.toolUsageCount).reduce((a, b) => a + b, 0)} tool calls\n\n`;

    // Add session activity summary
    if (sessionActivity.tasksCreated.length > 0 || sessionActivity.tasksUpdated.length > 0 || sessionActivity.memoriesCreated.length > 0) {
      summary += `## [SESSION] What Happened This Session\n\n`;

      if (sessionActivity.tasksCreated.length > 0) {
        summary += `**Tasks Created:** ${sessionActivity.tasksCreated.length}\n`;
        sessionActivity.tasksCreated.slice(0, 3).forEach(taskId => {
          const task = database.tasks.find(t => t.id === taskId);
          if (task) summary += `- ${task.title}\n`;
        });
        if (sessionActivity.tasksCreated.length > 3) {
          summary += `- ... and ${sessionActivity.tasksCreated.length - 3} more\n`;
        }
        summary += `\n`;
      }

      if (sessionActivity.tasksCompleted.length > 0) {
        summary += `**Tasks Completed:** ${sessionActivity.tasksCompleted.length}\n`;
        sessionActivity.tasksCompleted.forEach(taskId => {
          const task = database.tasks.find(t => t.id === taskId);
          if (task) summary += `- ✅ ${task.title}\n`;
        });
        summary += `\n`;
      }

      if (sessionActivity.memoriesCreated.length > 0) {
        summary += `**Notes/Memories Created:** ${sessionActivity.memoriesCreated.length}\n`;
        sessionActivity.memoriesCreated.slice(0, 3).forEach(memoryId => {
          const memory = database.memories.find(m => m.id === memoryId);
          if (memory) summary += `- ${memory.title}\n`;
        });
        if (sessionActivity.memoriesCreated.length > 3) {
          summary += `- ... and ${sessionActivity.memoriesCreated.length - 3} more\n`;
        }
        summary += `\n`;
      }

      if (Object.keys(sessionActivity.toolUsageCount).length > 0) {
        summary += `**Tool Usage:**\n`;
        Object.entries(sessionActivity.toolUsageCount).forEach(([tool, count]) => {
          summary += `- ${tool}: ${count}x\n`;
        });
        summary += `\n`;
      }

      summary += `---\n\n`;
    }

    for (const project of projects) {
      const projectTasks = database.tasks.filter(task => task.project_id === project.id);
      const completedTasks = projectTasks.filter(task => task.completed);
      const activeTasks = projectTasks.filter(task => !task.completed);

      summary += `## [PROJECT] ${project.name}\n\n`;
      summary += `**Status:** ${project.status}\n`;
      summary += `**Progress:** ${project.completion_percentage}%\n`;
      summary += `**Tasks:** ${completedTasks.length}/${projectTasks.length} completed\n\n`;

      if (activeTasks.length > 0) {
        summary += `### [ACTIVE] Active Tasks\n`;
        activeTasks.forEach(task => {
          summary += `- **${task.title}** (${task.priority} priority)\n`;
        });
        summary += `\n`;
      }

      if (completedTasks.length > 0) {
        summary += `### [DONE] Recently Completed\n`;
        completedTasks.slice(-3).forEach(task => {
          summary += `- **${task.title}**\n`;
        });
        summary += `\n`;
      }

      // Recent memories for context
      const recentMemories = database.memories
        .filter(memory => memory.project_id === project.id)
        .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())
        .slice(0, 3);

      if (recentMemories.length > 0) {
        summary += `### [NOTES] Recent Notes\n`;
        recentMemories.forEach(memory => {
          summary += `- **${memory.title}:** ${memory.content.substring(0, 100)}${memory.content.length > 100 ? '...' : ''}\n`;
        });
        summary += `\n`;
      }

      summary += `---\n\n`;
    }

    // Add markdown file suggestion
    const dateStr = new Date().toISOString().split('T')[0];
    const markdownSuggestion = `\n\n[SUGGESTION] Save this summary as a markdown file for future reference:\n\`session-summary-${dateStr}.md\`\n\nThis will help you pick up where you left off in future sessions.`;

    return {
      content: [{
        type: "text",
        text: summary + markdownSuggestion
      }]
    };
  }


  async set_current_project(args: any): Promise<any> {
    this.trackToolUsage('set_current_project');
    const { project_id, dry_run = false } = args;

    if (!project_id) {
      throw new Error('Project ID is required');
    }

    // Handle dry run
    if (dry_run) {
      return {
        content: [{
          type: "text",
          text: `[DRY RUN] set_current_project: Would set project '${project_id}' as current project. No changes made.`
        }],
        isError: false
      };
    }

    const result = await this.inMemoryStore.runExclusive(async (db) => {
      const project = this.projectService.findProjectById(db.projects, project_id);
      if (!project) {
        throw new Error(`Project not found: ${project_id}`);
      }

      // Update meta information
      if (!db.meta) {
        db.meta = {
          last_updated: new Date().toISOString(),
          version: "2.0.0",
          session_count: 0,
          current_project_id: project_id
        };
      } else {
        db.meta.current_project_id = project_id;
      }

      return {
        result: project,
        commit: true,
        changedParts: new Set(['meta'] as const)
      };
    });

    // Track session activity
    this.trackToolUsage('set_current_project', 'project_switched', result.id);


    return {
      content: [{
        type: "text",
        text: `[OK] Current project set to: **${result.name}**\n\nAll new tasks will be added to this project by default.`
      }]
    };
  }



  // Getter methods for accessing internal state (useful for handlers)
  getDatabase(): ProjectDatabase {
    return this.inMemoryStore.getDatabase();
  }

  getTaskIndex(): Map<string, Task> {
    return this.taskIndex;
  }

  /**
   * Cleanup method for graceful shutdown
   */
  async shutdown(): Promise<void> {
    this.isShuttingDown = true;

    // Clear task index to free memory
    this.taskIndex.clear();

    // Cleanup in-memory store
    this.inMemoryStore.cleanup();
  }

  /**
   * Track tool usage and session activity
   */
  private trackToolUsage(toolName: string, activityType?: string, itemId?: string) {
    // Track tool usage count
    const currentCount = this.sessionActivity.toolUsageCount.get(toolName) || 0;
    this.sessionActivity.toolUsageCount.set(toolName, currentCount + 1);

    // Track specific activities
    if (activityType && itemId) {
      switch (activityType) {
        case 'task_created':
          this.sessionActivity.tasksCreated.push(itemId);
          break;
        case 'task_updated':
          this.sessionActivity.tasksUpdated.push(itemId);
          break;
        case 'task_completed':
          this.sessionActivity.tasksCompleted.push(itemId);
          break;
        case 'memory_created':
          this.sessionActivity.memoriesCreated.push(itemId);
          break;
        case 'project_created':
          this.sessionActivity.projectsCreated.push(itemId);
          break;
        case 'project_switched':
          this.sessionActivity.projectSwitches.push(itemId);
          this.sessionActivity.lastActiveProject = itemId;
          break;
      }
    }
  }

  /**
   * Get session activity summary
   */
  getSessionActivity() {
    return {
      ...this.sessionActivity,
      sessionDuration: Math.round((Date.now() - this.sessionStartTime.getTime()) / 1000 / 60),
      toolUsageCount: Object.fromEntries(this.sessionActivity.toolUsageCount)
    };
  }

  /**
   * Reset session activity (useful for testing)
   */
  resetSessionActivity() {
    this.sessionActivity = {
      tasksCreated: [],
      tasksUpdated: [],
      tasksCompleted: [],
      memoriesCreated: [],
      projectsCreated: [],
      projectSwitches: [],
      keyDecisions: [],
      toolUsageCount: new Map()
    };
    this.sessionStartTime = new Date();
  }

  // MCP Tool Wrappers for hidden methods
  
  /**
   * Internal system stats (no longer exposed as MCP tool)
   */
  private async get_system_stats(args: any = {}): Promise<any> {
    this.trackToolUsage('get_system_stats');
    const { dry_run = false } = args;

    if (dry_run) {
      return {
        content: [{
          type: "text",
          text: `[DRY RUN] get_system_stats: Would return current system statistics. No changes made.`
        }],
        isError: false
      };
    }

    const stats = this.getSystemStats();
    
    return {
      content: [{
        type: "text",
        text: `[INFO] **System Statistics**\n\n**Database:**\n- Projects: ${stats.database.projects}\n- Tasks: ${stats.database.tasks}\n- Memories: ${stats.database.memories}\n- Queued Operations: ${stats.database.queuedOperations}\n- Last Updated: ${stats.database.lastUpdated}\n\n**Session:**\n- Task Index Size: ${stats.taskIndexSize}\n- Session Duration: ${stats.sessionDuration} minutes\n- Status: ${stats.isShuttingDown ? 'Shutting down' : 'Active'}`
      }]
    };
  }

  /**
   * Internal data cleanup (no longer exposed as MCP tool)
   */
  private async cleanup_orphaned_data(args: any = {}): Promise<any> {
    return this.safeExecute('cleanup_orphaned_data', async () => {
      this.trackToolUsage('cleanup_orphaned_data');
      const { dry_run = false } = args;

      if (dry_run) {
        return {
          content: [{
            type: "text",
            text: `[DRY RUN] cleanup_orphaned_data: Would perform data integrity cleanup. No changes made.`
          }],
          isError: false
        };
      }

      const stats = await this.cleanupOrphanedData();
      
      let report = `[OK] **Data Cleanup Complete**\n\n`;
      report += `**Issues Fixed:**\n`;
      report += `- Orphaned Tasks: ${stats.orphanedTasks}\n`;
      report += `- Orphaned Memories: ${stats.orphanedMemories}\n`;
      report += `- Invalid Task References: ${stats.invalidTaskReferences}\n`;
      report += `- Invalid Current Project: ${stats.invalidCurrentProject ? 'Yes' : 'No'}\n`;
      report += `- Duplicates Removed: ${stats.duplicatesRemoved}\n`;
      report += `- Corrupted Data Fixed: ${stats.corruptedDataFixed}\n\n`;
      
      const totalIssues = stats.orphanedTasks + stats.orphanedMemories + stats.invalidTaskReferences + 
                         (stats.invalidCurrentProject ? 1 : 0) + stats.duplicatesRemoved + stats.corruptedDataFixed;
      
      if (totalIssues === 0) {
        report += `[INFO] Database is clean - no issues found.`;
      } else {
        report += `[INFO] Fixed ${totalIssues} total issues.`;
      }

      return {
        content: [{
          type: "text",
          text: report
        }]
      };
    });
  }

  // New Read-Only Tools for better agent workflow

  /**
   * List tasks with filtering and pagination
   */
  async list_tasks(args: any = {}): Promise<any> {
    this.trackToolUsage('list_tasks');
    const { status, priority, project_id, completed, limit = 50, offset = 0 } = args;

    const database = this.inMemoryStore.getDatabase();
    let tasks = database.tasks;

    // Apply filters
    if (project_id) {
      tasks = tasks.filter(task => task.project_id === project_id);
    }
    if (status !== undefined) {
      // Map status to completed boolean for consistency
      if (status === 'completed') {
        tasks = tasks.filter(task => task.completed);
      } else if (status === 'active') {
        tasks = tasks.filter(task => !task.completed);
      }
    }
    if (completed !== undefined) {
      tasks = tasks.filter(task => task.completed === completed);
    }
    if (priority) {
      tasks = tasks.filter(task => task.priority === priority);
    }

    // Sort by priority (critical > high > medium > low) and creation date
    const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
    tasks = tasks.sort((a, b) => {
      const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];
      if (priorityDiff !== 0) return priorityDiff;
      return new Date(b.created_date).getTime() - new Date(a.created_date).getTime();
    });

    // Apply pagination
    const totalTasks = tasks.length;
    tasks = tasks.slice(offset, offset + limit);

    // Format response
    let response = `# Task List\n\n`;
    response += `**Total Tasks:** ${totalTasks} (showing ${tasks.length})\n`;
    if (project_id) {
      const project = this.projectService.findProjectById(database.projects, project_id);
      response += `**Project:** ${project?.name || 'Unknown'}\n`;
    }
    response += `\n`;

    if (tasks.length === 0) {
      response += `[INFO] No tasks found matching the criteria.`;
    } else {
      tasks.forEach((task, index) => {
        const status = task.completed ? '[DONE]' : '[ACTIVE]';
        response += `${offset + index + 1}. **${task.title}** ${status}\n`;
        response += `   Priority: ${task.priority} | ID: ${task.id}\n`;
        if (task.progress && task.progress > 0) {
          response += `   Progress: ${task.progress}%\n`;
        }
        if (task.description) {
          response += `   ${task.description.substring(0, 100)}${task.description.length > 100 ? '...' : ''}\n`;
        }
        response += `\n`;
      });
    }

    return {
      content: [{
        type: "text",
        text: response
      }]
    };
  }

  /**
   * List projects with basic info
   */
  async list_projects(args: any = {}): Promise<any> {
    this.trackToolUsage('list_projects');
    const { status, limit = 50, offset = 0 } = args;

    const database = this.inMemoryStore.getDatabase();
    let projects = database.projects;

    // Apply filters
    if (status) {
      projects = projects.filter(project => project.status === status);
    }

    // Sort by status priority and creation date
    const statusOrder = { in_progress: 0, planning: 1, blocked: 2, completed: 3, archived: 4 };
    projects = projects.sort((a, b) => {
      const statusDiff = (statusOrder[a.status] || 99) - (statusOrder[b.status] || 99);
      if (statusDiff !== 0) return statusDiff;
      return new Date(b.created_date).getTime() - new Date(a.created_date).getTime();
    });

    // Apply pagination
    const totalProjects = projects.length;
    projects = projects.slice(offset, offset + limit);

    // Calculate task counts for each project
    const projectsWithStats = projects.map(project => {
      const projectTasks = database.tasks.filter(task => task.project_id === project.id);
      const completedTasks = projectTasks.filter(task => task.completed);
      return {
        ...project,
        totalTasks: projectTasks.length,
        completedTasks: completedTasks.length,
        completion: projectTasks.length > 0 ? Math.round((completedTasks.length / projectTasks.length) * 100) : 0
      };
    });

    // Format response
    let response = `# Project List\n\n`;
    response += `**Total Projects:** ${totalProjects} (showing ${projects.length})\n\n`;

    if (projectsWithStats.length === 0) {
      response += `[INFO] No projects found matching the criteria.`;
    } else {
      projectsWithStats.forEach((project, index) => {
        const isCurrentProject = database.meta?.current_project_id === project.id;
        const currentMarker = isCurrentProject ? ' [CURRENT]' : '';
        
        response += `${offset + index + 1}. **${project.name}**${currentMarker}\n`;
        response += `   Status: ${project.status} | Completion: ${project.completion}%\n`;
        response += `   Tasks: ${project.completedTasks}/${project.totalTasks} completed\n`;
        response += `   ID: ${project.id}\n`;
        if (project.description) {
          response += `   ${project.description.substring(0, 100)}${project.description.length > 100 ? '...' : ''}\n`;
        }
        response += `\n`;
      });
    }

    return {
      content: [{
        type: "text",
        text: response
      }]
    };
  }

  /**
   * Get detailed info for a single task
   */
  async get_task(args: any): Promise<any> {
    this.trackToolUsage('get_task');
    const { task_id } = args;

    if (!task_id) {
      throw new Error('Task ID is required');
    }

    const database = this.inMemoryStore.getDatabase();
    const task = this.taskService.findTaskById(database.tasks, task_id);
    
    if (!task) {
      throw new Error(`Task not found: ${task_id}`);
    }

    // Get project info
    const project = this.projectService.findProjectById(database.projects, task.project_id);
    
    // Get subtasks if any
    const subtasks = database.tasks.filter(t => t.parent_id === task_id);
    
    // Get related memories
    const relatedMemories = database.memories.filter(m => m.task_id === task_id);

    // Format detailed response
    let response = `# Task Details: ${task.title}\n\n`;
    response += `**ID:** ${task.id}\n`;
    response += `**Status:** ${task.completed ? 'Completed [DONE]' : 'Active [ACTIVE]'}\n`;
    response += `**Priority:** ${task.priority}\n`;
    response += `**Project:** ${project?.name || 'Unknown'} (${task.project_id})\n`;
    response += `**Created:** ${new Date(task.created_date).toLocaleDateString()}\n`;
    
    if (task.completed && task.completed_date) {
      response += `**Completed:** ${new Date(task.completed_date).toLocaleDateString()}\n`;
    }
    
    if (task.progress && task.progress > 0) {
      response += `**Progress:** ${task.progress}%\n`;
    }
    
    response += `\n`;

    if (task.description) {
      response += `## Description\n${task.description}\n\n`;
    }

    if (task.line_range) {
      response += `## Code Reference\n`;
      response += `File: ${task.line_range.file_path}\n`;
      response += `Lines: ${task.line_range.start_line}-${task.line_range.end_line}\n\n`;
    }

    if (task.blockers && task.blockers.length > 0) {
      response += `## Blockers\n`;
      task.blockers.forEach((blocker, index) => {
        response += `${index + 1}. ${blocker}\n`;
      });
      response += `\n`;
    }

    if (task.notes && task.notes.length > 0) {
      response += `## Notes\n`;
      task.notes.slice(-3).forEach(note => {
        response += `- ${note}\n`;
      });
      if (task.notes.length > 3) {
        response += `... and ${task.notes.length - 3} more notes\n`;
      }
      response += `\n`;
    }

    if (subtasks.length > 0) {
      response += `## Subtasks (${subtasks.length})\n`;
      subtasks.forEach((subtask, index) => {
        const status = subtask.completed ? '[DONE]' : '[ACTIVE]';
        response += `${index + 1}. **${subtask.title}** ${status}\n`;
      });
      response += `\n`;
    }

    if (relatedMemories.length > 0) {
      response += `## Related Memories (${relatedMemories.length})\n`;
      relatedMemories.slice(0, 3).forEach((memory, index) => {
        response += `${index + 1}. **${memory.title}** (${memory.importance} importance)\n`;
      });
      if (relatedMemories.length > 3) {
        response += `... and ${relatedMemories.length - 3} more memories\n`;
      }
    }

    return {
      content: [{
        type: "text",
        text: response
      }]
    };
  }

  // Additional Maintenance and Utility Tools



  /**
   * Export current session data for persistence
   */
  async export_session(args: any = {}): Promise<any> {
    this.trackToolUsage('export_session');
    const { format = 'markdown', include_handoff = true, raw_markdown = false } = args;

    const database = this.inMemoryStore.getDatabase();
    const sessionActivity = this.getSessionActivity();

    if (format === 'json') {
      const jsonData = ExportService.exportAsJson(database, sessionActivity);
      return {
        content: [{
          type: "text",
          text: `[OK] **Session Data Exported (JSON)**\n\n\`\`\`json\n${jsonData}\n\`\`\`\n\n[INFO] Copy this data to save session state permanently.`
        }]
      };
    }

    // Generate handoff summary if requested
    let handoffSummary = undefined;
    if (include_handoff) {
      const handoffResult = await this.generate_handoff_summary({ format: 'detailed' });
      handoffSummary = handoffResult.content[0].text;
    }

    const markdown = ExportService.exportAsMarkdown(database, sessionActivity, handoffSummary);
    const filename = `session-export-${new Date().toISOString().split('T')[0]}.md`;
    
    // If raw_markdown is requested, return just the clean markdown content
    if (raw_markdown) {
      return {
        content: [{
          type: "text",
          text: markdown
        }]
      };
    }

    // Default behavior: wrap in MCP response format with instructions
    return {
      content: [{
        type: "text",
        text: `[OK] **Session Exported to Markdown**\n\n${markdown}\n\n[INFO] **Recommended:** Save this as \`${filename}\` for permanent storage.\n\n[TIP] **For Clean Markdown:** Use \`export_session\` with \`raw_markdown: true\` or \`generate_handoff_summary\` for unwrapped content.`
      }]
    };
  }

  /**
   * Get system health and performance statistics
   */
  getSystemStats(): {
    database: ReturnType<InMemoryStore['getStats']>;
    taskIndexSize: number;
    sessionDuration: number;
    isShuttingDown: boolean;
  } {
    return {
      database: this.inMemoryStore.getStats(),
      taskIndexSize: this.taskIndex.size,
      sessionDuration: Math.round((Date.now() - this.sessionStartTime.getTime()) / 1000 / 60),
      isShuttingDown: this.isShuttingDown
    };
  }

  /**
   * Simplified cleanup of orphaned data for data integrity recovery
   */
  async cleanupOrphanedData(): Promise<{
    orphanedTasks: number;
    orphanedMemories: number;
    invalidTaskReferences: number;
    invalidCurrentProject: boolean;
    duplicatesRemoved: number;
    corruptedDataFixed: number;
  }> {
    return this.safeExecute('cleanupOrphanedData', async () => {
      const result = await this.inMemoryStore.runExclusive(async (db) => {
        const stats = {
          orphanedTasks: 0,
          orphanedMemories: 0,
          invalidTaskReferences: 0,
          invalidCurrentProject: false,
          duplicatesRemoved: 0,
          corruptedDataFixed: 0
        };

        const projectIds = new Set(db.projects.map(p => p.id));
        const taskIds = new Set(db.tasks.map(t => t.id));

        // 1. Remove duplicates using Set-based deduplication
        const uniqueProjects = new Map();
        db.projects = db.projects.filter(project => {
          if (uniqueProjects.has(project.id)) {
            stats.duplicatesRemoved++;
            return false;
          }
          uniqueProjects.set(project.id, project);
          return true;
        });

        const uniqueTasks = new Map();
        db.tasks = db.tasks.filter(task => {
          if (uniqueTasks.has(task.id)) {
            stats.duplicatesRemoved++;
            return false;
          }
          uniqueTasks.set(task.id, task);
          return true;
        });

        const uniqueMemories = new Map();
        db.memories = db.memories.filter(memory => {
          if (uniqueMemories.has(memory.id)) {
            stats.duplicatesRemoved++;
            return false;
          }
          uniqueMemories.set(memory.id, memory);
          return true;
        });

        // 2. Remove orphaned data
        db.tasks = db.tasks.filter(task => {
          if (!projectIds.has(task.project_id)) {
            stats.orphanedTasks++;
            return false;
          }
          return true;
        });

        db.memories = db.memories.filter(memory => {
          if (memory.project_id && !projectIds.has(memory.project_id)) {
            stats.orphanedMemories++;
            return false;
          }
          return true;
        });

        // 3. Fix invalid references
        db.tasks.forEach(task => {
          if (task.parent_id && !taskIds.has(task.parent_id)) {
            task.parent_id = undefined;
            stats.invalidTaskReferences++;
          }
        });

        db.memories.forEach(memory => {
          if (memory.task_id && !taskIds.has(memory.task_id)) {
            memory.task_id = undefined;
            stats.invalidTaskReferences++;
          }
        });

        // 4. Fix invalid current project
        if (db.meta.current_project_id && !projectIds.has(db.meta.current_project_id)) {
          db.meta.current_project_id = undefined;
          stats.invalidCurrentProject = true;
        }

        // 5. Fix corrupted data (missing required fields)
        db.projects.forEach(project => {
          if (!project.id || !project.name) {
            stats.corruptedDataFixed++;
            if (!project.id) project.id = `project-${Date.now()}-${Math.random()}`;
            if (!project.name) project.name = 'Recovered Project';
          }
        });

        db.tasks.forEach(task => {
          if (!task.id || !task.title) {
            stats.corruptedDataFixed++;
            if (!task.id) task.id = `task-${Date.now()}-${Math.random()}`;
            if (!task.title) task.title = 'Recovered Task';
          }
        });

        db.memories.forEach(memory => {
          if (!memory.id || !memory.content) {
            stats.corruptedDataFixed++;
            if (!memory.id) memory.id = `memory-${Date.now()}-${Math.random()}`;
            if (!memory.content) memory.content = 'Recovered memory content';
          }
        });

        // Only commit if there were actual changes
        const hasChanges = Object.values(stats).some(value =>
          typeof value === 'number' ? value > 0 : value === true
        );

        return {
          result: stats,
          commit: hasChanges,
          changedParts: new Set(['projects', 'tasks', 'memories', 'meta'] as const)
        };
      });

      // Rebuild task index if tasks were changed
      if (result.orphanedTasks > 0 || result.duplicatesRemoved > 0) {
        this.buildTaskIndex();
      }

      return result;
    });
  }


}



================================================
FILE: src/handlers/RequestHandlers.ts
================================================
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  ListResourcesRequestSchema,
  ReadResourceRequestSchema,
  ListResourceTemplatesRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import { ALL_TOOLS } from '../tools/index.js';
import type { MemoryPickleCore } from '../core/MemoryPickleCore.js';
import { formatErrorResponse, MemoryPickleError } from '../utils/errors.js';

/**
 * Registers all MCP request handlers for tools, resources, and templates on the server.
 *
 * Sets up endpoints for tool invocation, in-memory resource access, and resource template listing, enabling MCP-compliant operations using the provided core logic.
 */
export function setupRequestHandlers(server: Server, core: MemoryPickleCore): void {
  // Tool handling
  setupToolHandlers(server, core);

  // Resource handling
  setupResourceHandlers(server, core);

  // Template handling
  setupTemplateHandlers(server);
}

/**
 * Dynamically extracts tool names from the tools definition to ensure synchronization
 */
function getToolNames(): string[] {
  return ALL_TOOLS.map(tool => tool.name);
}

/**
 * Validates that a core method exists for a given tool name
 */
function validateCoreMethod(core: MemoryPickleCore, toolName: string): boolean {
  return typeof (core as any)[toolName] === 'function';
}

/**
 * Registers MCP request handlers for listing available tools and invoking core tool methods.
 *
 * Dynamically synchronizes with the tools definition and validates core method availability.
 * All tool execution errors are caught and returned as proper error responses.
 */
function setupToolHandlers(server: Server, core: MemoryPickleCore): void {
  // Get tool names dynamically from tools definition
  const toolNames = getToolNames();

  // List available tools
  server.setRequestHandler(ListToolsRequestSchema, async () => {
    return {
      tools: ALL_TOOLS
    };
  });

  // Handle tool calls with improved error handling and validation
  server.setRequestHandler(CallToolRequestSchema, async (request) => {
    const { name, arguments: args } = request.params;

    // Validate tool exists in our tools definition
    if (!toolNames.includes(name)) {
      throw new MemoryPickleError(
        `Unknown tool: ${name}. Available tools: ${toolNames.join(', ')}`,
        'UNKNOWN_TOOL'
      );
    }

    // Validate core method exists
    if (!validateCoreMethod(core, name)) {
      throw new MemoryPickleError(
        `Tool not implemented in core: ${name}`,
        'TOOL_NOT_IMPLEMENTED'
      );
    }

    try {
      // Execute the tool method
      const result = await (core as any)[name](args || {});
      return result;
    } catch (error) {
      // Enhanced error handling with context
      const enhancedError = error instanceof Error 
        ? new Error(`Tool '${name}' execution failed: ${error.message}`)
        : new Error(`Tool '${name}' execution failed: Unknown error`);
      
      return formatErrorResponse(enhancedError);
    }
  });
}

/**
 * Registers MCP request handlers for listing and reading virtual in-memory resources.
 *
 * Exposes endpoints to enumerate and access session data and summaries as resources using the `memory://` protocol. All resources are dynamically generated from the in-memory state of the provided core instance.
 *
 * @remark Only the `memory://` protocol is supported. Attempting to access other protocols or unknown resource paths will result in an error.
 */
function setupResourceHandlers(server: Server, core: MemoryPickleCore): void {
  // List resources - return virtual in-memory resources
  server.setRequestHandler(ListResourcesRequestSchema, async () => {
    const resources = [
      {
        uri: `memory:///current-session`,
        mimeType: "application/json",
        name: "Current Session Data",
        description: "In-memory session data including projects, tasks, and memories"
      },
      {
        uri: `memory:///session-summary`,
        mimeType: "text/markdown",
        name: "Session Summary",
        description: "Current session summary in markdown format"
      },
      {
        uri: `memory:///system-stats`,
        mimeType: "application/json",
        name: "System Statistics",
        description: "Current system performance and health statistics"
      }
    ];

    return { resources };
  });

  // Read resources - serve in-memory data with enhanced error handling
  server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
    try {
      const url = new URL(request.params.uri);

      if (url.protocol === 'memory:') {
        const resourcePath = url.pathname;

        switch (resourcePath) {
          case '/current-session':
            // Return current in-memory database as JSON
            const database = core.getDatabase();
            return {
              contents: [{
                uri: request.params.uri,
                mimeType: "application/json",
                text: JSON.stringify(database, null, 2)
              }]
            };

          case '/session-summary':
            // Return session summary as markdown
            const summary = await core.generate_handoff_summary({});
            return {
              contents: [{
                uri: request.params.uri,
                mimeType: "text/markdown",
                text: summary.content[0].text
              }]
            };

          case '/system-stats':
            // Return system statistics as JSON
            const stats = core.getSystemStats();
            return {
              contents: [{
                uri: request.params.uri,
                mimeType: "application/json",
                text: JSON.stringify(stats, null, 2)
              }]
            };

          default:
            throw new MemoryPickleError(
              `Unknown memory resource: ${resourcePath}. Available resources: /current-session, /session-summary, /system-stats`,
              'UNKNOWN_RESOURCE'
            );
        }
      }

      throw new MemoryPickleError(
        `Unsupported protocol: ${url.protocol}. Only memory:// protocol is supported in in-memory mode.`,
        'UNSUPPORTED_PROTOCOL'
      );
    } catch (error) {
      if (error instanceof MemoryPickleError) {
        throw error;
      }
      throw new MemoryPickleError(
        `Resource access failed: ${error instanceof Error ? error.message : 'Unknown error'}`,
        'RESOURCE_ACCESS_ERROR'
      );
    }
  });
}

/**
 * Registers a request handler that lists available resource templates for in-memory resources.
 *
 * The handler advertises templates for accessing in-memory resources such as "current-session", "session-summary", and "system-stats" via the `memory://` protocol.
 */
function setupTemplateHandlers(server: Server): void {
  // List resource templates
  server.setRequestHandler(ListResourceTemplatesRequestSchema, async () => {
    const templates = [];

    // In-memory resource access template
    templates.push({
      uriTemplate: "memory:///{resource}",
      name: "In-Memory Resource Access",
      description: "Access in-memory resources (current-session, session-summary, system-stats)",
      mimeType: "application/json"
    });

    return { resourceTemplates: templates };
  });
}



================================================
FILE: src/server/ServerConfig.ts
================================================
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { getVersion } from '../utils/version.js';

/**
 * MCP Server configuration
 */
export const SERVER_CONFIG = {
  name: "memory-pickle-mcp",
  version: getVersion(),
} as const;

/**
 * Server capabilities configuration
 */
export const SERVER_CAPABILITIES = {
  capabilities: {
    resources: {},
    tools: {},
  },
} as const;

/**
 * Creates and configures an MCP server instance with predefined settings and capabilities.
 *
 * @returns A new {@link Server} initialized with the server's configuration and capabilities.
 */
export function createServer(): Server {
  return new Server(SERVER_CONFIG, SERVER_CAPABILITIES);
}

/**
 * Creates and returns a transport for server communication over standard input and output streams.
 *
 * @returns A {@link StdioServerTransport} instance for stdio-based server communication.
 */
export function createTransport(): StdioServerTransport {
  return new StdioServerTransport();
}

/**
 * Connects the server to the provided stdio transport and starts processing MCP requests.
 *
 * @remark
 * Does not log startup messages to prevent interference with stdio-based MCP communication.
 */
export async function startServer(server: Server, transport: StdioServerTransport): Promise<void> {
  await server.connect(transport);
  // Server is now running and ready to handle MCP requests
}



================================================
FILE: src/services/ExportService.ts
================================================
import type { ProjectDatabase } from '../types/index.js';

/**
 * Service for exporting session data in various formats
 */
export class ExportService {
  
  /**
   * Export session data as JSON
   */
  static exportAsJson(database: ProjectDatabase, sessionActivity: any): string {
    const exportData = {
      export_info: {
        timestamp: new Date().toISOString(),
        session_duration_minutes: sessionActivity.sessionDuration,
        total_tool_calls: Object.values(sessionActivity.toolUsageCount).reduce((a, b) => (a as number) + (b as number), 0)
      },
      database: {
        projects: database.projects,
        tasks: database.tasks,
        memories: database.memories,
        meta: database.meta
      },
      session_activity: sessionActivity
    };

    return JSON.stringify(exportData, null, 2);
  }

  /**
   * Export session data as markdown
   */
  static exportAsMarkdown(database: ProjectDatabase, sessionActivity: any, handoffSummary?: string): string {
    let markdown = `# Session Export - ${new Date().toLocaleDateString()}\n\n`;
    
    if (handoffSummary) {
      markdown += handoffSummary + '\n\n---\n\n';
    }

    markdown += `## Complete Session Data\n\n`;
    markdown += `**Export Time:** ${new Date().toLocaleString()}\n`;
    markdown += `**Session Duration:** ${sessionActivity.sessionDuration} minutes\n`;
    markdown += `**Total Tool Calls:** ${Object.values(sessionActivity.toolUsageCount).reduce((a, b) => (a as number) + (b as number), 0)}\n\n`;

    // Projects section
    markdown += `### Projects (${database.projects.length})\n\n`;
    database.projects.forEach(project => {
      const projectTasks = database.tasks.filter(t => t.project_id === project.id);
      const completedTasks = projectTasks.filter(t => t.completed);
      
      markdown += `#### ${project.name}\n`;
      markdown += `- **Status:** ${project.status}\n`;
      markdown += `- **Progress:** ${project.completion_percentage}%\n`;
      markdown += `- **Tasks:** ${completedTasks.length}/${projectTasks.length} completed\n`;
      markdown += `- **ID:** ${project.id}\n`;
      if (project.description) {
        markdown += `- **Description:** ${project.description}\n`;
      }
      markdown += `\n`;
    });

    // Tasks section
    markdown += `### Tasks (${database.tasks.length})\n\n`;
    database.tasks.forEach(task => {
      const status = task.completed ? '[COMPLETED]' : '[ACTIVE]';
      markdown += `#### ${task.title} ${status}\n`;
      markdown += `- **Priority:** ${task.priority}\n`;
      markdown += `- **Project ID:** ${task.project_id}\n`;
      markdown += `- **ID:** ${task.id}\n`;
      if (task.description) {
        markdown += `- **Description:** ${task.description}\n`;
      }
      if (task.progress && task.progress > 0) {
        markdown += `- **Progress:** ${task.progress}%\n`;
      }
      markdown += `\n`;
    });

    // Memories section
    markdown += `### Memories (${database.memories.length})\n\n`;
    database.memories.forEach(memory => {
      markdown += `#### ${memory.title}\n`;
      markdown += `- **Importance:** ${memory.importance}\n`;
      markdown += `- **Content:** ${memory.content}\n`;
      if (memory.project_id) {
        markdown += `- **Project ID:** ${memory.project_id}\n`;
      }
      if (memory.task_id) {
        markdown += `- **Task ID:** ${memory.task_id}\n`;
      }
      markdown += `- **Created:** ${new Date(memory.timestamp).toLocaleString()}\n`;
      markdown += `\n`;
    });

    return markdown;
  }
}


================================================
FILE: src/services/index.ts
================================================
export { InMemoryStore } from './InMemoryStore.js';
export { ProjectService } from './ProjectService.js';
export { TaskService } from './TaskService.js';
export { MemoryService } from './MemoryService.js';
export { RecallService } from './RecallService.js';
export { ExportService } from './ExportService.js';


================================================
FILE: src/services/InMemoryStore.ts
================================================
import type { ProjectDatabase } from '../types/index.js';
import { ValidationUtils } from '../utils/ValidationUtils.js';
import { getVersion } from '../utils/version.js';

/**
 * High-performance in-memory data store with transaction safety and caching.
 * Maintains data integrity through snapshot-based transactions while optimizing
 * for single-client MCP usage with performance monitoring and smart caching.
 */
export class InMemoryStore {
  private database: ProjectDatabase;
  private operationLock: Promise<void> = Promise.resolve();
  private operationQueue: Array<{
    operation: (db: ProjectDatabase) => Promise<any>;
    resolve: (value: any) => void;
    reject: (error: any) => void;
    timestamp: number;
    operationType: string;
  }> = [];

  // Performance monitoring
  private metrics = {
    totalOperations: 0,
    successfulOperations: 0,
    failedOperations: 0,
    averageOperationTime: 0,
    lastOperationTime: 0,
    cacheHits: 0,
    cacheMisses: 0
  };

  // Simple caching for frequently accessed data
  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();
  private static readonly CACHE_TTL = 30000; // 30 seconds
  private static readonly MAX_CACHE_SIZE = 100;

  // Data size limits to prevent unbounded memory growth
  private static readonly MAX_PROJECTS = 1000;
  private static readonly MAX_TASKS = 10000;
  private static readonly MAX_MEMORIES = 5000;
  private static readonly MAX_QUEUE_SIZE = 100;
  private static readonly MAX_DATABASE_SIZE_MB = 50;

  constructor() {
    this.database = this.createDefaultDatabase();
    this.startMaintenanceTasks();
  }

  /**
   * Starts background maintenance tasks for cache cleanup and metrics
   */
  private startMaintenanceTasks(): void {
    // Cache cleanup every 60 seconds
    setInterval(() => {
      this.cleanupCache();
    }, 60000);
  }

  /**
   * Executes an operation with proper mutex-based transaction safety and performance monitoring.
   * Uses Promise chaining to ensure true serialization without recursion.
   *
   * @param operation - Function that receives the database and returns result with optional commit
   * @param operationType - Type of operation for monitoring (optional)
   * @returns The result from the operation
   */
  async runExclusive<T>(
    operation: (db: ProjectDatabase) => Promise<{
      result: T;
      commit?: boolean;
      changedParts?: Set<'projects' | 'tasks' | 'memories' | 'meta'>;
    }>,
    operationType: string = 'unknown'
  ): Promise<T> {
    const startTime = Date.now();
    
    return new Promise<T>((resolve, reject) => {
      // Queue the operation with its resolve/reject handlers and metadata
      this.operationQueue.push({ 
        operation, 
        resolve, 
        reject, 
        timestamp: startTime,
        operationType 
      });
      
      // Process the queue (this will handle the current operation if it's the only one)
      this.processQueue();
    }).finally(() => {
      // Update performance metrics
      const duration = Date.now() - startTime;
      this.updateMetrics(duration, true);
    });
  }

  /**
   * Processes the operation queue with proper mutex-style locking and enhanced monitoring
   */
  private processQueue(): void {
    if (this.operationQueue.length === 0) return;

    // Chain the next operation to the current lock
    this.operationLock = this.operationLock
      .then(async () => {
        const queueItem = this.operationQueue.shift();
        if (!queueItem) return;

        const { operation, resolve, reject, timestamp, operationType } = queueItem;

        try {
          this.metrics.totalOperations++;

          // Create deep snapshot for true transaction safety
          const databaseSnapshot = this.createDeepSnapshot();

          // Execute operation on isolated snapshot
          const { result, commit = false, changedParts } = await operation(databaseSnapshot);

          // Validate and commit atomically if requested
          if (commit) {
            this.validateDatabaseIntegrity(databaseSnapshot, changedParts);
            this.commitChanges(databaseSnapshot);
            
            // Invalidate cache on data changes
            if (changedParts && changedParts.size > 0) {
              this.invalidateCache(changedParts);
            }
          }

          this.metrics.successfulOperations++;
          resolve(result);
        } catch (error) {
          this.metrics.failedOperations++;
          // Rollback is automatic - snapshot is discarded
          reject(error);
        }
      })
      .catch((error) => {
        // Handle any unexpected errors in the chain
        console.error('Unexpected error in operation queue:', error);
        this.metrics.failedOperations++;
      })
      .finally(() => {
        // Continue processing if there are more operations
        if (this.operationQueue.length > 0) {
          this.processQueue();
        }
      });
  }

  /**
   * Gets cached data or computes and caches the result
   */
  private getCached<T>(key: string, computeFn: () => T, ttl: number = InMemoryStore.CACHE_TTL): T {
    const cached = this.cache.get(key);
    const now = Date.now();

    if (cached && (now - cached.timestamp) < cached.ttl) {
      this.metrics.cacheHits++;
      return cached.data;
    }

    this.metrics.cacheMisses++;
    const data = computeFn();
    
    // Prevent cache from growing too large
    if (this.cache.size >= InMemoryStore.MAX_CACHE_SIZE) {
      // Remove oldest entries
      const entries = Array.from(this.cache.entries());
      entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
      for (let i = 0; i < Math.floor(InMemoryStore.MAX_CACHE_SIZE * 0.2); i++) {
        this.cache.delete(entries[i][0]);
      }
    }

    this.cache.set(key, { data, timestamp: now, ttl });
    return data;
  }

  /**
   * Invalidates cache entries based on changed data parts
   */
  private invalidateCache(changedParts: Set<'projects' | 'tasks' | 'memories' | 'meta'>): void {
    const keysToDelete: string[] = [];
    
    for (const [key] of this.cache) {
      if (changedParts.has('projects') && key.includes('project')) {
        keysToDelete.push(key);
      }
      if (changedParts.has('tasks') && key.includes('task')) {
        keysToDelete.push(key);
      }
      if (changedParts.has('memories') && key.includes('memory')) {
        keysToDelete.push(key);
      }
      if (changedParts.has('meta') && key.includes('meta')) {
        keysToDelete.push(key);
      }
    }

    keysToDelete.forEach(key => this.cache.delete(key));
  }

  /**
   * Cleans up expired cache entries
   */
  private cleanupCache(): void {
    const now = Date.now();
    const keysToDelete: string[] = [];

    for (const [key, value] of this.cache) {
      if ((now - value.timestamp) > value.ttl) {
        keysToDelete.push(key);
      }
    }

    keysToDelete.forEach(key => this.cache.delete(key));
  }

  /**
   * Updates performance metrics
   */
  private updateMetrics(duration: number, success: boolean): void {
    this.metrics.lastOperationTime = duration;
    
    // Update rolling average (simple exponential smoothing)
    const alpha = 0.1; // Smoothing factor
    this.metrics.averageOperationTime = 
      (this.metrics.averageOperationTime * (1 - alpha)) + (duration * alpha);
  }

  /**
   * Public method to load the project database with caching.
   * Returns a snapshot copy of the in-memory database.
   */
  async loadDatabase(): Promise<ProjectDatabase> {
    return this.getCached('database_snapshot', () => this.createSnapshot(), 5000); // 5-second TTL for database snapshots
  }

  /**
   * Public method to save the project database.
   * Updates the in-memory database with validation.
   */
  async saveDatabase(database: ProjectDatabase): Promise<void> {
    this.validateDatabaseIntegrity(database);
    database.meta.last_updated = new Date().toISOString();
    this.commitChanges(database);
    
    // Clear database cache
    this.cache.delete('database_snapshot');
  }

  /**
   * Get direct reference to the database for shared state
   */
  getDatabase(): ProjectDatabase {
    return this.database;
  }

  /**
   * Creates a default empty database structure.
   */
  private createDefaultDatabase(): ProjectDatabase {
    return {
      meta: {
        last_updated: new Date().toISOString(),
        version: getVersion(),
        session_count: 0
      },
      projects: [],
      tasks: [],
      memories: [],
      templates: {}
    };
  }

  /**
   * Creates a deep snapshot copy of the database for true transaction safety
   * Optimized with performance monitoring
   */
  private createDeepSnapshot(): ProjectDatabase {
    const startTime = Date.now();
    
    try {
      // Use JSON serialization for true deep cloning
      // This ensures complete isolation between snapshot and original
      const serialized = JSON.stringify(this.database);
      const snapshot = JSON.parse(serialized) as ProjectDatabase;
      
      const duration = Date.now() - startTime;
      if (duration > 100) { // Log slow snapshot operations
        console.warn(`Slow snapshot creation: ${duration}ms for ${serialized.length} bytes`);
      }
      
      return snapshot;
    } catch (error) {
      throw new Error(`Failed to create database snapshot: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Creates a shallow snapshot copy (kept for backward compatibility)
   * @deprecated Use createDeepSnapshot for true isolation
   */
  private createSnapshot(): ProjectDatabase {
    return this.createDeepSnapshot();
  }

  /**
   * Commits changes atomically to the main database with optimized operations
   */
  private commitChanges(snapshot: ProjectDatabase): void {
    snapshot.meta.last_updated = new Date().toISOString();
    this.database = snapshot;
    
    // Clear any database-related cache entries
    this.cache.delete('database_snapshot');
  }

  /**
   * Validates database size limits to prevent unbounded memory growth
   */
  private validateDatabaseSizeLimits(database: ProjectDatabase): void {
    // Check queue size first
    if (this.operationQueue.length > InMemoryStore.MAX_QUEUE_SIZE) {
      throw new Error(`Operation queue too large: ${this.operationQueue.length} operations. Maximum allowed: ${InMemoryStore.MAX_QUEUE_SIZE}`);
    }

    // Check individual collection sizes
    if (database.projects.length > InMemoryStore.MAX_PROJECTS) {
      throw new Error(`Too many projects: ${database.projects.length}. Maximum allowed: ${InMemoryStore.MAX_PROJECTS}`);
    }

    if (database.tasks.length > InMemoryStore.MAX_TASKS) {
      throw new Error(`Too many tasks: ${database.tasks.length}. Maximum allowed: ${InMemoryStore.MAX_TASKS}`);
    }

    if (database.memories.length > InMemoryStore.MAX_MEMORIES) {
      throw new Error(`Too many memories: ${database.memories.length}. Maximum allowed: ${InMemoryStore.MAX_MEMORIES}`);
    }

    // Check total database size (cached estimate)
    const estimatedSizeMB = this.getCached(
      'database_size_estimate',
      () => this.estimateDatabaseSize(database),
      10000 // 10-second cache for size estimates
    );
    
    if (estimatedSizeMB > InMemoryStore.MAX_DATABASE_SIZE_MB) {
      throw new Error(`Database too large: ~${estimatedSizeMB}MB. Maximum allowed: ${InMemoryStore.MAX_DATABASE_SIZE_MB}MB`);
    }
  }

  /**
   * Estimates database size in MB using JSON serialization length with caching
   */
  private estimateDatabaseSize(database: ProjectDatabase): number {
    try {
      const jsonString = JSON.stringify(database);
      const sizeBytes = new Blob([jsonString]).size;
      return Math.round((sizeBytes / 1024 / 1024) * 100) / 100; // Round to 2 decimal places
    } catch {
      // Fallback rough estimate
      const itemCount = database.projects.length + database.tasks.length + database.memories.length;
      return Math.round((itemCount * 0.001) * 100) / 100; // Assume ~1KB per item average
    }
  }

  /**
   * Validates database integrity after operations using comprehensive validation
   */
  private validateDatabaseIntegrity(
    database: ProjectDatabase,
    changedParts?: Set<'projects' | 'tasks' | 'memories' | 'meta'>
  ): void {
    try {
      // Check size limits first to prevent unbounded growth
      this.validateDatabaseSizeLimits(database);

      // Full database validation (cached)
      const validation = this.getCached(
        `db_validation_${JSON.stringify(changedParts)}`,
        () => ValidationUtils.validateDatabase(database),
        1000 // 1-second cache for validation results
      );
      
      if (!validation.isValid) {
        throw new Error(`Database validation failed: ${validation.errors.join('; ')}`);
      }

      // Additional specific validations based on changed parts
      if (changedParts?.has('projects')) {
        database.projects.forEach((project: any) => {
          const projectValidation = ValidationUtils.validateProject(project);
          if (!projectValidation.isValid) {
            throw new Error(`Project validation failed: ${projectValidation.errors.join('; ')}`);
          }
        });
      }

      if (changedParts?.has('tasks')) {
        database.tasks.forEach((task: any) => {
          const taskValidation = ValidationUtils.validateTask(task);
          if (!taskValidation.isValid) {
            throw new Error(`Task validation failed: ${taskValidation.errors.join('; ')}`);
          }
        });
      }

      if (changedParts?.has('memories')) {
        database.memories.forEach((memory: any) => {
          const memoryValidation = ValidationUtils.validateMemory(memory);
          if (!memoryValidation.isValid) {
            throw new Error(`Memory validation failed: ${memoryValidation.errors.join('; ')}`);
          }
        });
      }

    } catch (error) {
      throw new Error(`Database integrity validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Validates and sanitizes input data before operations with enhanced error context
   */
  validateAndSanitizeInput(type: 'project', data: any): any;
  validateAndSanitizeInput(type: 'task', data: any): any;
  validateAndSanitizeInput(type: 'memory', data: any): any;
  validateAndSanitizeInput(type: 'project' | 'task' | 'memory', data: any): any {
    try {
      switch (type) {
        case 'project':
          const sanitizedProject = ValidationUtils.sanitizeProject(data);
          const projectValidation = ValidationUtils.validateProject(sanitizedProject);
          if (!projectValidation.isValid) {
            throw new Error(`Project validation failed: ${projectValidation.errors.join('; ')}`);
          }
          return sanitizedProject;
        
        case 'task':
          const sanitizedTask = ValidationUtils.sanitizeTask(data);
          const taskValidation = ValidationUtils.validateTask(sanitizedTask);
          if (!taskValidation.isValid) {
            throw new Error(`Task validation failed: ${taskValidation.errors.join('; ')}`);
          }
          return sanitizedTask;
        
        case 'memory':
          const sanitizedMemory = ValidationUtils.sanitizeMemory(data);
          const memoryValidation = ValidationUtils.validateMemory(sanitizedMemory);
          if (!memoryValidation.isValid) {
            throw new Error(`Memory validation failed: ${memoryValidation.errors.join('; ')}`);
          }
          return sanitizedMemory;
        
        default:
          throw new Error(`Unknown validation type: ${type}`);
      }
    } catch (error) {
      throw new Error(`Input validation failed for ${type}: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Cleanup method for graceful shutdown with enhanced cleanup
   */
  cleanup(): void {
    // Reject any pending operations
    this.operationQueue.forEach(({ reject }) => {
      reject(new Error('Database shutting down'));
    });
    this.operationQueue.length = 0;
    
    // Clear cache
    this.cache.clear();
  }

  /**
   * Async cleanup method for graceful shutdown with operation completion
   */
  async shutdownAsync(): Promise<void> {
    // Reject any pending operations
    this.operationQueue.forEach(({ reject }) => {
      reject(new Error('Database shutting down'));
    });
    this.operationQueue.length = 0;
    
    // Clear cache
    this.cache.clear();
    
    // Wait for current operations to complete
    try {
      await this.operationLock;
    } catch {
      // Ignore errors during shutdown
    }
  }

  /**
   * Get comprehensive database statistics for monitoring and optimization
   */
  getStats(): {
    projects: number;
    tasks: number;
    memories: number;
    queuedOperations: number;
    lastUpdated: string;
    estimatedSizeMB: number;
    performance: {
      totalOperations: number;
      successfulOperations: number;
      failedOperations: number;
      successRate: number;
      averageOperationTime: number;
      lastOperationTime: number;
    };
    cache: {
      size: number;
      hitRate: number;
      totalHits: number;
      totalMisses: number;
    };
  } {
    const cacheTotal = this.metrics.cacheHits + this.metrics.cacheMisses;
    
    return {
      projects: this.database.projects.length,
      tasks: this.database.tasks.length,
      memories: this.database.memories.length,
      queuedOperations: this.operationQueue.length,
      lastUpdated: this.database.meta.last_updated,
      estimatedSizeMB: this.estimateDatabaseSize(this.database),
      performance: {
        totalOperations: this.metrics.totalOperations,
        successfulOperations: this.metrics.successfulOperations,
        failedOperations: this.metrics.failedOperations,
        successRate: this.metrics.totalOperations > 0 
          ? Math.round((this.metrics.successfulOperations / this.metrics.totalOperations) * 100) 
          : 100,
        averageOperationTime: Math.round(this.metrics.averageOperationTime * 100) / 100,
        lastOperationTime: this.metrics.lastOperationTime
      },
      cache: {
        size: this.cache.size,
        hitRate: cacheTotal > 0 ? Math.round((this.metrics.cacheHits / cacheTotal) * 100) : 0,
        totalHits: this.metrics.cacheHits,
        totalMisses: this.metrics.cacheMisses
      }
    };
  }
}


================================================
FILE: src/services/MemoryService.ts
================================================
import type { Memory, HandoffSummary, Task, Project, LineRange } from '../types/index.js';
import { generateId } from '../utils/idGenerator.js';

/**
 * Service responsible for memory management and handoff operations
 */
export class MemoryService {
  /**
   * Creates a new memory entry
   */
  createMemory(args: {
    title: string;
    content: string;
    category?: string;
    importance?: 'critical' | 'high' | 'medium' | 'low';
    tags?: string[];
    task_id?: string;
    project_id?: string;
    line_range?: LineRange;
  }): Memory {
    const {
      title,
      content,
      category = 'general',
      importance = 'medium',
      tags = [],
      task_id,
      project_id,
      line_range
    } = args;
    
    if (!title || !content) {
      throw new Error('Title and content are required');
    }

    // Validate line_range if provided
    if (line_range) {
      if (typeof line_range.start_line !== 'number' || typeof line_range.end_line !== 'number') {
        throw new Error('Line range start_line and end_line must be numbers');
      }
      if (line_range.start_line < 1 || line_range.end_line < 1) {
        throw new Error('Line numbers must be positive (1-based)');
      }
      if (line_range.start_line > line_range.end_line) {
        throw new Error('start_line must be less than or equal to end_line');
      }
    }

    return {
      id: generateId('mem'),
      timestamp: new Date().toISOString(),
      category,
      importance,
      tags: Array.isArray(tags) ? tags : [tags],
      title,
      content,
      task_id,
      project_id,
      related_memories: [],
      line_range
    };
  }

  /**
   * Creates and adds a memory to the memories array
   */
  addMemory(memories: Memory[], args: {
    title: string;
    content: string;
    category?: string;
    importance?: 'critical' | 'high' | 'medium' | 'low';
    tags?: string[];
    task_id?: string;
    project_id?: string;
    line_range?: LineRange;
  }): Memory {
    const memory = this.createMemory(args);
    memories.push(memory);
    return memory;
  }

  /**
   * Searches memories based on query and filters
   */
  searchMemories(memories: Memory[], args: {
    query?: string;
    category?: string;
    tags?: string[];
    limit?: number;
  }): Memory[] {
    const { query, category, tags, limit = 10 } = args;

    // Allow searching by tags alone, or require query if no other filters
    if (!query && !category && !tags) {
      return [];
    }

    const lowerQuery = query?.toLowerCase();
    
    const results = memories.filter(memory => {
      const lowerCaseTags = memory.tags.map(t => t.toLowerCase());

      const matchesQuery = !lowerQuery || (
        memory.title.toLowerCase().includes(lowerQuery) ||
        memory.content.toLowerCase().includes(lowerQuery) ||
        lowerCaseTags.some(tag => tag.includes(lowerQuery))
      );

      const matchesCategory = !category || memory.category.toLowerCase() === category.toLowerCase();

      // Use AND logic for tags: all provided tags must be present.
      const matchesTags = !tags || tags.every((tag: string) => lowerCaseTags.includes(tag.toLowerCase()));

      return matchesQuery && matchesCategory && matchesTags;
    }).slice(0, limit);

    return results;
  }

  /**
   * Formats memory search results for display
   */
  formatMemoryResults(memories: Memory[]): string {
    const formattedResults = memories.map(memory => {
      return `## ${memory.title}
**Category:** ${memory.category} | **Importance:** ${memory.importance}
**Tags:** ${memory.tags.join(', ')}
**Date:** ${new Date(memory.timestamp).toLocaleDateString()}

${memory.content}`;
    }).join('\n\n---\n\n');

    return `[FOUND] Found ${memories.length} relevant memories:\n\n${formattedResults}`;
  }

  /**
   * Generates a handoff summary for session transitions
   */
  generateHandoffSummary(
    project: Project,
    tasks: Task[],
    sessionCount: number,
    sessionStartTime?: Date
  ): HandoffSummary {
    // Get tasks completed in current session (default to last 2 hours if no session start time)
    const sessionCutoff = sessionStartTime || new Date(Date.now() - 2 * 60 * 60 * 1000);
    
    const recentlyCompleted = tasks
      .filter(t =>
        t.project_id === project.id &&
        t.completed &&
        t.completed_date &&
        new Date(t.completed_date) > sessionCutoff
      )
      .map(t => t.title);

    const inProgress = tasks
      .filter(t => 
        t.project_id === project.id && 
        !t.completed &&
        (t.progress && t.progress > 0)
      )
      .map(t => `${t.title} (${t.progress}%)`);

    const blocked = tasks
      .filter(t => 
        t.project_id === project.id && 
        t.blockers && 
        t.blockers.length > 0
      )
      .map(t => `${t.title}: ${t.blockers!.join(', ')}`);

    const upcoming = tasks
      .filter(t => 
        t.project_id === project.id && 
        !t.completed &&
        (t.priority === 'critical' || t.priority === 'high')
      )
      .sort((a, b) => {
        const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
        return priorityOrder[a.priority] - priorityOrder[b.priority];
      })
      .slice(0, 5)
      .map(t => `${t.title} (${t.priority})`);

    return {
      project_name: project.name,
      completion_percentage: project.completion_percentage,
      last_session_date: new Date().toISOString(),
      completed_in_last_session: recentlyCompleted,
      in_progress: inProgress,
      blocked_items: blocked,
      next_priorities: upcoming,
      session_notes: `Session #${sessionCount + 1}`
    };
  }

  /**
   * Formats handoff summary for display
   */
  formatHandoffSummary(handoff: HandoffSummary, format: 'detailed' | 'compact' = 'detailed'): string {
    let result = `# [HANDOFF] Project Handoff Summary\n\n`;
    result += `**Project:** ${handoff.project_name}\n`;
    result += `**Completion:** ${handoff.completion_percentage}%\n`;
    result += `**Session Date:** ${new Date(handoff.last_session_date).toLocaleString()}\n\n`;

    if (format === 'detailed') {
      result += `## [DONE] Completed This Session\n`;
      if (handoff.completed_in_last_session.length > 0) {
        handoff.completed_in_last_session.forEach(item => {
          result += `- ${item}\n`;
        });
      } else {
        result += `- No tasks completed this session\n`;
      }

      result += `\n## [ACTIVE] In Progress\n`;
      if (handoff.in_progress.length > 0) {
        handoff.in_progress.forEach(item => {
          result += `- ${item}\n`;
        });
      } else {
        result += `- No tasks currently in progress\n`;
      }

      if (handoff.blocked_items.length > 0) {
        result += `\n## [BLOCKED] Blocked Items\n`;
        handoff.blocked_items.forEach(item => {
          result += `- ${item}\n`;
        });
      }

      result += `\n## [NEXT] Next Priorities\n`;
      if (handoff.next_priorities.length > 0) {
        handoff.next_priorities.forEach(item => {
          result += `- ${item}\n`;
        });
      } else {
        result += `- No high priority items pending\n`;
      }
    } else {
      // Compact format for easy copy/paste
      result += `**Quick Summary:**\n`;
      result += `Completed: ${handoff.completed_in_last_session.length} tasks | `;
      result += `In Progress: ${handoff.in_progress.length} | `;
      result += `Blocked: ${handoff.blocked_items.length}\n\n`;
      result += `**Continue with:** ${handoff.next_priorities[0] || 'Review project status for next tasks'}`;
    }

    result += `\n\n---\n*Copy this summary to your next chat session to continue where you left off.*`;

    return result;
  }


}


================================================
FILE: src/services/ProjectService.ts
================================================
import type { Project, Task, ProjectSummary } from '../types/index.js';
import { generateId } from '../utils/idGenerator.js';

/**
 * Service responsible for project management operations
 */
export class ProjectService {
  /**
   * Creates a new project
   */
  createProject(args: { name: string; description?: string; status?: 'planning' | 'in_progress' | 'blocked' | 'completed' | 'archived' }): Project {
    const { name, description, status = 'planning' } = args;
    
    if (!name) {
      throw new Error('Project name is required');
    }

    // Validate status if provided
    if (status && !['planning', 'in_progress', 'blocked', 'completed', 'archived'].includes(status)) {
      throw new Error(`Invalid project status: ${status}. Must be one of: planning, in_progress, blocked, completed, archived`);
    }

    return {
      id: generateId('proj'),
      name,
      description,
      created_date: new Date().toISOString(),
      status,
      completion_percentage: 0,
      tasks: [],
      milestones: []
    };
  }

  /**
   * Updates project completion percentage based on tasks
   */
  updateProjectCompletion(project: Project, tasks: Task[]): void {
    const projectTasks = tasks.filter(t => t.project_id === project.id);
    
    if (projectTasks.length === 0) {
      project.completion_percentage = 0;
      return;
    }

    const completedTasks = projectTasks.filter(t => t.completed).length;
    project.completion_percentage = Math.round((completedTasks / projectTasks.length) * 100);

    if (project.completion_percentage === 100) {
      project.status = 'completed';
    } else if (project.completion_percentage > 0) {
      project.status = 'in_progress';
    }
  }

  /**
   * Generates a comprehensive project summary
   */
  generateProjectSummary(project: Project, tasks: Task[]): ProjectSummary {
    const projectTasks = tasks.filter(t => t.project_id === project.id);
    
    const completed = projectTasks.filter(t => t.completed);
    const inProgress = projectTasks.filter(t => !t.completed && t.progress && t.progress > 0);
    const blocked = projectTasks.filter(t => t.blockers && t.blockers.length > 0);
    const critical = projectTasks.filter(t => t.priority === 'critical');
    
    const recentCompletions = completed
      .filter(t => t.completed_date)
      .sort((a, b) => new Date(b.completed_date!).getTime() - new Date(a.completed_date!).getTime())
      .slice(0, 5);

    const upcoming = projectTasks
      .filter(t => !t.completed)
      .sort((a, b) => {
        const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
        return priorityOrder[a.priority] - priorityOrder[b.priority];
      })
      .slice(0, 5);

    return {
      project,
      total_tasks: projectTasks.length,
      completed_tasks: completed.length,
      in_progress_tasks: inProgress.length,
      blocked_tasks: blocked.length,
      recent_completions: recentCompletions,
      upcoming_tasks: upcoming,
      critical_items: critical,
      completion_percentage: project.completion_percentage
    };
  }

  /**
   * Updates a project with new values
   */
  updateProject(projects: Project[], projectId: string, updates: Partial<Project>): Project {
    const project = this.findProjectById(projects, projectId);
    if (!project) {
      throw new Error(`Project not found: ${projectId}`);
    }

    // Apply updates
    Object.assign(project, updates);
    return project;
  }

  /**
   * Finds a project by ID
   */
  findProjectById(projects: Project[], projectId: string): Project | undefined {
    return projects.find(p => p.id === projectId);
  }

  /**
   * Gets the completion percentage for a project
   */
  getProjectCompletion(projects: Project[], projectId: string): number {
    const project = this.findProjectById(projects, projectId);
    return project?.completion_percentage || 0;
  }

  /**
   * Formats all projects overview
   */
  formatAllProjectsOverview(projects: Project[], tasks: Task[]): string {
    if (projects.length === 0) {
      return `📋 No projects found. Use \`create_project\` to start a new project.`;
    }

    let result = `# 📊 All Projects Overview\n\n`;
    
    projects.forEach(project => {
      const projectTasks = tasks.filter(t => t.project_id === project.id);
      const completedTasks = projectTasks.filter(t => t.completed).length;
      
      result += `## ${project.name}\n`;
      result += `**Status:** ${project.status} | **Completion:** ${project.completion_percentage}%\n`;
      result += `**Tasks:** ${completedTasks}/${projectTasks.length} completed\n`;
      result += `**ID:** ${project.id}\n\n`;
    });

    return result;
  }
}


================================================
FILE: src/services/RecallService.ts
================================================
import type { ProjectDatabase, Project, Task, Memory } from '../types/index.js';

/**
 * Service for universal state recall - combines projects, tasks, and memories
 * into optimized, ranked JSON responses for agent planning
 */
export class RecallService {

  /**
   * Universal state recall - returns ranked, filtered context in single call
   */
  static generateStateRecall(
    database: ProjectDatabase,
    args: {
      limit?: number;
      project_id?: string;
      include_completed?: boolean;
      memory_importance?: 'low' | 'medium' | 'high' | 'critical';
      focus?: 'tasks' | 'projects' | 'memories' | 'all';
    } = {}
  ): {
    current_project: Project | null;
    active_tasks: Task[];
    overdue_tasks: Task[];
    recent_completions: Task[];
    recent_memories: Memory[];
    project_stats: {
      total: number;
      in_progress: number;
      completed: number;
      blocked: number;
    };
    task_stats: {
      total: number;
      active: number;
      completed: number;
      critical: number;
      high_priority: number;
    };
    session_context: {
      current_project_id?: string;
      total_projects: number;
      total_tasks: number;
      total_memories: number;
    };
  } {
    const {
      limit = 20,
      project_id,
      include_completed = false,
      memory_importance,
      focus = 'all'
    } = args;

    // Get current project
    const currentProjectId = project_id || database.meta?.current_project_id;
    const currentProject = currentProjectId 
      ? database.projects.find(p => p.id === currentProjectId) || null
      : null;

    // Filter tasks by project if specified
    let tasks = database.tasks;
    if (currentProjectId) {
      tasks = tasks.filter(t => t.project_id === currentProjectId);
    }

    // Get active tasks (prioritized and ranked)
    const activeTasks = tasks
      .filter(t => !t.completed)
      .sort((a, b) => {
        // Sort by priority first, then creation date
        const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
        const priorityDiff = priorityOrder[a.priority] - priorityOrder[b.priority];
        if (priorityDiff !== 0) return priorityDiff;
        return new Date(a.created_date).getTime() - new Date(b.created_date).getTime();
      })
      .slice(0, Math.floor(limit * 0.6)); // 60% of limit for active tasks

    // Get overdue tasks (tasks with blockers or high priority older than 7 days)
    const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
    const overdueTasks = tasks
      .filter(t => !t.completed && (
        (t.blockers && t.blockers.length > 0) ||
        (t.priority === 'critical' && new Date(t.created_date) < sevenDaysAgo)
      ))
      .slice(0, 5);

    // Get recent completions
    const recentCompletions = include_completed
      ? tasks
          .filter(t => t.completed && t.completed_date)
          .sort((a, b) => new Date(b.completed_date!).getTime() - new Date(a.completed_date!).getTime())
          .slice(0, Math.floor(limit * 0.2)) // 20% of limit
      : [];

    // Filter memories
    let memories = database.memories;
    if (currentProjectId) {
      memories = memories.filter(m => 
        m.project_id === currentProjectId || 
        (!m.project_id && m.task_id && tasks.some(t => t.id === m.task_id))
      );
    }
    if (memory_importance) {
      memories = memories.filter(m => m.importance === memory_importance);
    }

    // Get recent memories (ranked by importance and recency)
    const recentMemories = memories
      .sort((a, b) => {
        // Sort by importance first, then recency
        const importanceOrder = { critical: 0, high: 1, medium: 2, low: 3 };
        const importanceDiff = importanceOrder[a.importance] - importanceOrder[b.importance];
        if (importanceDiff !== 0) return importanceDiff;
        return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();
      })
      .slice(0, Math.floor(limit * 0.2)); // 20% of limit

    // Calculate project stats
    const projectStats = {
      total: database.projects.length,
      in_progress: database.projects.filter(p => p.status === 'in_progress').length,
      completed: database.projects.filter(p => p.status === 'completed').length,
      blocked: database.projects.filter(p => p.status === 'blocked').length
    };

    // Calculate task stats
    const allTasks = database.tasks;
    const taskStats = {
      total: allTasks.length,
      active: allTasks.filter(t => !t.completed).length,
      completed: allTasks.filter(t => t.completed).length,
      critical: allTasks.filter(t => t.priority === 'critical' && !t.completed).length,
      high_priority: allTasks.filter(t => t.priority === 'high' && !t.completed).length
    };

    // Session context
    const sessionContext = {
      current_project_id: currentProjectId,
      total_projects: database.projects.length,
      total_tasks: database.tasks.length,
      total_memories: database.memories.length
    };

    return {
      current_project: currentProject,
      active_tasks: activeTasks,
      overdue_tasks: overdueTasks,
      recent_completions: recentCompletions,
      recent_memories: recentMemories,
      project_stats: projectStats,
      task_stats: taskStats,
      session_context: sessionContext
    };
  }

  /**
   * Format state recall as human-readable text
   */
  static formatStateRecall(stateData: ReturnType<typeof RecallService.generateStateRecall>): string {
    let output = `# 🎯 Universal State Recall\n\n`;

    // Current project context
    if (stateData.current_project) {
      output += `## 📋 Current Project: **${stateData.current_project.name}**\n`;
      output += `Status: ${stateData.current_project.status} | Completion: ${stateData.current_project.completion_percentage}%\n`;
      if (stateData.current_project.description) {
        output += `${stateData.current_project.description.substring(0, 150)}${stateData.current_project.description.length > 150 ? '...' : ''}\n`;
      }
      output += `\n`;
    } else {
      output += `## 📋 No Current Project Set\n`;
      output += `Use \`set_current_project\` to focus on a specific project.\n\n`;
    }

    // Active tasks (prioritized)
    if (stateData.active_tasks.length > 0) {
      output += `## 🔥 Active Tasks (${stateData.active_tasks.length})\n`;
      stateData.active_tasks.forEach((task, index) => {
        const priorityEmoji = { critical: '🚨', high: '⚡', medium: '📌', low: '📝' };
        output += `${index + 1}. ${priorityEmoji[task.priority]} **${task.title}** (${task.priority})\n`;
        if (task.progress && task.progress > 0) {
          output += `   Progress: ${task.progress}%\n`;
        }
      });
      output += `\n`;
    }

    // Overdue/blocked tasks
    if (stateData.overdue_tasks.length > 0) {
      output += `## ⚠️ Overdue/Blocked Tasks (${stateData.overdue_tasks.length})\n`;
      stateData.overdue_tasks.forEach((task, index) => {
        output += `${index + 1}. **${task.title}** (${task.priority})\n`;
        if (task.blockers && task.blockers.length > 0) {
          output += `   🚫 Blocked: ${task.blockers[0]}\n`;
        }
      });
      output += `\n`;
    }

    // Recent completions
    if (stateData.recent_completions.length > 0) {
      output += `## ✅ Recent Completions (${stateData.recent_completions.length})\n`;
      stateData.recent_completions.forEach((task, index) => {
        const completedDate = task.completed_date 
          ? new Date(task.completed_date).toLocaleDateString()
          : 'Recently';
        output += `${index + 1}. **${task.title}** (${completedDate})\n`;
      });
      output += `\n`;
    }

    // Recent memories
    if (stateData.recent_memories.length > 0) {
      output += `## 🧠 Recent Context (${stateData.recent_memories.length})\n`;
      stateData.recent_memories.forEach((memory, index) => {
        const importanceEmoji = { critical: '🚨', high: '⚡', medium: '📝', low: '💡' };
        output += `${index + 1}. ${importanceEmoji[memory.importance]} **${memory.title}**\n`;
        output += `   ${memory.content.substring(0, 100)}${memory.content.length > 100 ? '...' : ''}\n`;
      });
      output += `\n`;
    }

    // Summary stats
    output += `## 📊 Summary Statistics\n`;
    output += `**Projects:** ${stateData.project_stats.total} total`;
    if (stateData.project_stats.in_progress > 0) {
      output += ` (${stateData.project_stats.in_progress} in progress)`;
    }
    if (stateData.project_stats.blocked > 0) {
      output += ` (${stateData.project_stats.blocked} blocked)`;
    }
    output += `\n`;
    
    output += `**Tasks:** ${stateData.task_stats.active}/${stateData.task_stats.total} active`;
    if (stateData.task_stats.critical > 0) {
      output += ` (${stateData.task_stats.critical} critical)`;
    }
    output += `\n`;
    
    output += `**Memories:** ${stateData.session_context.total_memories} stored\n`;

    return output;
  }

  /**
   * Search and rank memories with advanced filtering
   */
  static searchMemories(
    memories: Memory[],
    query: string,
    options: {
      importance?: 'low' | 'medium' | 'high' | 'critical';
      project_id?: string;
      task_id?: string;
      limit?: number;
    } = {}
  ): Memory[] {
    const { importance, project_id, task_id, limit = 10 } = options;
    
    let filtered = memories;

    // Apply filters
    if (importance) {
      filtered = filtered.filter(m => m.importance === importance);
    }
    if (project_id) {
      filtered = filtered.filter(m => m.project_id === project_id);
    }
    if (task_id) {
      filtered = filtered.filter(m => m.task_id === task_id);
    }

    // Text search with ranking
    if (query?.trim()) {
      const searchTerm = query.trim().toLowerCase();
      filtered = filtered
        .map(memory => {
          let score = 0;
          const titleMatch = memory.title.toLowerCase().includes(searchTerm);
          const contentMatch = memory.content.toLowerCase().includes(searchTerm);
          
          if (titleMatch) score += 10;
          if (contentMatch) score += 5;
          
          // Boost score based on importance
          const importanceBoost = { critical: 4, high: 3, medium: 2, low: 1 };
          score += importanceBoost[memory.importance];
          
          // Boost recent memories
          const age = Date.now() - new Date(memory.timestamp).getTime();
          const daysSinceCreated = age / (1000 * 60 * 60 * 24);
          if (daysSinceCreated < 7) score += 2;
          
          return { memory, score };
        })
        .filter(item => item.score > 0)
        .sort((a, b) => b.score - a.score)
        .map(item => item.memory);
    } else {
      // Sort by importance and recency if no search query
      const importanceOrder = { critical: 0, high: 1, medium: 2, low: 3 };
      filtered = filtered.sort((a, b) => {
        const importanceDiff = importanceOrder[a.importance] - importanceOrder[b.importance];
        if (importanceDiff !== 0) return importanceDiff;
        return new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime();
      });
    }

    return filtered.slice(0, limit);
  }
}


================================================
FILE: src/services/TaskService.ts
================================================
import type { Task, Project, LineRange } from '../types/index.js';
import { generateId } from '../utils/idGenerator.js';

/**
 * High-performance service for task management operations with optimized algorithms and caching
 */
export class TaskService {
  // Cache for priority detection to avoid repeated regex operations
  private static priorityCache = new Map<string, 'critical' | 'high' | 'medium' | 'low'>();
  private static readonly PRIORITY_CACHE_SIZE = 100;

  /**
   * Creates a new task with intelligent priority detection
   */
  createTask(args: {
    title: string;
    description?: string;
    parent_id?: string;
    priority?: 'critical' | 'high' | 'medium' | 'low';
    due_date?: string;
    tags?: string[];
    project_id: string;
    line_range?: LineRange;
  }): Task {
    const {
      title,
      description,
      parent_id,
      priority,
      due_date,
      tags = [],
      project_id,
      line_range
    } = args;

    // Validate required fields
    if (!title?.trim()) {
      throw new Error('Task title is required and cannot be empty');
    }
    if (!project_id?.trim()) {
      throw new Error('Project ID is required and cannot be empty');
    }

    // Validate priority if provided
    if (priority && !['critical', 'high', 'medium', 'low'].includes(priority)) {
      throw new Error(`Invalid priority: ${priority}. Must be one of: critical, high, medium, low`);
    }

    // Validate line_range if provided
    this.validateLineRange(line_range);

    // Auto-detect priority from title and description
    const detectedPriority = priority || this.detectPriorityFromText(title, description);

    return {
      id: generateId('task'),
      project_id,
      parent_id,
      title: title.trim(),
      description: description?.trim(),
      completed: false,
      progress: 0,
      created_date: new Date().toISOString(),
      due_date,
      priority: detectedPriority,
      tags: Array.isArray(tags) ? tags.filter(tag => tag?.trim()) : [],
      subtasks: [],
      notes: [],
      blockers: [],
      line_range
    };
  }

  /**
   * Validates line range parameters
   */
  private validateLineRange(line_range: LineRange | undefined): void {
    if (!line_range) return;
    
    if (typeof line_range.start_line !== 'number' || typeof line_range.end_line !== 'number') {
      throw new Error('Line range start_line and end_line must be numbers');
    }
    if (line_range.start_line < 1 || line_range.end_line < 1) {
      throw new Error('Line numbers must be positive (1-based)');
    }
    if (line_range.start_line > line_range.end_line) {
      throw new Error('start_line must be less than or equal to end_line');
    }
    if (line_range.file_path && !line_range.file_path.trim()) {
      throw new Error('file_path cannot be empty if provided');
    }
  }

  /**
   * Updates task progress and related fields efficiently
   */
  updateTaskProgress(task: Task, args: {
    progress?: number;
    notes?: string;
    blockers?: string[];
  }): void {
    const { progress, notes, blockers } = args;

    if (progress !== undefined) {
      if (typeof progress !== 'number' || progress < 0 || progress > 100) {
        throw new Error('Progress must be a number between 0 and 100');
      }
      
      task.progress = Math.round(progress); // Round to avoid floating point issues
      
      if (task.progress === 100 && !task.completed) {
        task.completed = true;
        task.completed_date = new Date().toISOString();
      } else if (task.progress < 100 && task.completed) {
        // If progress is reduced below 100, un-complete the task
        task.completed = false;
        task.completed_date = undefined;
      }
    }

    if (notes?.trim()) {
      task.notes = task.notes || [];
      task.notes.push(`[${new Date().toLocaleString()}] ${notes.trim()}`);
    }

    if (blockers !== undefined) {
      task.blockers = blockers.filter(blocker => typeof blocker === 'string' && blocker.trim());
    }
  }

  /**
   * Updates parent task progress based on subtasks with optimized calculation
   */
  updateParentProgress(parentTask: Task, allTasks: Task[]): void {
    if (!parentTask.subtasks || parentTask.subtasks.length === 0) return;

    // Use Set for O(1) lookup instead of Array.includes
    const subtaskIds = new Set(parentTask.subtasks);
    const subtasks = allTasks.filter(t => subtaskIds.has(t.id));

    if (subtasks.length === 0) return;

    const totalProgress = subtasks.reduce((sum, task) => {
      return sum + (task.completed ? 100 : (task.progress || 0));
    }, 0);

    parentTask.progress = Math.round(totalProgress / subtasks.length);
    
    if (parentTask.progress === 100 && !parentTask.completed) {
      parentTask.completed = true;
      parentTask.completed_date = new Date().toISOString();
    }
  }

  /**
   * Links task to project and parent task efficiently
   */
  linkTaskToProject(task: Task, project: Project, parentTask?: Task): void {
    // Add to project's task list if not already present
    if (!project.tasks.includes(task.id)) {
      project.tasks.push(task.id);
    }

    // Add to parent's subtasks if applicable
    if (parentTask && task.parent_id === parentTask.id) {
      parentTask.subtasks = parentTask.subtasks || [];
      if (!parentTask.subtasks.includes(task.id)) {
        parentTask.subtasks.push(task.id);
      }
    }
  }

  /**
   * Finds a task by ID with error context
   */
  findTaskById(tasks: Task[], taskId: string): Task | undefined {
    if (!Array.isArray(tasks)) {
      throw new Error('Tasks parameter must be an array');
    }
    if (!taskId?.trim()) {
      throw new Error('Task ID is required and cannot be empty');
    }
    
    return tasks.find(t => t.id === taskId);
  }

  /**
   * Updates a task in the tasks array with comprehensive validation
   */
  updateTask(tasks: Task[], taskId: string, updates: Partial<Task>): Task {
    const task = this.findTaskById(tasks, taskId);
    if (!task) {
      throw new Error(`Task not found: ${taskId}. Available task IDs: ${tasks.slice(0, 5).map(t => t.id).join(', ')}${tasks.length > 5 ? '...' : ''}`);
    }

    // Validate updates before applying
    if (updates.progress !== undefined) {
      if (typeof updates.progress !== 'number' || updates.progress < 0 || updates.progress > 100) {
        throw new Error('Progress must be a number between 0 and 100');
      }
    }

    if (updates.priority && !['critical', 'high', 'medium', 'low'].includes(updates.priority)) {
      throw new Error(`Invalid priority: ${updates.priority}`);
    }

    if (updates.title !== undefined && !updates.title?.trim()) {
      throw new Error('Task title cannot be empty');
    }

    // Apply updates
    Object.assign(task, updates);

    // Handle completion date when completed is set to true
    if (updates.completed === true && !task.completed_date) {
      task.completed_date = new Date().toISOString();
    } else if (updates.completed === false) {
      task.completed_date = undefined;
    }

    // Handle progress-based completion (only if progress reaches 100 and completed wasn't explicitly set)
    if (updates.progress !== undefined && updates.progress >= 100 && updates.completed === undefined) {
      task.completed = true;
      task.completed_date = new Date().toISOString();
    }

    return task;
  }

  /**
   * Optimized task toggling with overloaded signatures
   */
  toggleTask(tasks: Task[], taskId: string): Task;
  toggleTask(task: Task): void;
  toggleTask(tasksOrTask: Task[] | Task, taskId?: string): Task | void {
    if (Array.isArray(tasksOrTask)) {
      // Array version
      const task = this.findTaskById(tasksOrTask, taskId!);
      if (!task) {
        throw new Error(`Task not found: ${taskId}`);
      }
      this.toggleSingleTask(task);
      return task;
    } else {
      // Single task version
      this.toggleSingleTask(tasksOrTask);
    }
  }

  /**
   * Helper method for toggling a single task
   */
  private toggleSingleTask(task: Task): void {
    task.completed = !task.completed;
    if (task.completed) {
      task.completed_date = new Date().toISOString();
      task.progress = 100;
    } else {
      task.completed_date = undefined;
      task.progress = 0;
    }
  }

  /**
   * Optimized task filtering with better performance for large datasets
   */
  filterTasks(tasks: Task[], filters: {
    status?: 'completed' | 'pending' | 'in_progress';
    project_id?: string;
    parent_id?: string;
    priority?: 'critical' | 'high' | 'medium' | 'low';
    text_search?: string;
  }): Task[] {
    const { status, project_id, parent_id, priority, text_search } = filters;
    
    let filteredTasks = tasks;

    // Apply filters in order of selectivity for better performance
    if (project_id) {
      filteredTasks = filteredTasks.filter(t => t.project_id === project_id);
    }

    if (priority) {
      filteredTasks = filteredTasks.filter(t => t.priority === priority);
    }

    if (parent_id !== undefined) {
      filteredTasks = filteredTasks.filter(t => t.parent_id === parent_id);
    }

    if (status) {
      switch (status) {
        case 'completed':
          filteredTasks = filteredTasks.filter(t => t.completed === true);
          break;
        case 'pending':
          filteredTasks = filteredTasks.filter(t => !t.completed && (!t.progress || t.progress === 0));
          break;
        case 'in_progress':
          filteredTasks = filteredTasks.filter(t => !t.completed && t.progress && t.progress > 0 && t.progress < 100);
          break;
      }
    }

    if (text_search?.trim()) {
      const searchTerm = text_search.trim().toLowerCase();
      filteredTasks = filteredTasks.filter(t => 
        t.title.toLowerCase().includes(searchTerm) ||
        (t.description && t.description.toLowerCase().includes(searchTerm)) ||
        t.tags.some(tag => tag.toLowerCase().includes(searchTerm))
      );
    }

    return filteredTasks;
  }

  /**
   * Optimized task sorting with stable sort algorithm
   */
  sortTasks(tasks: Task[], sortBy: 'priority' | 'created_date' | 'progress' | 'title' = 'priority'): Task[] {
    const priorityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
    
    return [...tasks].sort((a, b) => {
      // Always sort completed tasks after incomplete ones
      if (a.completed !== b.completed) {
        return a.completed ? 1 : -1;
      }

      switch (sortBy) {
        case 'priority':
          return priorityOrder[a.priority] - priorityOrder[b.priority];
        case 'created_date':
          return new Date(a.created_date).getTime() - new Date(b.created_date).getTime();
        case 'progress':
          return (b.progress || 0) - (a.progress || 0);
        case 'title':
          return a.title.localeCompare(b.title);
        default:
          return priorityOrder[a.priority] - priorityOrder[b.priority];
      }
    });
  }

  /**
   * Optimized task tree formatting with better performance
   */
  formatTaskTree(task: Task, allTasks: Task[], indent: number = 0): string {
    const indentStr = '  '.repeat(indent);
    const checkbox = task.completed ? '[DONE]' : '[ ]';
    const progress = task.progress ? ` (${task.progress}%)` : '';
    
    let result = `${indentStr}${checkbox} ${task.title}${progress} [${task.priority}]\n`;
    
    if (task.blockers && task.blockers.length > 0) {
      result += `${indentStr}  [BLOCKED] ${task.blockers.join(', ')}\n`;
    }

    if (task.subtasks && task.subtasks.length > 0) {
      // Use Set for O(1) lookup performance
      const taskMap = new Map(allTasks.map(t => [t.id, t]));
      const subtasks = task.subtasks.map(id => taskMap.get(id)).filter(Boolean) as Task[];
      
      subtasks.forEach(subtask => {
        result += this.formatTaskTree(subtask, allTasks, indent + 1);
      });
    }

    return result;
  }

  /**
   * Enhanced task list formatting with summary statistics
   */
  formatTaskList(tasks: Task[], includeStats: boolean = true): string {
    let result = `# Task List\n\n`;
    
    if (includeStats) {
      const completed = tasks.filter(t => t.completed).length;
      const inProgress = tasks.filter(t => !t.completed && t.progress && t.progress > 0).length;
      const blocked = tasks.filter(t => t.blockers && t.blockers.length > 0).length;
      
      result += `**Summary:** ${tasks.length} total • ${completed} completed • ${inProgress} in progress • ${blocked} blocked\n\n`;
    } else {
      result += `**Found:** ${tasks.length} tasks\n\n`;
    }

    tasks.forEach(task => {
      const status = task.completed ? '[DONE]' : '[ ]';
      result += `${status} **${task.title}** (${task.id})\n`;
      result += `   Priority: ${task.priority} | Progress: ${task.progress || 0}%`;
      
      if (task.due_date) {
        result += ` | Due: ${new Date(task.due_date).toLocaleDateString()}`;
      }
      result += '\n';
      
      if (task.description) {
        result += `   ${task.description}\n`;
      }
      
      if (task.blockers && task.blockers.length > 0) {
        result += `   [BLOCKED] ${task.blockers.join(', ')}\n`;
      }
      
      result += '\n';
    });

    return result;
  }

  /**
   * Optimized markdown export with better performance
   */
  exportTaskTree(task: Task, allTasks: Task[], indent: number = 0): string {
    const indentStr = '  '.repeat(indent);
    const checkbox = task.completed ? '- [x]' : '- [ ]';
    
    let result = `${indentStr}${checkbox} ${task.title}`;
    if (task.priority !== 'medium') result += ` (${task.priority})`;
    if (task.progress && !task.completed) result += ` - ${task.progress}%`;
    result += '\n';
    
    if (task.description) {
      result += `${indentStr}  > ${task.description}\n`;
    }
    
    if (task.blockers && task.blockers.length > 0) {
      result += `${indentStr}  > [BLOCKED] ${task.blockers.join(', ')}\n`;
    }

    if (task.subtasks && task.subtasks.length > 0) {
      // Use Map for O(1) lookup
      const taskMap = new Map(allTasks.map(t => [t.id, t]));
      const subtasks = task.subtasks.map(id => taskMap.get(id)).filter(Boolean) as Task[];
      
      subtasks.forEach(subtask => {
        result += this.exportTaskTree(subtask, allTasks, indent + 1);
      });
    }

    return result;
  }

  /**
   * Cached priority detection from task title and description text
   */
  private detectPriorityFromText(title: string, description?: string): 'critical' | 'high' | 'medium' | 'low' {
    const cacheKey = `${title}|${description || ''}`;
    
    // Check cache first
    if (TaskService.priorityCache.has(cacheKey)) {
      return TaskService.priorityCache.get(cacheKey)!;
    }

    const text = `${title} ${description || ''}`.toLowerCase();
    let detectedPriority: 'critical' | 'high' | 'medium' | 'low' = 'medium';
    
    // Critical priority keywords
    if (/\b(urgent|critical|emergency|blocking|security|asap|immediately)\b/.test(text)) {
      detectedPriority = 'critical';
    }
    // High priority keywords
    else if (/\b(important|deadline|core feature|must have|high priority)\b/.test(text)) {
      detectedPriority = 'high';
    }
    // Low priority keywords
    else if (/\b(nice to have|maybe|consider|polish|optional|low priority|when time permits)\b/.test(text)) {
      detectedPriority = 'low';
    }

    // Cache the result (with size limit)
    if (TaskService.priorityCache.size >= TaskService.PRIORITY_CACHE_SIZE) {
      // Clear oldest entries (simple FIFO)
      const keys = Array.from(TaskService.priorityCache.keys());
      for (let i = 0; i < Math.floor(TaskService.PRIORITY_CACHE_SIZE * 0.2); i++) {
        TaskService.priorityCache.delete(keys[i]);
      }
    }
    
    TaskService.priorityCache.set(cacheKey, detectedPriority);
    return detectedPriority;
  }

  /**
   * Builds optimized quick-lookup indexes for tasks with better performance
   */
  static buildIndexes(tasks: Task[]): {
    tasksById: Map<string, Task>;
    tasksByProject: Map<string, Task[]>;
    tasksByStatus: Map<string, Task[]>;
    tasksByPriority: Map<string, Task[]>;
  } {
    const tasksById = new Map<string, Task>();
    const tasksByProject = new Map<string, Task[]>();
    const tasksByStatus = new Map<string, Task[]>();
    const tasksByPriority = new Map<string, Task[]>();

    tasks.forEach(task => {
      // By ID index
      tasksById.set(task.id, task);

      // By project index
      if (!tasksByProject.has(task.project_id)) {
        tasksByProject.set(task.project_id, []);
      }
      tasksByProject.get(task.project_id)!.push(task);

      // By status index
      const status = task.completed ? 'completed' : 'active';
      if (!tasksByStatus.has(status)) {
        tasksByStatus.set(status, []);
      }
      tasksByStatus.get(status)!.push(task);

      // By priority index
      if (!tasksByPriority.has(task.priority)) {
        tasksByPriority.set(task.priority, []);
      }
      tasksByPriority.get(task.priority)!.push(task);
    });

    return { tasksById, tasksByProject, tasksByStatus, tasksByPriority };
  }

  /**
   * Clears the priority detection cache (useful for testing)
   */
  static clearPriorityCache(): void {
    TaskService.priorityCache.clear();
  }
}


================================================
FILE: src/tools/index.ts
================================================
/**
 * MCP Tools Registry - 13 secure tools for AI-powered project management
 * 
 * Security-hardened descriptions following MCP best practices:
 * - Factual, descriptive language only
 * - No imperative commands or behavioral instructions
 * - No system prompt interference patterns
 * - Clean, minimal descriptions focused on functionality
 */

const CORE_TOOLS = [
  // READ TOOLS
  {
    name: "recall_state",
    description: "Returns comprehensive project context including tasks, memories, and statistics. Provides current session state and project overview data.",
    inputSchema: {
      type: "object",
      properties: {
        limit: { type: "number", default: 20, description: "Maximum number of items to return per category" },
        project_id: { type: "string", description: "Specific project ID to focus on (optional, defaults to current project)" },
        include_completed: { type: "boolean", default: false, description: "Include completed tasks in the summary" },
        focus: { type: "string", enum: ["tasks", "projects", "memories", "all"], default: "all", description: "Focus the recall on specific data types" }
      }
    },
    annotations: {
      title: "Universal State Recall",
      readOnlyHint: true,
      openWorldHint: false,
      idempotentHint: true
    }
  },
  {
    name: "list_tasks",
    description: "Returns filtered list of tasks with pagination support. Supports filtering by status, priority, project, and completion state.",
    inputSchema: {
      type: "object",
      properties: {
        status: { type: "string", enum: ["active", "completed"], description: "Filter by completion status" },
        priority: { type: "string", enum: ["critical", "high", "medium", "low"], description: "Filter by priority level" },
        project_id: { type: "string", description: "Filter by specific project ID" },
        completed: { type: "boolean", description: "Boolean filter for completion status (alternative to status)" },
        limit: { type: "number", default: 50, minimum: 1, maximum: 200, description: "Maximum number of tasks to return" },
        offset: { type: "number", default: 0, minimum: 0, description: "Number of tasks to skip for pagination" }
      }
    },
    annotations: {
      title: "Task Listing & Filtering",
      readOnlyHint: true,
      openWorldHint: false,
      idempotentHint: true
    }
  },
  {
    name: "list_projects",
    description: "Returns list of projects with completion statistics and optional status filtering. Includes progress percentages and task counts.",
    inputSchema: {
      type: "object",
      properties: {
        status: { type: "string", enum: ["planning", "in_progress", "blocked", "completed", "archived"], description: "Filter projects by status" },
        limit: { type: "number", default: 50, minimum: 1, maximum: 200, description: "Maximum number of projects to return" },
        offset: { type: "number", default: 0, minimum: 0, description: "Number of projects to skip for pagination" }
      }
    },
    annotations: {
      title: "Project Listing & Overview",
      readOnlyHint: true,
      openWorldHint: false,
      idempotentHint: true
    }
  },
  {
    name: "get_task",
    description: "Returns detailed information for a single task including subtasks, notes, blockers, and related memories.",
    inputSchema: {
      type: "object",
      properties: {
        task_id: { type: "string", description: "Unique identifier of the task to retrieve" }
      },
      required: ["task_id"]
    },
    annotations: {
      title: "Task Detail Retrieval",
      readOnlyHint: true,
      openWorldHint: false,
      idempotentHint: true
    }
  },

  // WRITE TOOLS  
  {
    name: "create_project",
    description: "Creates a new project with specified name, description, and status. Sets the new project as the current active project.",
    inputSchema: {
      type: "object",
      properties: {
        name: { type: "string", minLength: 1, maxLength: 200, description: "Project name (required)" },
        description: { type: "string", maxLength: 20000, description: "Detailed project description" },
        status: { type: "string", enum: ["planning", "in_progress", "blocked", "completed", "archived"], default: "planning", description: "Initial project status" },
        dry_run: { type: "boolean", default: false, description: "Preview changes without creating the project" }
      },
      required: ["name"]
    },
    annotations: {
      title: "Project Creation",
      readOnlyHint: false,
      destructiveHint: false,
      openWorldHint: false,
      idempotentHint: false
    }
  },
  {
    name: "update_project",
    description: "Updates existing project properties including name, description, or status.",
    inputSchema: {
      type: "object",
      properties: {
        project_id: { type: "string", description: "Project ID to update (required)" },
        name: { type: "string", minLength: 1, maxLength: 200, description: "New project name" },
        description: { type: "string", maxLength: 20000, description: "New project description" },
        status: { type: "string", enum: ["planning", "in_progress", "blocked", "completed", "archived"], description: "New project status" },
        dry_run: { type: "boolean", default: false, description: "Preview changes without updating" }
      },
      required: ["project_id"]
    },
    annotations: {
      title: "Project Update",
      readOnlyHint: false,
      destructiveHint: false,
      openWorldHint: false,
      idempotentHint: false
    }
  },
  {
    name: "set_current_project",
    description: "Changes the active project context. Subsequent task creation operations will default to this project.",
    inputSchema: {
      type: "object",
      properties: {
        project_id: { type: "string", description: "Project ID to set as current (required)" },
        dry_run: { type: "boolean", default: false, description: "Preview the switch without changing context" }
      },
      required: ["project_id"]
    },
    annotations: {
      title: "Project Context Switch",
      readOnlyHint: false,
      destructiveHint: false,
      openWorldHint: false,
      idempotentHint: true
    }
  },
  {
    name: "create_task",
    description: "Creates a new task in the current or specified project. Supports hierarchical task organization through parent_id and code location references through line_range.",
    inputSchema: {
      type: "object",
      properties: {
        title: { type: "string", minLength: 1, maxLength: 200, description: "Task title/summary (required)" },
        description: { type: "string", maxLength: 2000, description: "Detailed task description" },
        priority: { type: "string", enum: ["critical", "high", "medium", "low"], default: "medium", description: "Task priority level" },
        project_id: { type: "string", description: "Project ID (optional, uses current project if not specified)" },
        parent_id: { type: "string", description: "Parent task ID for creating subtasks" },
        line_range: {
          type: "object",
          properties: {
            start_line: { type: "number", minimum: 1, description: "Starting line number (1-based)" },
            end_line: { type: "number", minimum: 1, description: "Ending line number (1-based)" },
            file_path: { type: "string", description: "File path for code-related tasks" }
          },
          required: ["start_line", "end_line"],
          additionalProperties: false,
          description: "Code location reference for development tasks"
        },
        dry_run: { type: "boolean", default: false, description: "Preview task creation without saving" }
      },
      required: ["title"]
    },
    annotations: {
      title: "Task Creation",
      readOnlyHint: false,
      destructiveHint: false,
      openWorldHint: false,
      idempotentHint: false
    }
  },
  {
    name: "update_task",
    description: "Updates task properties including completion status, progress percentage, notes, and blockers. Progress notes are automatically timestamped.",
    inputSchema: {
      type: "object",
      properties: {
        task_id: { type: "string", description: "Task ID to update (required)" },
        title: { type: "string", minLength: 1, maxLength: 200, description: "New task title" },
        description: { type: "string", maxLength: 2000, description: "New task description" },
        priority: { type: "string", enum: ["critical", "high", "medium", "low"], description: "New priority level" },
        completed: { type: "boolean", description: "Mark task as completed (true) or active (false)" },
        progress: { type: "number", minimum: 0, maximum: 100, description: "Progress percentage (0-100)" },
        notes: { 
          oneOf: [
            { type: "string", description: "Single progress note" },
            { type: "array", items: { type: "string" }, description: "Multiple progress notes" }
          ],
          description: "Progress notes (automatically timestamped)"
        },
        blockers: { type: "array", items: { type: "string" }, description: "List of blockers preventing task completion" },
        dry_run: { type: "boolean", default: false, description: "Preview changes without updating" }
      },
      required: ["task_id"]
    },
    annotations: {
      title: "Task Update & Progress",
      readOnlyHint: false,
      destructiveHint: false,
      openWorldHint: false,
      idempotentHint: false
    }
  },

  // MEMORY TOOLS
  {
    name: "remember_this",
    description: "Stores information, decisions, or context with importance classification and optional linking to projects, tasks, or code locations.",
    inputSchema: {
      type: "object",
      properties: {
        content: { type: "string", minLength: 1, maxLength: 50000, description: "Information to remember (required)" },
        title: { type: "string", maxLength: 500, description: "Memory title (auto-generated if not provided)" },
        importance: { type: "string", enum: ["critical", "high", "medium", "low"], default: "medium", description: "Importance level classification" },
        project_id: { type: "string", description: "Link to specific project (uses current project if not specified)" },
        task_id: { type: "string", description: "Link to specific task" },
        line_range: {
          type: "object",
          properties: {
            start_line: { type: "number", minimum: 1, description: "Starting line number for code-related memories" },
            end_line: { type: "number", minimum: 1, description: "Ending line number for code-related memories" },
            file_path: { type: "string", description: "File path for code-related memories" }
          },
          required: ["start_line", "end_line"],
          additionalProperties: false,
          description: "Code location reference for development-related memories"
        },
        dry_run: { type: "boolean", default: false, description: "Preview memory storage without saving" }
      },
      required: ["content"]
    },
    annotations: {
      title: "Information Storage",
      readOnlyHint: false,
      destructiveHint: false,
      openWorldHint: false,
      idempotentHint: false
    }
  },
  {
    name: "recall_context",
    description: "Searches stored memories by query text with filtering options for project, importance level, and result limits. Searches both title and content fields.",
    inputSchema: {
      type: "object",
      properties: {
        query: { type: "string", description: "Search query (searches title and content)" },
        project_id: { type: "string", description: "Filter memories by project" },
        importance: { type: "string", enum: ["critical", "high", "medium", "low"], description: "Filter by importance level" },
        limit: { type: "number", default: 10, minimum: 1, maximum: 100, description: "Maximum number of memories to return" }
      }
    },
    annotations: {
      title: "Memory Search & Retrieval",
      readOnlyHint: true,
      openWorldHint: false,
      idempotentHint: true
    }
  },

  // SESSION MANAGEMENT
  {
    name: "export_session",
    description: "Exports complete session data in markdown or JSON format. Includes projects, tasks, memories, and session activity summary.",
    inputSchema: {
      type: "object",
      properties: {
        format: { type: "string", enum: ["markdown", "json"], default: "markdown", description: "Export format" },
        include_handoff: { type: "boolean", default: true, description: "Include handoff summary for session continuity" },
        raw_markdown: { type: "boolean", default: false, description: "Return clean markdown without MCP response wrapper" }
      }
    },
    annotations: {
      title: "Session Data Export",
      readOnlyHint: true,
      openWorldHint: false,
      idempotentHint: true
    }
  },
  {
    name: "generate_handoff_summary",
    description: "Generates comprehensive session summary with activity overview, progress updates, and current state for session continuity.",
    inputSchema: {
      type: "object",
      properties: {
        project_id: { type: "string", description: "Focus summary on specific project (optional)" },
        format: { type: "string", enum: ["detailed", "brief"], default: "detailed", description: "Summary detail level" }
      }
    },
    annotations: {
      title: "Session Handoff Summary",
      readOnlyHint: true,
      openWorldHint: false,
      idempotentHint: true
    }
  }
];

export const ALL_TOOLS = CORE_TOOLS;


================================================
FILE: src/types/index.ts
================================================
import type { z } from 'zod';
import type { projectDatabaseSchema, Task, Project, Memory } from './schemas.js';

// --- Core Database Types (from Zod schemas) ---
export type { ProjectDatabase, Task, Project, Memory, Milestone, LineRange } from './schemas.js';


// --- View Model & Non-persistent Interfaces ---

export interface ProjectSummary {
  project: Project;
  total_tasks: number;
  completed_tasks: number;
  in_progress_tasks: number;
  blocked_tasks: number;
  recent_completions: Task[];
  upcoming_tasks: Task[];
  critical_items: Task[];
  completion_percentage: number;
}

export interface HandoffSummary {
  project_name: string;
  completion_percentage: number;
  last_session_date: string;
  completed_in_last_session: string[];
  in_progress: string[];
  blocked_items: string[];
  next_priorities: string[];
  session_notes: string;
}

export interface MemoryTemplate {
  category: string;
  structure: Array<{
    step: string;
    prompt: string;
  }>;
  auto_trigger: string[];
}




================================================
FILE: src/types/schemas.ts
================================================
import { z } from 'zod';

// Schemas for primitive/reused types
const prioritySchema = z.enum(['critical', 'high', 'medium', 'low']);

// Line range schema for code/content references
const lineRangeSchema = z.object({
  start_line: z.number().int().positive(),
  end_line: z.number().int().positive(),
  file_path: z.string().optional(),
}).refine(
  (data) => data.start_line <= data.end_line,
  {
    message: "start_line must be less than or equal to end_line",
    path: ["start_line"]
  }
).optional();

export const taskSchema = z.object({
  id: z.string(),
  project_id: z.string(),
  parent_id: z.string().optional(),
  title: z.string(),
  description: z.string().optional(),
  completed: z.boolean(),
  completed_date: z.string().optional(),
  created_date: z.string(),
  due_date: z.string().optional(),
  progress: z.number().optional(),
  priority: prioritySchema,
  tags: z.array(z.string()).default([]),
  subtasks: z.array(z.string()).optional().default([]),
  notes: z.array(z.string()).optional().default([]),
  blockers: z.array(z.string()).optional().default([]),
  line_range: lineRangeSchema,
});

export const milestoneSchema = z.object({
  id: z.string(),
  title: z.string(),
  due_date: z.string().optional(),
  completed: z.boolean(),
  tasks: z.array(z.string()).default([]),
});

// Schema for Project
const projectSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().optional(),
  created_date: z.string(),
  status: z.enum(['planning', 'in_progress', 'blocked', 'completed', 'archived']),
  completion_percentage: z.number(),
  tasks: z.array(z.string()).default([]),
  milestones: z.array(milestoneSchema).optional().default([]),
});

// Schema for Memory
const memorySchema = z.object({
  id: z.string(),
  timestamp: z.string(),
  category: z.string(),
  importance: prioritySchema,
  tags: z.array(z.string()).default([]),
  title: z.string(),
  content: z.string(),
  related_memories: z.array(z.string()).optional().default([]),
  task_id: z.string().optional(),
  project_id: z.string().optional(),
  line_range: lineRangeSchema,
});

// Main Database Schema
export const projectDatabaseSchema = z.object({
  meta: z.object({
    last_updated: z.string(),
    version: z.string(),
    current_project_id: z.string().optional(),
    session_count: z.number(),
  }),
  projects: z.array(projectSchema).default([]),
  tasks: z.array(taskSchema).default([]),
  memories: z.array(memorySchema).default([]),
  templates: z.record(z.any()).default({}),
});

// Type inference for easy use
export type ProjectDatabase = z.infer<typeof projectDatabaseSchema>;
export type Task = z.infer<typeof taskSchema>;
export type Project = z.infer<typeof projectSchema>;
export type Memory = z.infer<typeof memorySchema>;
export type Milestone = z.infer<typeof milestoneSchema>;
export type LineRange = z.infer<typeof lineRangeSchema>;


================================================
FILE: src/utils/errors.ts
================================================
/**
 * Custom error classes for Memory Pickle MCP with specific error types
 * Provides structured error handling and better agent self-correction
 */

export class MemoryPickleError extends Error {
  constructor(message: string, public code?: string) {
    super(message);
    this.name = this.constructor.name;
  }
}

export class ValidationError extends MemoryPickleError {
  constructor(field: string, value: any, requirement: string) {
    super(`Validation failed for field '${field}': ${requirement}. Received: ${value}`);
    this.code = 'VALIDATION_ERROR';
  }
}

export class ProjectNotFoundError extends MemoryPickleError {
  constructor(projectId: string, availableProjects: string[] = []) {
    const suggestion = availableProjects.length > 0 
      ? ` Available projects: ${availableProjects.join(', ')}`
      : ' No projects exist yet. Create a project first.';
    super(`Project '${projectId}' not found.${suggestion}`);
    this.code = 'PROJECT_NOT_FOUND';
  }
}

export class TaskNotFoundError extends MemoryPickleError {
  constructor(taskId: string, availableTasks: string[] = []) {
    const suggestion = availableTasks.length > 0 
      ? ` Available tasks: ${availableTasks.slice(0, 5).join(', ')}${availableTasks.length > 5 ? '...' : ''}`
      : ' No tasks exist in current project.';
    super(`Task '${taskId}' not found.${suggestion}`);
    this.code = 'TASK_NOT_FOUND';
  }
}

export class MemoryNotFoundError extends MemoryPickleError {
  constructor(query: string) {
    super(`No memories found matching query: '${query}'. Try broader search terms or check spelling.`);
    this.code = 'MEMORY_NOT_FOUND';
  }
}

export class DuplicateProjectError extends MemoryPickleError {
  constructor(projectName: string) {
    super(`Project '${projectName}' already exists. Use a different name or set it as current project.`);
    this.code = 'DUPLICATE_PROJECT';
  }
}

export class InvalidPriorityError extends MemoryPickleError {
  constructor(priority: string) {
    super(`Invalid priority '${priority}'. Must be one of: critical, high, medium, low`);
    this.code = 'INVALID_PRIORITY';
  }
}

export class InvalidProgressError extends MemoryPickleError {
  constructor(progress: number) {
    super(`Invalid progress value '${progress}'. Must be between 0 and 100.`);
    this.code = 'INVALID_PROGRESS';
  }
}

export class CircularDependencyError extends MemoryPickleError {
  constructor(taskId: string, parentId: string) {
    super(`Cannot set parent '${parentId}' for task '${taskId}': would create circular dependency.`);
    this.code = 'CIRCULAR_DEPENDENCY';
  }
}

export class DryRunResult extends MemoryPickleError {
  constructor(operation: string, wouldHave: string) {
    super(`[DRY RUN] ${operation}: Would have ${wouldHave}`);
    this.code = 'DRY_RUN';
  }
}

/**
 * Formats error for MCP response with clean text output
 */
export function formatErrorResponse(error: Error): {
  content: Array<{ type: "text"; text: string }>;
  isError: true;
} {
  const errorPrefix = error instanceof MemoryPickleError && error.code 
    ? `[${error.code}]` 
    : '[ERROR]';
  
  return {
    content: [{
      type: "text",
      text: `${errorPrefix} ${error.message}`
    }],
    isError: true
  };
}




================================================
FILE: src/utils/idGenerator.ts
================================================
/**
 * Generates a unique ID with optional prefix
 */
export function generateId(prefix: string = 'id'): string {
  return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}


================================================
FILE: src/utils/ValidationUtils.ts
================================================
import type { Project, Task, Memory, ProjectDatabase, LineRange } from '../types/index.js';
import { ValidationError, InvalidPriorityError, InvalidProgressError } from './errors.js';

/**
 * Comprehensive validation utilities for data integrity and schema enforcement
 */
export class ValidationUtils {
  // Project validation
  static validateProject(project: Partial<Project>): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (!project.name || typeof project.name !== 'string') {
      errors.push('Project name is required and must be a string');
    } else if (project.name.length === 0 || project.name.length > 200) {
      errors.push('Project name must be between 1 and 200 characters');
    }

    if (project.description && typeof project.description !== 'string') {
      errors.push('Project description must be a string');
    } else if (project.description && project.description.length > 20000) {
      errors.push('Project description cannot exceed 20000 characters');
    }

    if (project.status && !['planning', 'in_progress', 'blocked', 'completed', 'archived'].includes(project.status)) {
      errors.push('Project status must be one of: planning, in_progress, blocked, completed, archived');
    }

    if (project.completion_percentage !== undefined) {
      if (typeof project.completion_percentage !== 'number' || 
          project.completion_percentage < 0 || 
          project.completion_percentage > 100) {
        errors.push('Project completion percentage must be a number between 0 and 100');
      }
    }

    if (project.id && (typeof project.id !== 'string' || project.id.length === 0)) {
      errors.push('Project ID must be a non-empty string');
    }

    return { isValid: errors.length === 0, errors };
  }

  // Task validation
  static validateTask(task: Partial<Task>): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (!task.title || typeof task.title !== 'string') {
      errors.push('Task title is required and must be a string');
    } else if (task.title.length === 0 || task.title.length > 200) {
      errors.push('Task title must be between 1 and 200 characters');
    }

    if (task.description && typeof task.description !== 'string') {
      errors.push('Task description must be a string');
    } else if (task.description && task.description.length > 2000) {
      errors.push('Task description cannot exceed 2000 characters');
    }

    if (task.priority && !['low', 'medium', 'high', 'critical'].includes(task.priority)) {
      errors.push('Task priority must be one of: low, medium, high, critical');
    }

    if (!task.project_id || typeof task.project_id !== 'string') {
      errors.push('Task project_id is required and must be a string');
    }

    if (task.parent_id && typeof task.parent_id !== 'string') {
      errors.push('Task parent_id must be a string');
    }

    if (task.progress !== undefined) {
      if (typeof task.progress !== 'number' || task.progress < 0 || task.progress > 100) {
        errors.push('Task progress must be a number between 0 and 100');
      }
    }

    if (task.completed !== undefined && typeof task.completed !== 'boolean') {
      errors.push('Task completed must be a boolean');
    }

    if (task.notes && !Array.isArray(task.notes)) {
      errors.push('Task notes must be an array');
    } else if (task.notes) {
      task.notes.forEach((note, index) => {
        if (typeof note !== 'string') {
          errors.push(`Task note at index ${index} must be a string`);
        }
      });
    }

    if (task.blockers && !Array.isArray(task.blockers)) {
      errors.push('Task blockers must be an array');
    } else if (task.blockers) {
      task.blockers.forEach((blocker, index) => {
        if (typeof blocker !== 'string') {
          errors.push(`Task blocker at index ${index} must be a string`);
        }
      });
    }

    return { isValid: errors.length === 0, errors };
  }

  // Memory validation
  static validateMemory(memory: Partial<Memory>): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (!memory.content || typeof memory.content !== 'string') {
      errors.push('Memory content is required and must be a string');
    } else if (memory.content.length === 0 || memory.content.length > 50000) {
      errors.push('Memory content must be between 1 and 50000 characters');
    }

    if (memory.title && typeof memory.title !== 'string') {
      errors.push('Memory title must be a string');
    } else if (memory.title && memory.title.length > 500) {
      errors.push('Memory title cannot exceed 500 characters');
    }

    if (memory.importance && !['low', 'medium', 'high', 'critical'].includes(memory.importance)) {
      errors.push('Memory importance must be one of: low, medium, high, critical');
    }

    if (memory.project_id && typeof memory.project_id !== 'string') {
      errors.push('Memory project_id must be a string');
    }

    if (memory.task_id && typeof memory.task_id !== 'string') {
      errors.push('Memory task_id must be a string');
    }

    return { isValid: errors.length === 0, errors };
  }

  // Database schema validation
  static validateDatabaseSchema(database: Partial<ProjectDatabase>): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Check required top-level properties
    if (!database.meta) {
      errors.push('Database meta is required');
    } else {
      if (!database.meta.version || typeof database.meta.version !== 'string') {
        errors.push('Database meta.version is required and must be a string');
      }
      if (!database.meta.last_updated || typeof database.meta.last_updated !== 'string') {
        errors.push('Database meta.last_updated is required and must be a string');
      }
      if (database.meta.session_count !== undefined && typeof database.meta.session_count !== 'number') {
        errors.push('Database meta.session_count must be a number');
      }
    }

    if (!Array.isArray(database.projects)) {
      errors.push('Database projects must be an array');
    } else {
      database.projects.forEach((project, index) => {
        const validation = this.validateProject(project);
        if (!validation.isValid) {
          errors.push(`Project at index ${index}: ${validation.errors.join(', ')}`);
        }
      });
    }

    if (!Array.isArray(database.tasks)) {
      errors.push('Database tasks must be an array');
    } else {
      database.tasks.forEach((task, index) => {
        const validation = this.validateTask(task);
        if (!validation.isValid) {
          errors.push(`Task at index ${index}: ${validation.errors.join(', ')}`);
        }
      });
    }

    if (!Array.isArray(database.memories)) {
      errors.push('Database memories must be an array');
    } else {
      database.memories.forEach((memory, index) => {
        const validation = this.validateMemory(memory);
        if (!validation.isValid) {
          errors.push(`Memory at index ${index}: ${validation.errors.join(', ')}`);
        }
      });
    }

    if (database.templates && typeof database.templates !== 'object') {
      errors.push('Database templates must be an object');
    }

    return { isValid: errors.length === 0, errors };
  }

  // Input sanitization
  /**
   * Sanitizes a string by trimming whitespace but preserving special characters
   */
  static sanitizeString(input: any): string {
    if (typeof input !== 'string') {
      return '';
    }
    // Only trim whitespace, preserve all other characters including newlines, tabs, emojis
    return input.trim();
  }

  static sanitizeId(input: any): string {
    if (input === null || input === undefined) return '';
    return String(input).trim();
  }

  static sanitizeProject(project: Partial<Project>): Partial<Project> {
    const sanitized = { ...project };
    if (sanitized.name) sanitized.name = this.sanitizeString(sanitized.name);
    if (sanitized.description) sanitized.description = this.sanitizeString(sanitized.description);
    return sanitized;
  }

  static sanitizeTask(task: Partial<Task>): Partial<Task> {
    const sanitized = { ...task };
    if (sanitized.title) sanitized.title = this.sanitizeString(sanitized.title);
    if (sanitized.description) sanitized.description = this.sanitizeString(sanitized.description);
    if (sanitized.notes) {
      sanitized.notes = sanitized.notes.map(note => this.sanitizeString(note));
    }
    if (sanitized.blockers) {
      sanitized.blockers = sanitized.blockers.map(blocker => this.sanitizeString(blocker));
    }
    return sanitized;
  }

  static sanitizeMemory(memory: Partial<Memory>): Partial<Memory> {
    const sanitized = { ...memory };
    if (sanitized.title) sanitized.title = this.sanitizeString(sanitized.title);
    if (sanitized.content) sanitized.content = this.sanitizeString(sanitized.content);
    return sanitized;
  }

  // Data limits validation
  static validateDataLimits(database: ProjectDatabase): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];
    
    if (database.projects.length > 5000) {
      errors.push('Too many projects - maximum 5000 allowed');
    }
    
    if (database.tasks.length > 50000) {
      errors.push('Too many tasks - maximum 50000 allowed');
    }
    
    if (database.memories.length > 25000) {
      errors.push('Too many memories - maximum 25000 allowed');
    }

    return { isValid: errors.length === 0, errors };
  }

  // Referential integrity validation
  static validateReferentialIntegrity(database: ProjectDatabase): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];
    const projectIds = new Set(database.projects.map(p => p.id));
    const taskIds = new Set(database.tasks.map(t => t.id));

    // Check tasks reference valid projects
    database.tasks.forEach(task => {
      if (!projectIds.has(task.project_id)) {
        errors.push(`Task ${task.id} references non-existent project ${task.project_id}`);
      }
      if (task.parent_id && !taskIds.has(task.parent_id)) {
        errors.push(`Task ${task.id} references non-existent parent task ${task.parent_id}`);
      }
    });

    // Check memories reference valid projects/tasks
    database.memories.forEach(memory => {
      if (memory.project_id && !projectIds.has(memory.project_id)) {
        errors.push(`Memory ${memory.id} references non-existent project ${memory.project_id}`);
      }
      if (memory.task_id && !taskIds.has(memory.task_id)) {
        errors.push(`Memory ${memory.id} references non-existent task ${memory.task_id}`);
      }
    });

    // Check current project reference
    if (database.meta.current_project_id && !projectIds.has(database.meta.current_project_id)) {
      errors.push(`Current project ${database.meta.current_project_id} does not exist`);
    }

    return { isValid: errors.length === 0, errors };
  }

  // Comprehensive database validation
  static validateDatabase(database: ProjectDatabase): { isValid: boolean; errors: string[] } {
    const schemaValidation = this.validateDatabaseSchema(database);
    if (!schemaValidation.isValid) {
      return schemaValidation;
    }

    const limitsValidation = this.validateDataLimits(database);
    if (!limitsValidation.isValid) {
      return limitsValidation;
    }

    const integrityValidation = this.validateReferentialIntegrity(database);
    if (!integrityValidation.isValid) {
      return integrityValidation;
    }

    return { isValid: true, errors: [] };
  }


  static isValidPriority(priority: any): boolean {
    if (!priority || typeof priority !== 'string') return false;
    return ['critical', 'high', 'medium', 'low'].includes(priority);
  }

  static isValidStatus(status: any): boolean {
    if (!status || typeof status !== 'string') return false;
    return ['planning', 'in_progress', 'blocked', 'completed', 'archived'].includes(status);
  }

  static isValidImportance(importance: any): boolean {
    if (!importance || typeof importance !== 'string') return false;
    return ['critical', 'high', 'medium', 'low'].includes(importance);
  }

  static validateStringLength(value: any, fieldName: string, min: number, max: number): void {
    const str = value ? String(value) : '';
    if (str.length < min || str.length > max) {
      throw new Error(`Field '${fieldName}' must be between ${min} and ${max} characters`);
    }
  }

  static validateProgress(progress: any): void {
    if (progress !== undefined && progress !== null) {
      if (typeof progress !== 'number' || progress < 0 || progress > 100) {
        throw new InvalidProgressError(progress);
      }
    }
  }

  static validateArray(value: any, fieldName: string, min: number, max: number): void {
    if (!Array.isArray(value)) {
      throw new Error(`Field '${fieldName}' must be an array`);
    }
    if (value.length < min || value.length > max) {
      throw new Error(`Field '${fieldName}' must have between ${min} and ${max} items`);
    }
  }

  static validateEnum(value: any, fieldName: string, validValues: string[]): void {
    if (!validValues.includes(value)) {
      throw new Error(`Field '${fieldName}' must be one of: ${validValues.join(', ')}`);
    }
  }

  static validateOptionalEnum(value: any, fieldName: string, validValues: string[]): void {
    if (value !== undefined && value !== null && !validValues.includes(value)) {
      throw new Error(`Field '${fieldName}' must be one of: ${validValues.join(', ')}, or undefined`);
    }
  }

  // Missing methods that tests expect
  static validatePriority(priority: any): void {
    if (priority === undefined || priority === null) {
      return; // Allow undefined/null priorities
    }
    
    if (typeof priority !== 'string' || !['critical', 'high', 'medium', 'low'].includes(priority)) {
      throw new InvalidPriorityError(priority);
    }
  }

  static validateRequiredField(value: any, fieldName: string): void {
    if (value === null || value === undefined) {
      throw new ValidationError(fieldName, value, 'cannot be null or undefined');
    }
    
    if (typeof value === 'string' && value.trim() === '') {
      throw new ValidationError(fieldName, value, 'cannot be empty string');
    }
  }

  static validateLineRange(lineRange: LineRange | undefined): void {
    if (lineRange === undefined || lineRange === null) {
      return; // Allow undefined line ranges
    }
    
    if (typeof lineRange !== 'object') {
      throw new ValidationError('line_range', lineRange, 'must be an object');
    }
    
    if (typeof lineRange.start_line !== 'number' || typeof lineRange.end_line !== 'number') {
      throw new ValidationError('line_range', lineRange, 'start_line and end_line must be numbers');
    }
    
    if (lineRange.start_line < 1 || lineRange.end_line < 1) {
      throw new ValidationError('line_range', lineRange, 'line numbers must be positive (1-based)');
    }
    
    if (lineRange.start_line > lineRange.end_line) {
      throw new ValidationError('line_range', lineRange, 'start_line must be less than or equal to end_line');
    }
  }

  /**
   * Validates email format using a simple regex pattern
   */
  static isValidEmail(email: any): boolean {
    if (!email || typeof email !== 'string') {
      return false;
    }
    
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  /**
   * Validates URL format, allowing only http and https protocols
   */
  static isValidUrl(url: any): boolean {
    if (!url || typeof url !== 'string') {
      return false;
    }
    
    try {
      const urlObj = new URL(url);
      return urlObj.protocol === 'http:' || urlObj.protocol === 'https:';
    } catch {
      return false;
    }
  }
}


================================================
FILE: src/utils/version.ts
================================================
/**
 * Centralized version management utility
 * Single source of truth for version information
 */

import { readFileSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

// Cache the version to avoid repeated file reads
let cachedVersion: string | null = null;
let cachedPackageJson: any = null;

/**
 * Returns the current version string from the project's package.json.
 *
 * The version is cached after the first read to optimize repeated access.
 * @returns The version string from package.json.
 */
export function getVersion(): string {
  if (cachedVersion === null) {
    const packageJson = getPackageJson();
    cachedVersion = packageJson.version;
  }
  return cachedVersion!;
}

/**
 * Returns the parsed contents of the project's `package.json` file.
 *
 * The result is cached after the first read to improve performance on subsequent calls.
 *
 * @returns The parsed `package.json` object.
 */
export function getPackageJson(): any {
  if (cachedPackageJson === null) {
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = dirname(__filename);
    const packageJsonPath = join(__dirname, '../../package.json');
    cachedPackageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8'));
  }
  return cachedPackageJson;
}

/**
 * Returns the package name from the project's package.json file.
 *
 * @returns The value of the "name" field from package.json.
 */
export function getPackageName(): string {
  const packageJson = getPackageJson();
  return packageJson.name;
}

/**
 * Clears the cached version and package information.
 *
 * Use this to force a fresh read of `package.json` data, such as in testing scenarios.
 */
export function clearVersionCache(): void {
  cachedVersion = null;
  cachedPackageJson = null;
}



================================================
FILE: test/jest.config.js
================================================
export default {
  // Multi-project configuration for organized test structure
  projects: [
    {
      displayName: {
        name: 'unit',
        color: 'cyan'
      },
      testMatch: ['<rootDir>/unit/**/*.test.ts'],
      setupFilesAfterEnv: ['<rootDir>/setup/unit.ts'],
      testEnvironment: 'node',
      preset: 'ts-jest/presets/default-esm',
      transform: {
        '^.+\\.ts$': ['ts-jest', {
          useESM: true,
          isolatedModules: true
        }]
      },
      extensionsToTreatAsEsm: ['.ts'],
      moduleNameMapper: {
        '^(\\.{1,2}/.*)\\.js$': '$1'
      },
      testTimeout: 10000,
      forceExit: true,
      detectOpenHandles: true
    },
    {
      displayName: {
        name: 'integration', 
        color: 'yellow'
      },
      testMatch: ['<rootDir>/integration/**/*.test.ts'],
      setupFilesAfterEnv: ['<rootDir>/setup/integration.ts'],
      testEnvironment: 'node',
      preset: 'ts-jest/presets/default-esm',
      transform: {
        '^.+\\.ts$': ['ts-jest', {
          useESM: true,
          isolatedModules: true
        }]
      },
      extensionsToTreatAsEsm: ['.ts'],
      moduleNameMapper: {
        '^(\\.{1,2}/.*)\\.js$': '$1'
      },
      testTimeout: 30000,
      forceExit: true,
      detectOpenHandles: true
    },
    {
      displayName: {
        name: 'e2e',
        color: 'green'
      },
      testMatch: ['<rootDir>/e2e/**/*.test.ts'],
      setupFilesAfterEnv: ['<rootDir>/setup/e2e.ts'],
      testEnvironment: 'node',
      preset: 'ts-jest/presets/default-esm',
      transform: {
        '^.+\\.ts$': ['ts-jest', {
          useESM: true,
          isolatedModules: true
        }]
      },
      extensionsToTreatAsEsm: ['.ts'],
      moduleNameMapper: {
        '^(\\.{1,2}/.*)\\.js$': '$1'
      },
      testTimeout: 60000,
      forceExit: true,
      detectOpenHandles: true
    },
    {
      displayName: {
        name: 'performance',
        color: 'magenta'
      },
      testMatch: ['<rootDir>/performance/**/*.test.ts'],
      setupFilesAfterEnv: ['<rootDir>/setup/performance.ts'],
      testEnvironment: 'node',
      preset: 'ts-jest/presets/default-esm',
      transform: {
        '^.+\\.ts$': ['ts-jest', {
          useESM: true,
          isolatedModules: true
        }]
      },
      extensionsToTreatAsEsm: ['.ts'],
      moduleNameMapper: {
        '^(\\.{1,2}/.*)\\.js$': '$1'
      },
      testTimeout: 120000,
      forceExit: true,
      detectOpenHandles: true
    }
  ],

  // Coverage configuration (global level)
  collectCoverage: true,
  coverageDirectory: '../coverage',
  coverageReporters: ['text', 'lcov', 'html'],
  collectCoverageFrom: [
    '../src/**/*.ts',
    '!../src/**/*.d.ts',
    '!../src/index.ts',
  ],
  
  // Global settings
  maxWorkers: '50%',
  verbose: true,
  clearMocks: true,
  restoreMocks: true
}; 


================================================
FILE: test/fixtures/sample-projects.json
================================================
[
  {
    "name": "E-commerce Platform",
    "description": "Building a modern e-commerce platform with React and Node.js",
    "status": "in_progress",
    "tasks": [
      {
        "title": "Build React Frontend",
        "description": "Create responsive UI components and pages",
        "priority": "high"
      },
      {
        "title": "Develop Node.js API",
        "description": "Build RESTful API with authentication",
        "priority": "critical"
      },
      {
        "title": "Write Integration Tests",
        "description": "Comprehensive testing suite",
        "priority": "medium"
      }
    ]
  },
  {
    "name": "Mobile App",
    "description": "iOS and Android mobile application",
    "status": "planning",
    "tasks": [
      {
        "title": "Design UI Mockups",
        "description": "Create user interface designs",
        "priority": "high"
      },
      {
        "title": "Implement Authentication",
        "description": "Add login and security features",
        "priority": "critical"
      }
    ]
  },
  {
    "name": "Data Analytics Dashboard",
    "description": "Business intelligence and reporting dashboard",
    "status": "planning",
    "tasks": [
      {
        "title": "Setup Analytics Dashboard",
        "description": "Configure data visualization components",
        "priority": "medium"
      },
      {
        "title": "Implement Real-time Updates",
        "description": "Add live data streaming",
        "priority": "high"
      }
    ]
  }
] 


================================================
FILE: test/helpers/TestCoreUtils.ts
================================================
/**
 * Test Utilities for MemoryPickleCore
 * 
 * Helper functions for creating and managing MemoryPickleCore instances in tests
 */

import { MemoryPickleCore } from '../../src/core/MemoryPickleCore.js';

export class TestCoreUtils {
  /**
   * Create a MemoryPickleCore instance with automatic cleanup tracking
   */
  static async createCore(): Promise<MemoryPickleCore> {
    const core = await MemoryPickleCore.create();
    
    // Register for automatic cleanup
    if ((global as any).trackCoreInstance) {
      (global as any).trackCoreInstance(core);
    }
    
    return core;
  }

  /**
   * Create a project and return both the response and extracted ID
   */
  static async createProjectWithId(
    core: MemoryPickleCore, 
    name: string, 
    description?: string
  ): Promise<{ response: any; projectId: string }> {
    const response = await core.create_project({
      name,
      description: description || `Project: ${name}`
    });

    const projectId = response.content[0].text.match(/\*\*ID:\*\* ([^\n]+)/)?.[1];
    if (!projectId) {
      throw new Error('Failed to extract project ID from response');
    }

    return { response, projectId };
  }

  /**
   * Create a task and return both the response and extracted ID
   */
  static async createTaskWithId(
    core: MemoryPickleCore,
    title: string,
    options: { description?: string; priority?: string; projectId?: string } = {}
  ): Promise<{ response: any; taskId: string }> {
    const response = await core.create_task({
      title,
      description: options.description || `Task: ${title}`,
      priority: options.priority || 'medium',
      project_id: options.projectId
    });

    const taskId = response.content[0].text.match(/\*\*ID:\*\* ([^\n]+)/)?.[1];
    if (!taskId) {
      throw new Error('Failed to extract task ID from response');
    }

    return { response, taskId };
  }

  /**
   * Create a memory and return the response
   */
  static async createMemory(
    core: MemoryPickleCore,
    title: string,
    content: string,
    options: { importance?: string; projectId?: string; taskId?: string } = {}
  ): Promise<any> {
    return await core.remember_this({
      title,
      content,
      importance: options.importance || 'medium',
      project_id: options.projectId,
      task_id: options.taskId
    });
  }

  /**
   * Setup a complete test scenario with project, tasks, and memories
   */
  static async setupTestScenario(core: MemoryPickleCore): Promise<{
    projectId: string;
    taskIds: string[];
    memoryResponses: any[];
  }> {
    // Create project
    const { projectId } = await this.createProjectWithId(
      core,
      'Test Scenario Project',
      'A comprehensive test scenario'
    );

    // Create tasks
    const task1 = await this.createTaskWithId(core, 'Implementation Task', {
      priority: 'high'
    });
    const task2 = await this.createTaskWithId(core, 'Testing Task', {
      priority: 'medium'
    });
    const task3 = await this.createTaskWithId(core, 'Documentation Task', {
      priority: 'low'
    });

    const taskIds = [task1.taskId, task2.taskId, task3.taskId];

    // Create memories
    const memory1 = await this.createMemory(
      core,
      'Technical Decision',
      'Decided to use TypeScript for better type safety',
      { importance: 'high' }
    );

    const memory2 = await this.createMemory(
      core,
      'Implementation Note',
      'Remember to handle edge cases in the validation logic',
      { importance: 'medium' }
    );

    const memoryResponses = [memory1, memory2];

    return { projectId, taskIds, memoryResponses };
  }

  /**
   * Extract ID from MCP response text
   */
  static extractId(responseText: string, type: 'task' | 'project' | 'memory' = 'task'): string {
    const match = responseText.match(/\*\*ID:\*\* ([^\n]+)/);
    if (!match) {
      throw new Error(`Failed to extract ${type} ID from response`);
    }
    return match[1];
  }

  /**
   * Wait for a specific amount of time (useful for timing tests)
   */
  static async wait(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Measure execution time of an operation
   */
  static async measureTime<T>(operation: () => Promise<T>): Promise<{ result: T; duration: number }> {
    const start = Date.now();
    const result = await operation();
    const duration = Date.now() - start;
    return { result, duration };
  }
} 


================================================
FILE: test/integration/workflows/ProjectWorkflows.test.ts
================================================
/**
 * Integration Tests for Project Workflows
 * 
 * Tests complete project management workflows
 */

import { MemoryPickleCore } from '../../../src/core/MemoryPickleCore.js';

describe('Project Workflows Integration', () => {
  let core: MemoryPickleCore;

  beforeEach(async () => {
    core = await MemoryPickleCore.create();
    // Track instance for cleanup
    (global as any).trackCoreInstance(core);
  });

  describe('Complete Project Lifecycle', () => {
    it('should handle project creation to completion workflow', async () => {
      // Create project
      const projectResponse = await core.create_project({
        name: 'E-commerce Platform',
        description: 'Building a modern e-commerce platform with React and Node.js'
      });

      expect(projectResponse.content[0].text).toContain('Project Created Successfully');
      expect(projectResponse.content[0].text).toContain('E-commerce Platform');

      // Create tasks
      await core.create_task({
        title: 'Build React Frontend',
        description: 'Create responsive UI components',
        priority: 'high'
      });

      await core.create_task({
        title: 'Develop Node.js API',
        description: 'Build RESTful API',
        priority: 'critical'
      });

      await core.create_task({
        title: 'Write Integration Tests',
        description: 'Comprehensive testing suite',
        priority: 'medium'
      });

      // Check project status
      const finalStatus = await core.recall_state({});
      expect(finalStatus.content[0].text).toContain('E-commerce Platform');
      expect(finalStatus.content[0].text).toContain('3/3 active');
    });

    it('should track project completion percentage correctly', async () => {
      // Create project with tasks
      await core.create_project({
        name: 'Completion Tracking Project',
        description: 'Testing completion percentage calculations'
      });

      const task1 = await core.create_task({ title: 'Task 1' });
      const task2 = await core.create_task({ title: 'Task 2' });
      const task3 = await core.create_task({ title: 'Task 3' });

      // Complete first task
      const task1Id = task1.content[0].text.match(/\*\*ID:\*\* ([^\n]+)/)?.[1];
      await core.update_task({
        task_id: task1Id!,
        completed: true
      });

      let status = await core.recall_state({});
      expect(status.content[0].text).toContain('2/3 active'); // 2 active, 1 completed

      // Complete second task
      const task2Id = task2.content[0].text.match(/\*\*ID:\*\* ([^\n]+)/)?.[1];
      await core.update_task({
        task_id: task2Id!,
        completed: true
      });

      status = await core.recall_state({});
      expect(status.content[0].text).toContain('1/3 active'); // 1 active, 2 completed
    });
  });

  describe('Multi-Project Session Management', () => {
    it('should handle multiple projects with context switching', async () => {
      // Create first project
      const project1 = await core.create_project({
        name: 'Mobile App',
        description: 'iOS and Android mobile application'
      });

      const project1Id = project1.content[0].text.match(/\*\*ID:\*\* ([^\n]+)/)?.[1];

      // Create tasks for first project
      await core.create_task({
        title: 'Design UI Mockups',
        priority: 'high'
      });

      await core.create_task({
        title: 'Implement Authentication',
        priority: 'critical'
      });

      // Create second project
      const project2 = await core.create_project({
        name: 'Web Dashboard',
        description: 'Admin dashboard for data visualization'
      });

      const project2Id = project2.content[0].text.match(/\*\*ID:\*\* ([^\n]+)/)?.[1];

      // Create task for second project
      await core.create_task({
        title: 'Setup Analytics Dashboard',
        priority: 'medium'
      });

      // Switch back to first project
      await core.set_current_project({ project_id: project1Id! });

      // Verify context switch worked
      const switchedStatus = await core.recall_state({});
      expect(switchedStatus.content[0].text).toContain('Mobile App');
      expect(switchedStatus.content[0].text).toContain('3/3 active'); // All 3 tasks are active across both projects

      // Verify specific project status queries work
      const project2Status = await core.recall_state({ project_id: project2Id! });
      expect(project2Status.content[0].text).toContain('Web Dashboard');
      expect(project2Status.content[0].text).toContain('Tasks'); // Just check it contains task information
    });
  });
}); 


================================================
FILE: test/setup/e2e.ts
================================================
/**
 * E2E Test Setup
 * 
 * Setup and teardown for end-to-end tests covering complete workflows
 */

// Extended timeout for e2e tests
jest.setTimeout(60000);

// Global test cleanup to prevent Jest hanging
let e2eCoreInstances: any[] = [];

// Track MemoryPickleCore instances for cleanup
(global as any).trackCoreInstance = (core: any) => {
  e2eCoreInstances.push(core);
};

// Cleanup all core instances after each test
afterEach(async () => {
  await Promise.all(
    e2eCoreInstances.map(async (core) => {
      try {
        if (core && typeof core.shutdown === 'function') {
          await core.shutdown();
        }
      } catch (error) {
        // Ignore cleanup errors
      }
    })
  );
  e2eCoreInstances = [];
});

// Keep console output for e2e test debugging
beforeEach(() => {
  // Don't mock console for e2e tests - we want to see the full output
}); 


================================================
FILE: test/setup/global.ts
================================================
/**
 * Global Test Setup
 * 
 * Universal setup and teardown for all test types in the organized structure
 */

// Global test cleanup to prevent Jest hanging
let globalCoreInstances: any[] = [];

// Track MemoryPickleCore instances for cleanup
(global as any).trackCoreInstance = (core: any) => {
  globalCoreInstances.push(core);
};

// Cleanup all core instances after each test
afterEach(async () => {
  await Promise.all(
    globalCoreInstances.map(async (core) => {
      try {
        if (core && typeof core.shutdown === 'function') {
          await core.shutdown();
        }
      } catch (error) {
        // Ignore cleanup errors
      }
    })
  );
  globalCoreInstances = [];
}); 


================================================
FILE: test/setup/integration.ts
================================================
/**
 * Integration Test Setup
 * 
 * Setup and teardown for integration tests covering component interactions
 */

// Extended timeout for integration tests
jest.setTimeout(30000);

// Global test cleanup to prevent Jest hanging
let integrationCoreInstances: any[] = [];

// Track MemoryPickleCore instances for cleanup
(global as any).trackCoreInstance = (core: any) => {
  integrationCoreInstances.push(core);
};

// Cleanup all core instances after each test
afterEach(async () => {
  await Promise.all(
    integrationCoreInstances.map(async (core) => {
      try {
        if (core && typeof core.shutdown === 'function') {
          await core.shutdown();
        }
      } catch (error) {
        // Ignore cleanup errors
      }
    })
  );
  integrationCoreInstances = [];
});

// Reset console output for clean test runs
beforeEach(() => {
  jest.spyOn(console, 'log').mockImplementation(() => {});
  jest.spyOn(console, 'warn').mockImplementation(() => {});
});

afterEach(() => {
  jest.restoreAllMocks();
}); 


================================================
FILE: test/setup/performance.ts
================================================
/**
 * Performance Test Setup
 * 
 * Setup and teardown for performance tests with extended timeouts
 */

// Very extended timeout for performance tests
jest.setTimeout(120000);

// Global test cleanup to prevent Jest hanging
let perfCoreInstances: any[] = [];

// Track MemoryPickleCore instances for cleanup
(global as any).trackCoreInstance = (core: any) => {
  perfCoreInstances.push(core);
};

// Cleanup all core instances after each test
afterEach(async () => {
  await Promise.all(
    perfCoreInstances.map(async (core) => {
      try {
        if (core && typeof core.shutdown === 'function') {
          await core.shutdown();
        }
      } catch (error) {
        // Ignore cleanup errors
      }
    })
  );
  perfCoreInstances = [];
});

// Enable performance monitoring
beforeEach(() => {
  // Mock console.warn but keep console.log for performance metrics
  jest.spyOn(console, 'warn').mockImplementation(() => {});
});

afterEach(() => {
  jest.restoreAllMocks();
}); 


================================================
FILE: test/setup/unit.ts
================================================
/**
 * Unit Test Setup
 * 
 * Setup and teardown for unit tests focusing on individual components
 */

// Global test timeout for unit tests
jest.setTimeout(10000);

// Global test cleanup to prevent Jest hanging
let coreInstances: any[] = [];

// Track MemoryPickleCore instances for cleanup
(global as any).trackCoreInstance = (core: any) => {
  coreInstances.push(core);
};

// Cleanup all core instances after each test
afterEach(async () => {
  await Promise.all(
    coreInstances.map(async (core) => {
      try {
        if (core && typeof core.shutdown === 'function') {
          await core.shutdown();
        }
      } catch (error) {
        // Ignore cleanup errors
      }
    })
  );
  coreInstances = [];
});

// Reset console.warn for clean test output
beforeEach(() => {
  jest.spyOn(console, 'warn').mockImplementation(() => {});
});

afterEach(() => {
  jest.restoreAllMocks();
}); 


================================================
FILE: test/unit/services/ProjectService.test.ts
================================================
/**
 * Unit Tests for ProjectService
 * 
 * Tests individual ProjectService methods in isolation
 */

import { ProjectService } from '../../../src/services/ProjectService.js';

describe('ProjectService Unit Tests', () => {
  let projectService: ProjectService;

  beforeEach(() => {
    projectService = new ProjectService();
  });

  describe('createProject', () => {
    it('should create a project with default values', () => {
      const project = projectService.createProject({
        name: 'Test Project',
        description: 'A test project'
      });

      expect(project.name).toBe('Test Project');
      expect(project.description).toBe('A test project');
      expect(project.status).toBe('planning');
      expect(project.completion_percentage).toBe(0);
      expect(project.id).toMatch(/^proj_/);
      expect(Array.isArray(project.tasks)).toBe(true);
      expect(project.tasks).toHaveLength(0);
    });

    it('should create a project with custom status', () => {
      const project = projectService.createProject({
        name: 'Custom Project',
        description: 'Custom description',
        status: 'in_progress'
      });

      expect(project.status).toBe('in_progress');
    });

    it('should throw error for empty name', () => {
      expect(() => {
        projectService.createProject({
          name: '',
          description: 'Test'
        });
      }).toThrow();
    });
  });

  describe('findProjectById', () => {
    it('should find existing project', () => {
      const projects = [
        projectService.createProject({ name: 'Project 1' }),
        projectService.createProject({ name: 'Project 2' })
      ];

      const found = projectService.findProjectById(projects, projects[0].id);
      expect(found).toBeDefined();
      expect(found?.name).toBe('Project 1');
    });

    it('should return undefined for non-existent project', () => {
      const projects = [
        projectService.createProject({ name: 'Project 1' })
      ];

      const found = projectService.findProjectById(projects, 'nonexistent');
      expect(found).toBeUndefined();
    });

    it('should handle empty projects array', () => {
      const found = projectService.findProjectById([], 'any-id');
      expect(found).toBeUndefined();
    });
  });

  describe('updateProject', () => {
    it('should update project fields', () => {
      const projects = [
        projectService.createProject({ name: 'Original Name' })
      ];

      const updated = projectService.updateProject(projects, projects[0].id, {
        name: 'Updated Name',
        description: 'Updated Description',
        status: 'in_progress'
      });

      expect(updated.name).toBe('Updated Name');
      expect(updated.description).toBe('Updated Description');
      expect(updated.status).toBe('in_progress');
    });

    it('should throw error for non-existent project', () => {
      const projects = [
        projectService.createProject({ name: 'Test' })
      ];

      expect(() => {
        projectService.updateProject(projects, 'nonexistent', {
          name: 'New Name'
        });
      }).toThrow('Project not found: nonexistent');
    });
  });
}); 

