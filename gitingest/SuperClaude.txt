Directory structure:
â””â”€â”€ superclaude-org-superclaude_framework/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ CHANGELOG.md
    â”œâ”€â”€ CODE_OF_CONDUCT.md
    â”œâ”€â”€ CONTRIBUTING.md
    â”œâ”€â”€ LICENSE
    â”œâ”€â”€ MANIFEST.in
    â”œâ”€â”€ pyproject.toml
    â”œâ”€â”€ ROADMAP.md
    â”œâ”€â”€ SECURITY.md
    â”œâ”€â”€ setup.py
    â”œâ”€â”€ uv.lock
    â”œâ”€â”€ VERSION
    â”œâ”€â”€ config/
    â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”œâ”€â”€ features.json
    â”‚   â””â”€â”€ requirements.json
    â”œâ”€â”€ Docs/
    â”‚   â”œâ”€â”€ commands-guide.md
    â”‚   â”œâ”€â”€ flags-guide.md
    â”‚   â”œâ”€â”€ installation-guide.md
    â”‚   â”œâ”€â”€ personas-guide.md
    â”‚   â””â”€â”€ superclaude-user-guide.md
    â”œâ”€â”€ profiles/
    â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”œâ”€â”€ developer.json
    â”‚   â”œâ”€â”€ minimal.json
    â”‚   â””â”€â”€ quick.json
    â”œâ”€â”€ setup/
    â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”œâ”€â”€ base/
    â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”œâ”€â”€ component.py
    â”‚   â”‚   â””â”€â”€ installer.py
    â”‚   â”œâ”€â”€ components/
    â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”œâ”€â”€ commands.py
    â”‚   â”‚   â”œâ”€â”€ core.py
    â”‚   â”‚   â”œâ”€â”€ hooks.py
    â”‚   â”‚   â””â”€â”€ mcp.py
    â”‚   â”œâ”€â”€ core/
    â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”œâ”€â”€ config_manager.py
    â”‚   â”‚   â”œâ”€â”€ file_manager.py
    â”‚   â”‚   â”œâ”€â”€ registry.py
    â”‚   â”‚   â”œâ”€â”€ settings_manager.py
    â”‚   â”‚   â””â”€â”€ validator.py
    â”‚   â”œâ”€â”€ operations/
    â”‚   â”‚   â”œâ”€â”€ __init__.py
    â”‚   â”‚   â”œâ”€â”€ backup.py
    â”‚   â”‚   â”œâ”€â”€ install.py
    â”‚   â”‚   â”œâ”€â”€ uninstall.py
    â”‚   â”‚   â””â”€â”€ update.py
    â”‚   â””â”€â”€ utils/
    â”‚       â”œâ”€â”€ __init__.py
    â”‚       â”œâ”€â”€ logger.py
    â”‚       â”œâ”€â”€ security.py
    â”‚       â””â”€â”€ ui.py
    â””â”€â”€ SuperClaude/
        â”œâ”€â”€ __init__.py
        â”œâ”€â”€ __main__.py
        â”œâ”€â”€ Commands/
        â”‚   â”œâ”€â”€ __init__.py
        â”‚   â”œâ”€â”€ analyze.md
        â”‚   â”œâ”€â”€ build.md
        â”‚   â”œâ”€â”€ cleanup.md
        â”‚   â”œâ”€â”€ design.md
        â”‚   â”œâ”€â”€ document.md
        â”‚   â”œâ”€â”€ estimate.md
        â”‚   â”œâ”€â”€ explain.md
        â”‚   â”œâ”€â”€ git.md
        â”‚   â”œâ”€â”€ implement.md
        â”‚   â”œâ”€â”€ improve.md
        â”‚   â”œâ”€â”€ index.md
        â”‚   â”œâ”€â”€ load.md
        â”‚   â”œâ”€â”€ spawn.md
        â”‚   â”œâ”€â”€ task.md
        â”‚   â”œâ”€â”€ test.md
        â”‚   â”œâ”€â”€ troubleshoot.md
        â”‚   â””â”€â”€ workflow.md
        â”œâ”€â”€ Core/
        â”‚   â”œâ”€â”€ __init__.py
        â”‚   â”œâ”€â”€ CLAUDE.md
        â”‚   â”œâ”€â”€ COMMANDS.md
        â”‚   â”œâ”€â”€ FLAGS.md
        â”‚   â”œâ”€â”€ MCP.md
        â”‚   â”œâ”€â”€ MODES.md
        â”‚   â”œâ”€â”€ ORCHESTRATOR.md
        â”‚   â”œâ”€â”€ PERSONAS.md
        â”‚   â”œâ”€â”€ PRINCIPLES.md
        â”‚   â””â”€â”€ RULES.md
        â””â”€â”€ Hooks/
            â”œâ”€â”€ __init__.py
            â””â”€â”€ PLACEHOLDER.py


Files Content:

(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: README.md
================================================
# SuperClaude v3 ğŸš€
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![PyPI version](https://img.shields.io/pypi/v/SuperClaude.svg)](https://pypi.org/project/SuperClaude/)
[![Version](https://img.shields.io/badge/version-3.0.0-blue.svg)](https://github.com/NomenAK/SuperClaude)
[![GitHub issues](https://img.shields.io/github/issues/NomenAK/SuperClaude)](https://github.com/NomenAK/SuperClaude/issues)
[![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](https://github.com/NomenAK/SuperClaude/blob/master/CONTRIBUTING.md)
[![Contributors](https://img.shields.io/github/contributors/NomenAK/SuperClaude)](https://github.com/NomenAK/SuperClaude/graphs/contributors)

A framework that extends Claude Code with specialized commands, personas, and MCP server integration.

**ğŸ“¢ Status**: Initial release, fresh out of beta! Bugs may occur as we continue improving things.

## What is SuperClaude? ğŸ¤”

SuperClaude tries to make Claude Code more helpful for development work by adding:
- ğŸ› ï¸ **16 specialized commands** for common dev tasks (some work better than others!)
- ğŸ­ **Smart personas** that usually pick the right expert for different domains 
- ğŸ”§ **MCP server integration** for docs, UI components, and browser automation
- ğŸ“‹ **Task management** that tries to keep track of progress
- âš¡ **Token optimization** to help with longer conversations

This is what we've been building to make development workflows smoother. Still rough around the edges, but getting better! ğŸ˜Š

## Current Status ğŸ“Š

âœ… **What's Working Well:**
- Installation suite (rewritten from the ground up)
- Core framework with 9 documentation files 
- 16 slash commands for various development tasks
- MCP server integration (Context7, Sequential, Magic, Playwright)
- Unified CLI installer for easy setup

âš ï¸ **Known Issues:**
- This is an initial release - bugs are expected
- Some features may not work perfectly yet
- Documentation is still being improved
- Hooks system was removed (coming back in v4)

## Key Features âœ¨

### Commands ğŸ› ï¸
We focused on 16 essential commands for the most common tasks:

**Development**: `/sc:implement`, `/sc:build`, `/sc:design`  
**Analysis**: `/sc:analyze`, `/sc:troubleshoot`, `/sc:explain`  
**Quality**: `/sc:improve`, `/sc:test`, `/sc:cleanup`  
**Others**: `/sc:document`, `/sc:git`, `/sc:estimate`, `/sc:task`, `/sc:index`, `/sc:load`, `/sc:spawn`

### Smart Personas ğŸ­
AI specialists that try to jump in when they seem relevant:
- ğŸ—ï¸ **architect** - Systems design and architecture stuff
- ğŸ¨ **frontend** - UI/UX and accessibility  
- âš™ï¸ **backend** - APIs and infrastructure
- ğŸ” **analyzer** - Debugging and figuring things out
- ğŸ›¡ï¸ **security** - Security concerns and vulnerabilities
- âœï¸ **scribe** - Documentation and writing
- *...and 5 more specialists*

*(They don't always pick perfectly, but usually get it right!)*

### MCP Integration ğŸ”§
External tools that connect when useful:
- **Context7** - Grabs official library docs and patterns 
- **Sequential** - Helps with complex multi-step thinking  
- **Magic** - Generates modern UI components 
- **Playwright** - Browser automation and testing stuff

*(These work pretty well when they connect properly! ğŸ¤)*

## âš ï¸ Upgrading from v2? Important!

If you're coming from SuperClaude v2, you'll need to clean up first:

1. **Uninstall v2** using its uninstaller if available
2. **Manual cleanup** - delete these if they exist:
   - `SuperClaude/`
   - `~/.claude/shared/`
   - `~/.claude/commands/` 
   - `~/.claude/CLAUDE.md`
4. **Then proceed** with v3 installation below

This is because v3 has a different structure and the old files can cause conflicts.

### ğŸ”„ **Key Change for v2 Users**
**The `/build` command changed!** In v2, `/build` was used for feature implementation. In v3:
- `/sc:build` = compilation/packaging only 
- `/sc:implement` = feature implementation (NEW!)

**Migration**: Replace `v2 /build myFeature` with `v3 /sc:implement myFeature`

## Installation ğŸ“¦

SuperClaude installation is a **two-step process**:
1. First install the Python package
2. Then run the installer to set up Claude Code integration

### Step 1: Install the Package

**Option A: From PyPI (Recommended)**
```bash
uv add SuperClaude
```

**Option B: From Source**
```bash
git clone https://github.com/NomenAK/SuperClaude.git
cd SuperClaude
uv sync
```
### ğŸ”§ UV / UVX Setup Guide

SuperClaude v3 also supports installation via [`uv`](https://github.com/astral-sh/uv) (a faster, modern Python package manager) or `uvx` for cross-platform usage.

### ğŸŒ€ Install with `uv`

Make sure `uv` is installed:

```bash
curl -Ls https://astral.sh/uv/install.sh | sh
```

> Or follow instructions from: [https://github.com/astral-sh/uv](https://github.com/astral-sh/uv)

Once `uv` is available, you can install SuperClaude like this:

```bash
uv venv
source .venv/bin/activate
uv pip install SuperClaude
```

### âš¡ Install with `uvx` (Cross-platform CLI)

If youâ€™re using `uvx`, just run:

```bash
uvx pip install SuperClaude
```

### âœ… Finish Installation

After installing, continue with the usual installer step:

```bash
python3 -m SuperClaude install
```

Or using bash-style CLI:

```bash
SuperClaude install
```

### ğŸ§  Note:

* `uv` provides better caching and performance.
* Compatible with Python 3.8+ and works smoothly with SuperClaude.

---
**Missing Python?** Install Python 3.7+ first:
```bash
# Linux (Ubuntu/Debian)
sudo apt update && sudo apt install python3 python3-pip

# macOS  
brew install python3

# Windows
# Download from https://python.org/downloads/
```

### Step 2: Run the Installer

After installing the package, run the SuperClaude installer to configure Claude Code (You can use any of the method):
### âš ï¸ Important Note 
**After installing the SuperClaude.**
**You can use `SuperClaude commands`
, `python3 -m SuperClaude commands` or also `python3 SuperClaude commands`**
```bash
# Quick setup (recommended for most users)
python3 SuperClaude install

# Interactive selection (choose components)
python3 SuperClaude install --interactive

# Minimal install (just core framework)
python3 SuperClaude install --minimal

# Developer setup (everything included)
python3 SuperClaude install --profile developer

# See all available options
python3 SuperClaude install --help
```
### Or Python Modular Usage
```bash
# Quick setup (recommended for most users)
python3 -m SuperClaude install

# Interactive selection (choose components)
python3 -m SuperClaude install --interactive

# Minimal install (just core framework)
python3 -m SuperClaude install --minimal

# Developer setup (everything included)
python3 -m SuperClaude install --profile developer

# See all available options
python3 -m SuperClaude install --help
```
### Simple bash Command Usage 
```bash
# Quick setup (recommended for most users)
SuperClaude install

# Interactive selection (choose components)
SuperClaude install --interactive

# Minimal install (just core framework)
SuperClaude install --minimal

# Developer setup (everything included)
SuperClaude install --profile developer

# See all available options
SuperClaude install --help
```

**That's it! ğŸ‰** The installer handles everything: framework files, MCP servers, and Claude Code configuration.

## How It Works ğŸ”„

SuperClaude tries to enhance Claude Code through:

1. **Framework Files** - Documentation installed to `~/.claude/` that guides how Claude responds
2. **Slash Commands** - 16 specialized commands for different dev tasks  
3. **MCP Servers** - External services that add extra capabilities (when they work!)
4. **Smart Routing** - Attempts to pick the right tools and experts based on what you're doing

Most of the time it plays nicely with Claude Code's existing stuff. ğŸ¤

## What's Coming in v4 ğŸ”®

We're hoping to work on these things for the next version:
- **Hooks System** - Event-driven stuff (removed from v3, trying to redesign it properly)
- **MCP Suite** - More external tool integrations  
- **Better Performance** - Trying to make things faster and less buggy
- **More Personas** - Maybe a few more domain specialists
- **Cross-CLI Support** - Might work with other AI coding assistants

*(No promises on timeline though - we're still figuring v3 out! ğŸ˜…)*

## Configuration âš™ï¸

After installation, you can customize SuperClaude by editing:
- `~/.claude/settings.json` - Main configuration
- `~/.claude/*.md` - Framework behavior files

Most users probably won't need to change anything - it usually works okay out of the box. ğŸ›ï¸

## Documentation ğŸ“–

Want to learn more? Check out our guides:

- ğŸ“š [**User Guide**](https://github.com/NomenAK/SuperClaude/blob/master/Docs/superclaude-user-guide.md) - Complete overview and getting started
- ğŸ› ï¸ [**Commands Guide**](https://github.com/NomenAK/SuperClaude/blob/master/Docs/commands-guide.md) - All 16 slash commands explained  
- ğŸ³ï¸ [**Flags Guide**](https://github.com/NomenAK/SuperClaude/blob/master/Docs/flags-guide.md) - Command flags and options
- ğŸ­ [**Personas Guide**](https://github.com/NomenAK/SuperClaude/blob/master/Docs/personas-guide.md) - Understanding the persona system
- ğŸ“¦ [**Installation Guide**](https://github.com/NomenAK/SuperClaude/blob/master/Docs/installation-guide.md) - Detailed installation instructions

These guides have more details than this README and are kept up to date.

## Contributing ğŸ¤

We welcome contributions! Areas where we could use help:
- ğŸ› **Bug Reports** - Let us know what's broken
- ğŸ“ **Documentation** - Help us explain things better  
- ğŸ§ª **Testing** - More test coverage for different setups
- ğŸ’¡ **Ideas** - Suggestions for new features or improvements

The codebase is pretty straightforward Python + documentation files.

## Project Structure ğŸ“

```
SuperClaude/
â”œâ”€â”€ setup.py               # pypi setup file
â”œâ”€â”€ SuperClaude/           # Framework files  
â”‚   â”œâ”€â”€ Core/              # Behavior documentation (COMMANDS.md, FLAGS.md, etc.)
â”‚   â”œâ”€â”€ Commands/          # 16 slash command definitions
â”‚   â””â”€â”€ Settings/          # Configuration files
â”œâ”€â”€ setup/                 # Installation system
â””â”€â”€ profiles/              # Installation profiles (quick, minimal, developer)
```

## Architecture Notes ğŸ—ï¸

The v3 architecture focuses on:
- **Simplicity** - Removed complexity that wasn't adding value
- **Reliability** - Better installation and fewer breaking changes  
- **Modularity** - Pick only the components you want
- **Performance** - Faster operations with smarter caching

We learned a lot from v2 and tried to address the main pain points.

## FAQ ğŸ™‹

**Q: Why was the hooks system removed?**  
A: It was getting complex and buggy. We're redesigning it properly for v4.

**Q: Does this work with other AI assistants?**  
A: Currently Claude Code only, but v4 will have broader compatibility.

**Q: Is this stable enough for daily use?**  
A: The basic stuff works pretty well, but definitely expect some rough edges since it's a fresh release. Probably fine for experimenting! ğŸ§ª

## SuperClaude Contributors

[![Contributors](https://contrib.rocks/image?repo=NomenAk/SuperClaude)](https://github.com/NomenAK/SuperClaude/graphs/contributors)

## License

MIT - [See LICENSE file for details](https://opensource.org/licenses/MIT)

## Star History

<a href="https://www.star-history.com/#NomenAK/SuperClaude&Date">
 <picture>
   <source media="(prefers-color-scheme: dark)" srcset="https://api.star-history.com/svg?repos=NomenAK/SuperClaude&type=Date&theme=dark" />
   <source media="(prefers-color-scheme: light)" srcset="https://api.star-history.com/svg?repos=NomenAK/SuperClaude&type=Date" />
   <img alt="Star History Chart" src="https://api.star-history.com/svg?repos=NomenAK/SuperClaude&type=Date" />
 </picture>
</a>
---

*Built by developers who got tired of generic responses. Hope you find it useful! ğŸ™‚*

---



================================================
FILE: CHANGELOG.md
================================================
# Changelog

All notable changes to SuperClaude will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Changed
- **BREAKING**: Commands now use `/sc:` namespace to avoid conflicts with user custom commands
- Commands are now installed in `~/.claude/commands/sc/` subdirectory
- All 16 commands updated: `/analyze` ï¿½ `/sc:analyze`, `/build` ï¿½ `/sc:build`, etc.
- Automatic migration from old command locations to new `sc/` subdirectory

### Added
- **NEW COMMAND**: `/sc:implement` for feature and code implementation (addresses v2 user feedback)
- Migration logic to move existing commands to new namespace automatically
- Enhanced uninstaller to handle both old and new command locations
- Improved command conflict prevention
- Better command organization and discoverability

### Technical Details
- Commands now accessible as `/sc:analyze`, `/sc:build`, `/sc:improve`, etc.
- Migration preserves existing functionality while preventing naming conflicts
- Installation process detects and migrates existing commands automatically
- Tab completion support for `/sc:` prefix to discover all SuperClaude commands

## [3.0.0] - 2025-07-14

### Added
- Initial release of SuperClaude v3.0
- 15 specialized slash commands for development tasks
- Smart persona auto-activation system
- MCP server integration (Context7, Sequential, Magic, Playwright)
- Unified CLI installer with multiple installation profiles
- Comprehensive documentation and user guides
- Token optimization framework
- Task management system

### Features
- **Commands**: analyze, build, cleanup, design, document, estimate, explain, git, improve, index, load, spawn, task, test, troubleshoot
- **Personas**: architect, frontend, backend, analyzer, security, mentor, refactorer, performance, qa, devops, scribe
- **MCP Servers**: Official library documentation, complex analysis, UI components, browser automation
- **Installation**: Quick, minimal, and developer profiles with component selection


================================================
FILE: CODE_OF_CONDUCT.md
================================================
# Code of Conduct

## ğŸ¤ Our Commitment

SuperClaude Framework is committed to providing a welcoming, inclusive, and harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.

We pledge to act in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.

## ğŸ¯ Our Standards

### Positive Behavior âœ…

Examples of behavior that contributes to a positive environment:

- **Be respectful** and considerate in communication
- **Welcome newcomers** and help them get started  
- **Focus on constructive feedback** that helps improve the project
- **Acknowledge different experiences** and skill levels
- **Accept responsibility** for mistakes and learn from them
- **Prioritize community benefit** over individual gains
- **Show empathy** towards other community members

### Unacceptable Behavior âŒ

Examples of unacceptable behavior:

- **Harassment or discrimination** of any kind
- **Trolling, insulting, or derogatory** comments
- **Personal or political attacks** on individuals
- **Publishing others' private information** without permission
- **Sexual language or imagery** and unwelcome sexual attention
- **Professional misconduct** or abuse of authority
- **Other conduct** which could reasonably be considered inappropriate

## ğŸ“‹ Our Responsibilities

### Project Maintainers
- **Clarify standards** of acceptable behavior
- **Take corrective action** in response to inappropriate behavior
- **Remove, edit, or reject** contributions that don't align with this Code of Conduct
- **Temporarily or permanently ban** contributors for behaviors deemed harmful

### Community Members
- **Report violations** through appropriate channels
- **Support newcomers** and help create an inclusive environment
- **Focus discussions** on technical topics and project improvement
- **Respect decisions** made by maintainers regarding conduct issues

## ğŸš¨ Enforcement

### Reporting Issues

If you experience or witness unacceptable behavior, please report it by:

1. **Email**: `conduct@superclaude.dev`
2. **GitHub**: Private message to project maintainers
3. **Direct contact**: Reach out to any maintainer directly

All reports will be handled confidentially and promptly.

### Investigation Process

1. **Initial review** within 48 hours
2. **Investigation** with all relevant parties
3. **Decision** based on established guidelines
4. **Action taken** appropriate to the situation
5. **Follow-up** to ensure resolution

### Possible Consequences

Based on the severity and nature of the violation:

#### 1. Correction ğŸ“
**Community Impact**: Minor inappropriate behavior  
**Consequence**: Private written warning with explanation of violation and guidance for future behavior

#### 2. Warning âš ï¸
**Community Impact**: Violation through a single incident or series of actions  
**Consequence**: Warning with specified consequences for continued behavior, including temporary restriction from community interaction

#### 3. Temporary Ban ğŸš«
**Community Impact**: Serious violation of community standards  
**Consequence**: Temporary ban from all community interaction and communication for a specified period

#### 4. Permanent Ban ğŸ”’
**Community Impact**: Pattern of violating community standards or severe single incident  
**Consequence**: Permanent ban from all community interaction and communication

## ğŸŒ Scope

This Code of Conduct applies in all community spaces, including:

- **GitHub repository** (issues, discussions, pull requests)
- **Communication channels** (Discord, Slack, email)
- **Events and meetups** (virtual or in-person)
- **Social media** when representing the project
- **Any other spaces** where community members interact regarding SuperClaude

## ğŸ’¬ Guidelines for Healthy Discussion

### Technical Discussions
- **Stay focused** on the technical aspects of issues
- **Provide context** for your suggestions and feedback
- **Be specific** about problems and proposed solutions
- **Acknowledge trade-offs** in different approaches

### Code Reviews
- **Focus on the code**, not the person
- **Explain the "why"** behind your suggestions
- **Suggest improvements** rather than just pointing out problems
- **Be patient** with less experienced contributors

### Community Support
- **Answer questions helpfully** without condescension
- **Share knowledge freely** and encourage learning
- **Direct people to resources** when you can't help directly
- **Celebrate successes** and acknowledge good contributions

## ğŸ“ Educational Approach

We believe in education over punishment when possible:

- **First-time violations** often receive guidance rather than penalties
- **Mentorship opportunities** for those who want to improve
- **Clear explanations** of why certain behavior is problematic
- **Resources and support** for understanding inclusive practices

## ğŸ“ Contact Information

### Conduct Team
- **Email**: `conduct@superclaude.dev`
- **Response time**: 48 hours maximum
- **Anonymous reporting**: Available upon request

### Project Leadership
For questions about this Code of Conduct or its enforcement:
- Create a GitHub Discussion with the "community" label
- Email project maintainers directly
- Check the [Contributing Guide](CONTRIBUTING.md) for additional guidance

## ğŸ™ Acknowledgments

This Code of Conduct is adapted from:
- [Contributor Covenant](https://www.contributor-covenant.org/), version 2.1
- [Django Code of Conduct](https://www.djangoproject.com/conduct/)
- [Python Community Code of Conduct](https://www.python.org/psf/conduct/)

## ğŸ“š Additional Resources

### Learning About Inclusive Communities
- [Open Source Guide: Building Welcoming Communities](https://opensource.guide/building-community/)
- [GitHub's Community Guidelines](https://docs.github.com/en/site-policy/github-terms/github-community-guidelines)
- [Mozilla Community Participation Guidelines](https://www.mozilla.org/en-US/about/governance/policies/participation/)

### Bystander Intervention
- **Speak up** when you see inappropriate behavior
- **Support** those who are being harassed or excluded
- **Report issues** even if you're not directly affected
- **Help create** an environment where everyone feels welcome

---

**Last Updated**: July 2025  
**Next Review**: January 2026

Thank you for helping make SuperClaude Framework a welcoming space for all developers! ğŸš€


================================================
FILE: CONTRIBUTING.md
================================================
# Contributing to SuperClaude Framework

Thanks for your interest in contributing! ğŸ™

SuperClaude is a community-driven project that enhances Claude Code through modular hooks and intelligent orchestration. Every contribution helps make the framework more useful for developers.

## ğŸš€ Quick Start

### Prerequisites
- Python 3.12+ (standard library only)
- Node.js 18+ (for MCP servers)
- Claude Code installed and authenticated

### Development Setup

```bash
# Clone the repository
git clone https://github.com/your-username/SuperClaude.git
cd SuperClaude

# Install SuperClaude
./install.sh --standard

# Run tests
python Tests/comprehensive_test.py
```

## ğŸ¯ Ways to Contribute

### ğŸ› Bug Reports
- Use GitHub Issues with the "bug" label
- Include system info (OS, Python/Node versions)
- Provide minimal reproduction steps
- Include relevant hook logs from `~/.claude/`

### ğŸ’¡ Feature Requests
- Check existing issues and roadmap first
- Use GitHub Issues with the "enhancement" label
- Describe the use case and expected behavior
- Consider if it fits the framework's modular philosophy

### ğŸ“ Documentation
- Fix typos or unclear explanations
- Add examples and use cases
- Improve installation guides
- Translate documentation (especially for Scribe persona)

### ğŸ”§ Code Contributions
- Focus on hooks, commands, or core framework components
- Follow existing patterns and conventions
- Include tests for new functionality
- Update documentation as needed

## ğŸ—ï¸ Architecture Overview

### Core Components
```
SuperClaude/
â”œâ”€â”€ SuperClaude/
â”‚   â”œâ”€â”€ Hooks/          # 15 Python hooks (main extension points)
â”‚   â”œâ”€â”€ Commands/       # 14 slash commands
â”‚   â”œâ”€â”€ Core/          # Framework documentation
â”‚   â””â”€â”€ Settings/      # Configuration files
â”œâ”€â”€ Scripts/           # Installation and utility scripts
â””â”€â”€ Tests/            # Test suite
```

### Hook System
Hooks are the primary extension mechanism:
- **PreToolUse**: Intercept before tool execution
- **PostToolUse**: Process after tool completion  
- **SubagentStop**: Handle sub-agent lifecycle
- **Stop**: Session cleanup and synthesis
- **Notification**: Real-time event processing

## ğŸ§ª Testing

### Running Tests
```bash
# Full test suite
python Tests/comprehensive_test.py

# Specific components
python Tests/task_management_test.py
python Tests/performance_test_suite.py

# Hook integration tests
python SuperClaude/Hooks/test_orchestration_integration.py
```

### Writing Tests
- Test hook behavior with mock data
- Include performance benchmarks
- Test error conditions and recovery
- Validate cross-component integration

## ğŸ“‹ Code Standards

### Python Code (Hooks)
```python
#!/usr/bin/env python3
"""
Brief description of hook purpose.
Part of SuperClaude Framework v3.0
"""

import json
import sys
from typing import Dict, Any

def process_hook_data(data: Dict[str, Any]) -> Dict[str, Any]:
    """Process hook data with proper error handling."""
    try:
        # Implementation here
        return {"status": "success", "data": result}
    except Exception as e:
        return {"status": "error", "message": str(e)}

if __name__ == "__main__":
    # Standard hook entry point
    input_data = json.loads(sys.stdin.read())
    result = process_hook_data(input_data)
    print(json.dumps(result))
```

### Documentation (Markdown)
- Use clear headings and structure
- Include code examples where helpful
- Add emoji sparingly for clarity ğŸ¯
- Keep language humble and developer-focused

### Commit Messages
```
type(scope): brief description

Longer explanation if needed.

- Specific changes made
- Why the change was needed
- Any breaking changes noted
```

Types: `feat`, `fix`, `docs`, `test`, `refactor`, `perf`, `chore`

## ğŸ”„ Development Workflow

### 1. Fork & Branch
```bash
git checkout -b feature/your-feature-name
```

### 2. Develop & Test
- Make focused, atomic changes
- Test locally with `--standard` installation
- Ensure hooks don't break existing functionality

### 3. Submit Pull Request
- Clear title and description
- Reference related issues
- Include test results
- Update documentation if needed

### 4. Code Review
- Address feedback promptly
- Keep discussions focused and respectful
- Be open to suggestions and improvements

## ğŸ“¦ Release Process

### Version Management
- Follow [Semantic Versioning](https://semver.org/)
- Update `VERSION` file
- Document changes in `CHANGELOG.md`
- Tag releases: `git tag v3.0.1`

### Release Checklist
- [ ] All tests pass
- [ ] Documentation updated
- [ ] CHANGELOG.md updated
- [ ] Version bumped
- [ ] Installation tested on clean system

## ğŸ¤ Community Guidelines

### Be Respectful
- Welcome newcomers and different experience levels
- Focus on the code and ideas, not personal attributes
- Help others learn and improve

### Stay Focused
- Keep discussions relevant to SuperClaude's goals
- Avoid scope creep in feature requests
- Consider if changes fit the modular philosophy

### Quality First
- Test your changes thoroughly
- Consider performance impact
- Think about maintainability

## ğŸ’¬ Getting Help

### Channels
- **GitHub Issues**: Bug reports and feature requests
- **GitHub Discussions**: General questions and ideas
- **Documentation**: Check existing guides first

### Common Questions

**Q: How do I debug hook execution?**
A: Check logs in `~/.claude/` and use verbose logging for detailed output.

**Q: Can I add new MCP servers?**
A: Yes! Follow the pattern in `settings.json` and add integration hooks.

**Q: How do I test changes without affecting my global setup?**
A: Use a separate test environment or backup your `~/.claude` directory before testing.

## ğŸ“„ License

By contributing, you agree that your contributions will be licensed under the MIT License.

## ğŸ™ Acknowledgments

Thanks to all contributors who help make SuperClaude better for the development community!


================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2024 SuperClaude Framework Contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


================================================
FILE: MANIFEST.in
================================================
include VERSION
include README.md
include LICENSE
recursive-include setup *
recursive-include SuperClaude *
recursive-include config *
recursive-include profiles *



================================================
FILE: pyproject.toml
================================================
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "SuperClaude"
dynamic = ["version"]
description = "SuperClaude Framework Management Hub"
readme = "README.md"
license = {text = "MIT"}
authors = [
    {name = "Mithun Gowda B", email = "contact@superclaude.dev"},
    {name = "NomenAK", email = "contact@superclaude.dev"},
]
requires-python = ">=3.8"
dependencies = [
    "setuptools>=45.0.0",
]
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
]

[project.urls]
Homepage = "https://github.com/NomenAK/SuperClaude"
Repository = "https://github.com/NomenAK/SuperClaude"
"Bug Tracker" = "https://github.com/NomenAK/SuperClaude/issues"
"GitHub" = "https://github.com/NomenAK/SuperClaude"
"Mithun Gowda B" = "https://github.com/mithun50"
"NomenAK" = "https://github.com/NomenAK"

[project.scripts]
SuperClaude = "SuperClaude.__main__:main"

[tool.hatch.version]
path = "VERSION"
pattern = "(?P<version>.*)"

[tool.hatch.build.targets.wheel]
packages = ["SuperClaude"]

[tool.hatch.build.targets.sdist]
include = [
    "SuperClaude/",
    "config/",
    "profiles/",
    "setup/",
    "VERSION",
    "README.md",
    "LICENSE",
    "MANIFEST.in",
]




================================================
FILE: ROADMAP.md
================================================
# SuperClaude Roadmap ğŸ—ºï¸

A realistic look at where we are and where we're headed. No marketing fluff, just honest development plans.

## Where We Are Now (v3.0 - July 2024) ğŸ“

SuperClaude v3 just came out of beta! ğŸ‰ Here's the honest current state:

### âœ… What's Working Well
- **Installation Suite** - Completely rewritten and much more reliable
- **Core Framework** - 9 documentation files that guide Claude's behavior  
- **15 Slash Commands** - Streamlined from 20+ to essential ones
- **MCP Integration** - Context7, Sequential, Magic, Playwright (partially working)
- **Unified CLI** - `SuperClaude.py` handles install/update/backup

### âš ï¸ What Needs Work
- **Bugs** - This is an initial release, expect rough edges
- **MCP Servers** - Integration works but could be smoother
- **Documentation** - Still improving user guides and examples
- **Performance** - Some operations slower than we'd like

### âŒ What We Removed
- **Hooks System** - Got too complex and buggy, removed for redesign

We're honestly pretty happy with v3 as a foundation, but there's definitely room for improvement.

## Short Term (v3.x) ğŸ”§

Our immediate focus is making v3 stable and polished:

### Bug Fixes & Stability ğŸ›
- Fix issues reported by early users
- Improve error messages and debugging
- Better handling of edge cases
- More reliable MCP server connections

### MCP Integration Improvements ğŸ”§
- Smoother Context7 documentation lookup
- Better Sequential reasoning integration  
- More reliable Magic UI component generation
- Improved Playwright browser automation

### Documentation & Examples ğŸ“
- User guides for common workflows
- Video tutorials (maybe, if we find time)
- Better command documentation
- Community cookbook of patterns

### Community Feedback ğŸ‘‚
- Actually listen to what people are saying
- Prioritize features people actually want
- Fix the things that are genuinely broken
- Be responsive to GitHub issues


## Medium Term (v4.0) ğŸš€

This is where things get more ambitious:

### Hooks System Return ğŸ”„
- **Complete redesign** - Learning from v3's mistakes
- **Event-driven architecture** - Properly thought out this time
- **Better performance** - Won't slow everything down
- **Simpler configuration** - Less complex than the old system

### MCP Suite Expansion ğŸ“¦
- **More MCP servers** - Additional specialized capabilities
- **Better coordination** - Servers working together smoothly
- **Community servers** - Framework for others to build on
- **Performance optimization** - Faster server communication

### Enhanced Core Features âš¡
- **Better task management** - Cross-session persistence
- **Improved token optimization** - More efficient conversations
- **Advanced orchestration** - Smarter routing and tool selection

### Quality & Performance ğŸ¯
- **Comprehensive testing** - Actually test things properly
- **Performance monitoring** - Know when things are slow
- **Better error recovery** - Graceful failure handling
- **Memory optimization** - Use resources more efficiently

*Timeline: Realistically targeting 2025, but could slip if v3 needs more work.*

## Long Term Vision (v5.0+) ğŸ”®

These are bigger ideas that might happen if everything goes well:

### Multi-CLI Compatibility ğŸŒ
- **OpenClode CLI** - Port SuperClaude to a more universal CLI
- **Beyond Claude Code** - Work with other AI coding assistants
- **Universal framework** - Common enhancement layer
- **Tool agnostic** - Core concepts portable across platforms
- **Ecosystem approach** - Not tied to single vendor

### Framework Evolution ğŸ·ï¸
- **SuperClaude rename** - Better reflects broader vision
- **Open source ecosystem** - Community-driven development
- **Plugin architecture** - Easy extensibility for developers
- **Cross-platform support** - Windows, macOS, Linux equally supported

### Advanced Intelligence ğŸ§ 
- **Learning capabilities** - Adapt to user patterns over time
- **Predictive assistance** - Anticipate what you need
- **Context persistence** - Remember across long projects
- **Collaborative features** - Team workflows and shared knowledge

*Timeline: This is pretty speculative. We'll see how v4 goes first.*

## How You Can Help ğŸ¤

We're a small team and could really use community input:

### Right Now ğŸš¨
- **Report bugs** - Seriously, tell us what's broken
- **Share feedback** - What works? What doesn't? What's missing?
- **Try different setups** - Help us find compatibility issues
- **Spread the word** - If you like it, tell other developers

### Ongoing ğŸ“‹
- **Feature requests** - What would make your workflow better?
- **Documentation** - Help us explain things clearly
- **Examples** - Share cool workflows you've discovered  
- **Code contributions** - PRs welcome for bug fixes

### Community Channels ğŸ’¬
- **GitHub Issues** - Bug reports and feature requests
- **GitHub Discussions** - General feedback and ideas
- **Pull Requests** - Code contributions and improvements

We read everything and try to respond thoughtfully.

## Staying Connected ğŸ“¢

### How We Communicate ğŸ“¡
- **GitHub Releases** - Major updates and changelogs
- **README updates** - Current status and key changes
- **This roadmap** - Updated quarterly (hopefully)

### What to Expect ğŸ””
- **Honest updates** - We'll tell you what's really happening
- **No overpromising** - Realistic timelines and scope
- **Community first** - Your feedback shapes our priorities
- **Transparent development** - Open about challenges and decisions

### Roadmap Updates ğŸ”„
We'll update this roadmap roughly every few months based on:
- How v3 is actually performing in the wild
- What the community is asking for
- Technical challenges we discover
- Changes in the AI development landscape
- Our own capacity and priorities

---

## Final Thoughts ğŸ’­

SuperClaude started as a way to make Claude Code more useful for developers. We think we're on the right track with v3, but we're definitely not done yet.

The most important thing is building something that actually helps people get their work done better. If you're using SuperClaude and it's making your development workflow smoother, that's awesome. If it's not, please tell us why.

We're in this for the long haul, but we want to make sure we're building the right things. Your feedback is crucial for keeping us pointed in the right direction.

Thanks for being part of this journey! ğŸ™

---


================================================
FILE: SECURITY.md
================================================
# Security Policy

## ğŸ”’ Reporting Security Vulnerabilities

We take security seriously. If you discover a security vulnerability in SuperClaude Framework, please help us address it responsibly.

### Responsible Disclosure

**Please do NOT create public GitHub issues for security vulnerabilities.**

Instead, email us directly at: `security@superclaude.dev` (or create a private GitHub Security Advisory)

### What to Include

When reporting a vulnerability, please provide:

- **Description** of the vulnerability and potential impact
- **Steps to reproduce** the issue with minimal examples
- **Affected versions** and components
- **Suggested fixes** if you have any ideas
- **Your contact information** for follow-up questions

### Response Timeline

- **Initial response**: Within 48 hours of report
- **Severity assessment**: Within 1 week
- **Fix timeline**: Depends on severity (see below)
- **Public disclosure**: After fix is released and users have time to update

## ğŸš¨ Severity Levels

### Critical (Fix within 24-48 hours)
- Remote code execution vulnerabilities
- Privilege escalation that affects system security
- Data exfiltration or unauthorized access to sensitive information

### High (Fix within 1 week)  
- Local code execution through hook manipulation
- Unauthorized file system access beyond intended scope
- Authentication bypass in MCP server communication

### Medium (Fix within 1 month)
- Information disclosure of non-sensitive data
- Denial of service through resource exhaustion
- Input validation issues with limited impact

### Low (Fix in next release)
- Minor information leaks
- Configuration issues with security implications
- Dependency vulnerabilities with low exploitability

## ğŸ›¡ï¸ Security Features

### Hook Execution Security
- **Timeout protection**: All hooks have configurable timeouts
- **Input validation**: JSON schema validation for all hook inputs
- **Sandboxed execution**: Hooks run with limited system permissions
- **Error containment**: Hook failures don't affect framework stability

### File System Protection
- **Path validation**: Prevents directory traversal attacks
- **Permission checking**: Validates file system permissions before operations
- **Secure defaults**: Conservative file access patterns
- **Backup mechanisms**: Safe fallback when operations fail

### MCP Server Security
- **Server validation**: Verify MCP server authenticity and integrity
- **Communication encryption**: Secure channels for all MCP communication
- **Timeout handling**: Prevent resource exhaustion from unresponsive servers
- **Fallback mechanisms**: Graceful degradation when servers are compromised

### Configuration Security
- **Input sanitization**: All configuration inputs are validated and sanitized
- **Secrets management**: Secure handling of API keys and sensitive data
- **Permission controls**: Fine-grained access controls in settings.json
- **Audit logging**: Track security-relevant configuration changes

## ğŸ”§ Security Best Practices

### For Users

#### Installation Security
```bash
# Verify installation scripts before running
cat install.sh | less

# Use development mode for testing
./install.sh --dev

# Check file permissions after installation
ls -la ~/.claude/
```

#### Configuration Security
```json
{
  "permissions": {
    "deny": [
      "Bash(rm:-rf /*)",
      "Bash(sudo:*)",
      "WebFetch(domain:localhost)"
    ]
  }
}
```

#### Regular Maintenance
- **Update regularly**: Keep SuperClaude and dependencies current
- **Review logs**: Check `~/.claude/` for suspicious activity
- **Monitor permissions**: Ensure hooks have minimal required permissions
- **Validate configurations**: Use provided schemas to validate settings

### For Developers

#### Hook Development
```python
# Always validate inputs
def validate_input(data: Dict[str, Any]) -> bool:
    required_fields = ["tool", "data"]
    return all(field in data for field in required_fields)

# Handle errors gracefully
try:
    result = process_data(input_data)
except Exception as e:
    return {"status": "error", "message": "Processing failed"}

# Use timeouts for external calls
import signal
signal.alarm(10)  # 10-second timeout
```

#### Secure Coding Guidelines
- **Input validation**: Validate all external inputs
- **Error handling**: Never expose internal state in error messages
- **Resource limits**: Implement timeouts and resource limits
- **Principle of least privilege**: Request minimal required permissions

## ğŸ“‹ Security Checklist

### Before Release
- [ ] All dependencies updated to latest secure versions
- [ ] Static security analysis run (bandit, safety)
- [ ] Input validation tests pass
- [ ] Permission model reviewed
- [ ] Documentation updated with security considerations

### Regular Maintenance
- [ ] Monthly dependency security updates
- [ ] Quarterly security review of codebase
- [ ] Annual third-party security assessment
- [ ] Continuous monitoring of security advisories

## ğŸ¤ Security Community

### Bug Bounty Program
Currently, we don't have a formal bug bounty program, but we recognize security researchers who help improve SuperClaude's security:

- **Public acknowledgment** in release notes and security advisories
- **Early access** to new features and versions
- **Direct communication** with the development team

### Security Advisory Process
1. **Internal assessment** of reported vulnerability
2. **Fix development** with thorough testing
3. **Coordinated disclosure** with security researcher
4. **Public advisory** published after fix release
5. **Post-mortem** to prevent similar issues

## ğŸ“ Contact Information

### Security Team
- **Email**: `security@superclaude.dev`
- **PGP Key**: Available on request
- **Response Time**: 48 hours maximum

### General Security Questions
For general security questions (not vulnerabilities):
- Create a GitHub Discussion with the "security" label
- Check existing documentation in this file
- Review the [Contributing Guide](CONTRIBUTING.md) for development security practices

## ğŸ“š Additional Resources

### Security-Related Documentation
- [Contributing Guidelines](CONTRIBUTING.md) - Secure development practices
- [Installation Guide](README.md) - Secure installation procedures
- [Configuration Reference](SuperClaude/Settings/settings.json) - Security settings

### External Security Resources
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [Python Security Best Practices](https://python.org/dev/security/)
- [Node.js Security Best Practices](https://nodejs.org/en/docs/guides/security/)

---

**Last Updated**: July 2025  
**Next Review**: October 2025

Thank you for helping keep SuperClaude Framework secure! ğŸ™


================================================
FILE: setup.py
================================================
import setuptools
import sys
import logging

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def get_version():
    """Get version from VERSION file with proper error handling."""
    try:
        with open("VERSION", "r") as f:
            return f.read().strip()
    except FileNotFoundError:
        logger.warning("VERSION file not found, using fallback version")
        return "3.0.0"
    except Exception as e:
        logger.error(f"Error reading VERSION file: {e}")
        return "3.0.0"

def get_long_description():
    """Get long description from README with error handling."""
    try:
        with open("README.md", "r", encoding="utf-8") as fh:
            return fh.read()
    except FileNotFoundError:
        logger.warning("README.md not found")
        return "SuperClaude Framework Management Hub"
    except Exception as e:
        logger.error(f"Error reading README.md: {e}")
        return "SuperClaude Framework Management Hub"

def get_install_requires():
    """Get install requirements with proper dependency management."""
    base_requires = ["setuptools>=45.0.0"]
    
    # Add Python version-specific dependencies
    if sys.version_info < (3, 8):
        base_requires.append("importlib-metadata>=1.0.0")
    
    # Add other dependencies your project needs
    # base_requires.extend([
    #     "requests>=2.25.0",
    #     "click>=7.0",
    #     # etc.
    # ])
    
    return base_requires

# Main setup configuration
setuptools.setup(
    name="SuperClaude",
    version=get_version(),
    author="Mithun Gowda B, NomenAK",
    author_email="contact@superclaude.dev",
    description="SuperClaude Framework Management Hub",
    long_description=get_long_description(),
    long_description_content_type="text/markdown",
    url="https://github.com/NomenAK/SuperClaude",
    packages=setuptools.find_packages(),
    include_package_data=True,
    install_requires=get_install_requires(),
    entry_points={
        "console_scripts": [
            "SuperClaude=SuperClaude.__main__:main",
            "superclaude=SuperClaude.__main__:main",
        ],
    },
    python_requires=">=3.8",
    project_urls={
        "GitHub": "https://github.com/NomenAK/SuperClaude",
        "Mithun Gowda B": "https://github.com/mithun50",
        "NomenAK": "https://github.com/NomenAK",
        "Bug Tracker": "https://github.com/NomenAK/SuperClaude/issues",
    },
    classifiers=[
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
        "Programming Language :: Python :: 3.12",
        "Operating System :: OS Independent",
        "License :: OSI Approved :: MIT License",
        "Development Status :: 4 - Beta",
        "Intended Audience :: Developers",
    ],
        )



================================================
FILE: uv.lock
================================================
version = 1
revision = 1
requires-python = ">=3.8"
resolution-markers = [
    "python_full_version >= '3.9'",
    "python_full_version < '3.9'",
]

[[package]]
name = "setuptools"
version = "75.3.2"
source = { registry = "https://pypi.org/simple" }
resolution-markers = [
    "python_full_version < '3.9'",
]
sdist = { url = "https://files.pythonhosted.org/packages/5c/01/771ea46cce201dd42cff043a5eea929d1c030fb3d1c2ee2729d02ca7814c/setuptools-75.3.2.tar.gz", hash = "sha256:3c1383e1038b68556a382c1e8ded8887cd20141b0eb5708a6c8d277de49364f5", size = 1354489 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/15/65/3f0dba35760d902849d39d38c0a72767794b1963227b69a587f8a336d08c/setuptools-75.3.2-py3-none-any.whl", hash = "sha256:90ab613b6583fc02d5369cbca13ea26ea0e182d1df2d943ee9cbe81d4c61add9", size = 1251198 },
]

[[package]]
name = "setuptools"
version = "80.9.0"
source = { registry = "https://pypi.org/simple" }
resolution-markers = [
    "python_full_version >= '3.9'",
]
sdist = { url = "https://files.pythonhosted.org/packages/18/5d/3bf57dcd21979b887f014ea83c24ae194cfcd12b9e0fda66b957c69d1fca/setuptools-80.9.0.tar.gz", hash = "sha256:f36b47402ecde768dbfafc46e8e4207b4360c654f1f3bb84475f0a28628fb19c", size = 1319958 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/a3/dc/17031897dae0efacfea57dfd3a82fdd2a2aeb58e0ff71b77b87e44edc772/setuptools-80.9.0-py3-none-any.whl", hash = "sha256:062d34222ad13e0cc312a4c02d73f059e86a4acbfbdea8f8f76b28c99f306922", size = 1201486 },
]

[[package]]
name = "superclaude"
source = { editable = "." }
dependencies = [
    { name = "setuptools", version = "75.3.2", source = { registry = "https://pypi.org/simple" }, marker = "python_full_version < '3.9'" },
    { name = "setuptools", version = "80.9.0", source = { registry = "https://pypi.org/simple" }, marker = "python_full_version >= '3.9'" },
]

[package.metadata]
requires-dist = [{ name = "setuptools", specifier = ">=45.0.0" }]



================================================
FILE: VERSION
================================================
3.0.0


================================================
FILE: config/__init__.py
================================================
[Empty file]


================================================
FILE: config/features.json
================================================
{
  "components": {
    "core": {
      "name": "core",
      "version": "3.0.0",
      "description": "SuperClaude framework documentation and core files",
      "category": "core",
      "dependencies": [],
      "enabled": true,
      "required_tools": []
    },
    "commands": {
      "name": "commands",
      "version": "3.0.0", 
      "description": "SuperClaude slash command definitions",
      "category": "commands",
      "dependencies": ["core"],
      "enabled": true,
      "required_tools": []
    },
    "mcp": {
      "name": "mcp",
      "version": "3.0.0",
      "description": "MCP server integration (Context7, Sequential, Magic, Playwright)",
      "category": "integration",
      "dependencies": ["core"],
      "enabled": true,
      "required_tools": ["node", "claude_cli"]
    },
    "hooks": {
      "name": "hooks",
      "version": "3.0.0",
      "description": "Claude Code hooks integration (future-ready)",
      "category": "integration", 
      "dependencies": ["core"],
      "enabled": false,
      "required_tools": []
    }
  }
}


================================================
FILE: config/requirements.json
================================================
{
  "python": {
    "min_version": "3.8.0"
  },
  "node": {
    "min_version": "16.0.0",
    "required_for": ["mcp"]
  },
  "disk_space_mb": 500,
  "external_tools": {
    "claude_cli": {
      "command": "claude --version",
      "min_version": "0.1.0",
      "required_for": ["mcp"],
      "optional": false
    },
    "git": {
      "command": "git --version",
      "min_version": "2.0.0",
      "required_for": ["development"],
      "optional": true
    }
  },
  "installation_commands": {
    "python": {
      "linux": "sudo apt update && sudo apt install python3 python3-pip",
      "darwin": "brew install python3",
      "win32": "Download Python from https://python.org/downloads/",
      "description": "Python 3.8+ is required for SuperClaude framework"
    },
    "node": {
      "linux": "sudo apt update && sudo apt install nodejs npm",
      "darwin": "brew install node",
      "win32": "Download Node.js from https://nodejs.org/",
      "description": "Node.js 16+ is required for MCP server integration"
    },
    "claude_cli": {
      "all": "Visit https://claude.ai/code for installation instructions",
      "description": "Claude CLI is required for MCP server management"
    },
    "git": {
      "linux": "sudo apt update && sudo apt install git",
      "darwin": "brew install git",
      "win32": "Download Git from https://git-scm.com/downloads",
      "description": "Git is recommended for development workflows"
    },
    "npm": {
      "linux": "sudo apt update && sudo apt install npm",
      "darwin": "npm is included with Node.js",
      "win32": "npm is included with Node.js",
      "description": "npm is required for installing MCP servers"
    }
  }
}


================================================
FILE: Docs/commands-guide.md
================================================
# SuperClaude Commands Guide ğŸ› ï¸

## ğŸ’¡ Don't Overthink It - SuperClaude Tries to Help

**The truth about these 17 commands**: You don't need to memorize them. Just start with `/sc:analyze` or `/sc:implement` and see what happens! 

**Here's how it usually works:**
- Type `/` in Claude Code â†’ See available commands
- Use basic ones like `/sc:analyze`, `/sc:build`, `/sc:improve` 
- **SuperClaude tries to pick helpful tools and experts** for each situation
- More commands become useful as you get comfortable

**Auto-activation is pretty neat** ğŸª„ - SuperClaude attempts to detect what you're trying to do and activate relevant specialists (security expert, performance optimizer, etc.) without you managing it. Usually works well! ğŸ˜Š

---

## Quick "Just Try These" List ğŸš€

**Start here** (no reading required):
```bash
/sc:help                    # See what's available
/sc:analyze src/            # Tries to analyze your code smartly 
/sc:workflow feature-100-prd.md  # Creates step-by-step implementation workflow from PRD
/sc:implement user-auth     # Creates features and components (replaces v2 /build)
/sc:build                   # Attempts intelligent project building
/sc:improve messy-file.js   # Tries to clean up code 
/sc:troubleshoot "error"    # Attempts to help with problems
```

**That's honestly enough to get started.** Everything else below is here when you get curious about what other tools are available. ğŸ› ï¸

---

A practical guide to all 16 SuperClaude slash commands. We'll be honest about what works well and what's still rough around the edges.

## Quick Reference ğŸ“‹

*(You really don't need to memorize this - just pick what sounds useful)*

| Command | Purpose | Auto-Activates | Best For |
|---------|---------|-----------------|----------|
| `/sc:analyze` | Smart code analysis | Security/performance experts | Finding issues, understanding codebases |
| `/sc:build` | Intelligent building | Frontend/backend specialists | Compilation, bundling, deployment prep |
| `/sc:implement` | Feature implementation | Domain-specific experts | Creating features, components, APIs, services |
| `/sc:improve` | Automatic code cleanup | Quality experts | Refactoring, optimization, quality fixes |
| `/sc:troubleshoot` | Problem investigation | Debug specialists | Debugging, issue investigation |
| `/sc:test` | Smart testing | QA experts | Running tests, coverage analysis |
| `/sc:document` | Auto documentation | Writing specialists | README files, code comments, guides |
| `/sc:git` | Enhanced git workflows | DevOps specialists | Smart commits, branch management |
| `/sc:design` | System design help | Architecture experts | Architecture planning, API design |
| `/sc:explain` | Learning assistant | Teaching specialists | Learning concepts, understanding code |
| `/sc:cleanup` | Debt reduction | Refactoring experts | Removing dead code, organizing files |
| `/sc:load` | Context understanding | Analysis experts | Project analysis, codebase understanding |
| `/sc:estimate` | Smart estimation | Planning experts | Time/effort planning, complexity analysis |
| `/sc:spawn` | Complex workflows | Orchestration system | Multi-step operations, workflow automation |
| `/sc:task` | Project management | Planning system | Long-term feature planning, task tracking |
| `/sc:workflow` | Implementation planning | Workflow system | Creating step-by-step workflows from PRDs |
| `/sc:index` | Command navigation | Help system | Finding the right command for your task |

**Pro tip**: Just try the ones that sound useful. SuperClaude usually tries to activate helpful experts and tools for each situation! ğŸ¯

## Development Commands ğŸ”¨

### `/workflow` - Implementation Workflow Generator ğŸ—ºï¸
**What it does**: Analyzes PRDs and feature requirements to create comprehensive step-by-step implementation workflows.

**The helpful part**: Takes your PRD and breaks it down into a structured implementation plan with expert guidance, dependency mapping, and task orchestration! ğŸ¯

**When to use it**:
- Starting a new feature from a PRD or specification
- Need a clear implementation roadmap
- Want expert guidance on implementation strategy
- Planning complex features with multiple dependencies

**The magic**: Auto-activates appropriate expert personas (architect, security, frontend, backend) and MCP servers (Context7 for patterns, Sequential for complex analysis) based on your feature requirements.

**Examples**:
```bash
/sc:workflow docs/feature-100-prd.md --strategy systematic --c7 --sequential
/sc:workflow "user authentication system" --persona security --output detailed
/sc:workflow payment-api --strategy mvp --risks --dependencies
```

**What you get**:
- **Roadmap Format**: Phase-based implementation plan with timelines
- **Tasks Format**: Organized epics, stories, and actionable tasks  
- **Detailed Format**: Step-by-step instructions with time estimates
- **Risk Assessment**: Potential issues and mitigation strategies
- **Dependency Mapping**: Internal and external dependencies
- **Expert Guidance**: Domain-specific best practices and patterns

### `/implement` - Feature Implementation
**What it does**: Implements features, components, and functionality with intelligent expert activation.

**The helpful part**: SuperClaude auto-activates the right experts (frontend, backend, security) and tools based on what you're implementing! ğŸ¯

**When to use it**:
- Creating new features or components (replaces v2's `/build` functionality)
- Implementing APIs, services, or modules
- Building UI components with modern frameworks
- Developing business logic and integrations

**Basic syntax**:
```bash
/sc:implement user authentication system      # Implement complete feature
/sc:implement --type component LoginForm      # Create specific component  
/sc:implement --type api user-management      # Build API endpoints
/sc:implement --framework react dashboard     # Framework-specific implementation
```

**Useful flags**:
- `--type component|api|service|feature|module` - Implementation type
- `--framework react|vue|express|django|etc` - Target framework
- `--safe` - Conservative implementation approach
- `--iterative` - Step-by-step development with validation
- `--with-tests` - Include test implementation
- `--documentation` - Generate docs alongside code

**Real examples**:
```bash
/sc:implement user authentication --type feature --with-tests
/sc:implement dashboard component --type component --framework react
/sc:implement REST API for orders --type api --safe
/sc:implement payment processing --type service --iterative
/sc:implement search functionality --framework vue --documentation
```

**Auto-activation patterns**:
- **Frontend**: UI components, React/Vue/Angular â†’ frontend persona + Magic MCP
- **Backend**: APIs, services, databases â†’ backend persona + Context7
- **Security**: Auth, payments, sensitive data â†’ security persona + validation
- **Complex features**: Multi-step implementations â†’ Sequential MCP + architect persona

**Gotchas**:
- Specify `--type` for better results (component vs service vs feature)
- Use `--framework` when working with specific tech stacks
- Try `--safe` for production code or `--iterative` for complex features
- Remember: this replaces v2's `/build` for actual code implementation

---

### `/build` - Project Building
**What it does**: Builds, compiles, and packages projects with smart error handling.

**The easy way**: Just type `/sc:build` and SuperClaude tries to figure out your build system! ğŸ¯

**When to use it**:
- You need to compile/bundle your project (just try `/sc:build`)
- Build process is failing and you want help debugging  
- Setting up build optimization (it tries to detect what you need)
- Preparing for deployment

**Basic syntax**:
```bash
/sc:build                          # Build current project
/sc:build --type prod              # Production build
/sc:build --clean                  # Clean build (remove old artifacts)
/sc:build --optimize               # Enable optimizations
/sc:build src/                     # Build specific directory
```

**Useful flags**:
- `--type dev|prod|test` - Build type
- `--clean` - Clean before building  
- `--optimize` - Enable build optimizations
- `--verbose` - Show detailed build output

**Real examples**:
```bash
/sc:build --type prod --optimize   # Production build with optimizations
/sc:build --clean --verbose        # Clean build with detailed output
/sc:build src/components           # Build just the components folder
```

**Gotchas**:
- Works best with common build tools (npm, webpack, etc.)
- May struggle with very custom build setups
- Check your build tool is in PATH

---

### `/design` - System & Component Design
**What it does**: Creates system architecture, API designs, and component specifications.

**When to use it**:
- Planning new features or systems
- Need API or database design
- Creating component architecture
- Documenting system relationships

**Basic syntax**:
```bash
/sc:design user-auth-system        # Design a user authentication system
/sc:design --type api auth         # Design just the API part
/sc:design --format spec payment   # Create formal specification
```

**Useful flags**:
- `--type architecture|api|component|database` - Design focus
- `--format diagram|spec|code` - Output format
- `--iterative` - Refine design through iterations

**Real examples**:
```bash
/sc:design --type api user-management    # Design user management API
/sc:design --format spec chat-system     # Create chat system specification
/sc:design --type database ecommerce     # Design database schema
```

**Gotchas**:
- More conceptual than code-generating
- Output quality depends on how clearly you describe requirements
- Great for planning phase, less for implementation details

## Analysis Commands ğŸ”

### `/analyze` - Code Analysis  
**What it does**: Comprehensive analysis of code quality, security, performance, and architecture.

**The helpful part**: SuperClaude tries to detect what kind of analysis you need and usually picks relevant experts! ğŸ”

**When to use it**:
- Understanding unfamiliar codebases (just point it at any folder)
- Finding security vulnerabilities (security expert usually jumps in)
- Performance bottleneck hunting (performance expert usually helps)
- Code quality assessment (quality specialist often takes over)

**Basic syntax**:
```bash
/sc:analyze src/                   # Analyze entire src directory
/sc:analyze --focus security       # Focus on security issues
/sc:analyze --depth deep app.js    # Deep analysis of specific file
```

**Useful flags**:
- `--focus quality|security|performance|architecture` - Analysis focus
- `--depth quick|deep` - Analysis thoroughness
- `--format text|json|report` - Output format

**Real examples**:
```bash
/sc:analyze --focus security --depth deep     # Deep security analysis
/sc:analyze --focus performance src/api/      # Performance analysis of API
/sc:analyze --format report .                 # Generate analysis report
```

**Gotchas**:
- Can take a while on large codebases
- Security analysis is pretty good, performance analysis varies
- Works best with common languages (JS, Python, etc.)

---

### `/troubleshoot` - Problem Investigation
**What it does**: Systematic debugging and problem investigation.

**When to use it**:
- Something's broken and you're not sure why
- Need systematic debugging approach
- Error messages are confusing
- Performance issues investigation

**Basic syntax**:
```bash
/sc:troubleshoot "login not working"     # Investigate login issue
/sc:troubleshoot --logs error.log        # Analyze error logs
/sc:troubleshoot performance             # Performance troubleshooting
```

**Useful flags**:
- `--logs <file>` - Include log file analysis
- `--systematic` - Use structured debugging approach
- `--focus network|database|frontend` - Focus area

**Real examples**:
```bash
/sc:troubleshoot "API returning 500" --logs server.log
/sc:troubleshoot --focus database "slow queries"
/sc:troubleshoot "build failing" --systematic
```

**Gotchas**:
- Works better with specific error descriptions
- Include relevant error messages and logs when possible
- May suggest obvious things first (that's usually good!)

---

### `/explain` - Educational Explanations
**What it does**: Explains code, concepts, and technologies in an educational way.

**When to use it**:
- Learning new technologies or patterns
- Understanding complex code
- Need clear explanations for team members
- Documenting tricky concepts

**Basic syntax**:
```bash
/sc:explain async/await               # Explain async/await concept
/sc:explain --code src/utils.js       # Explain specific code file
/sc:explain --beginner React hooks    # Beginner-friendly explanation
```

**Useful flags**:
- `--beginner` - Simpler explanations
- `--advanced` - Technical depth
- `--code <file>` - Explain specific code
- `--examples` - Include practical examples

**Real examples**:
```bash
/sc:explain --beginner "what is REST API"
/sc:explain --code src/auth.js --advanced
/sc:explain --examples "React context patterns"
```

**Gotchas**:
- Great for well-known concepts, may struggle with very niche topics
- Better with specific questions than vague "explain this codebase"
- Include context about your experience level

## Quality Commands âœ¨

### `/improve` - Code Enhancement
**What it does**: Systematic improvements to code quality, performance, and maintainability.

**When to use it**:
- Refactoring messy code
- Performance optimization
- Applying best practices
- Modernizing old code

**Basic syntax**:
```bash
/sc:improve src/legacy/            # Improve legacy code
/sc:improve --type performance     # Focus on performance
/sc:improve --safe src/utils.js    # Safe, low-risk improvements only
```

**Useful flags**:
- `--type quality|performance|maintainability|style` - Improvement focus
- `--safe` - Only apply low-risk changes
- `--preview` - Show what would be changed without doing it

**Real examples**:
```bash
/sc:improve --type performance --safe src/api/
/sc:improve --preview src/components/LegacyComponent.js
/sc:improve --type style . --safe
```

**Gotchas**:
- Always use `--preview` first to see what it wants to change
- `--safe` is your friend - prevents risky refactoring
- Works best on smaller files/modules rather than entire codebases

---

### `/cleanup` - Technical Debt Reduction
**What it does**: Removes dead code, unused imports, and organizes file structure.

**When to use it**:
- Codebase feels cluttered
- Lots of unused imports/variables
- File organization is messy
- Before major refactoring

**Basic syntax**:
```bash
/sc:cleanup src/                   # Clean up src directory
/sc:cleanup --dead-code            # Focus on dead code removal
/sc:cleanup --imports package.js   # Clean up imports in specific file
```

**Useful flags**:
- `--dead-code` - Remove unused code
- `--imports` - Clean up import statements
- `--files` - Reorganize file structure
- `--safe` - Conservative cleanup only

**Real examples**:
```bash
/sc:cleanup --dead-code --safe src/utils/
/sc:cleanup --imports src/components/
/sc:cleanup --files . --safe
```

**Gotchas**:
- Can be aggressive - always review changes carefully
- May not catch all dead code (especially dynamic imports)
- Better to run on smaller sections than entire projects

---

### `/test` - Testing & Quality Assurance
**What it does**: Runs tests, generates coverage reports, and maintains test quality.

**When to use it**:
- Running test suites
- Checking test coverage
- Generating test reports
- Setting up continuous testing

**Basic syntax**:
```bash
/sc:test                           # Run all tests
/sc:test --type unit               # Run only unit tests
/sc:test --coverage                # Generate coverage report
/sc:test --watch src/              # Watch mode for development
```

**Useful flags**:
- `--type unit|integration|e2e|all` - Test type
- `--coverage` - Generate coverage reports
- `--watch` - Run tests in watch mode
- `--fix` - Try to fix failing tests automatically

**Real examples**:
```bash
/sc:test --type unit --coverage
/sc:test --watch src/components/
/sc:test --type e2e --fix
```

**Gotchas**:
- Needs your test framework to be properly configured
- Coverage reports depend on your existing test setup
- `--fix` is experimental - review what it changes

## Documentation Commands ğŸ“

### `/document` - Focused Documentation
**What it does**: Creates documentation for specific components, functions, or features.

**When to use it**:
- Need README files
- Writing API documentation
- Adding code comments
- Creating user guides

**Basic syntax**:
```bash
/sc:document src/api/auth.js       # Document authentication module
/sc:document --type api            # API documentation
/sc:document --style brief README  # Brief README file
```

**Useful flags**:
- `--type inline|external|api|guide` - Documentation type
- `--style brief|detailed` - Level of detail
- `--template` - Use specific documentation template

**Real examples**:
```bash
/sc:document --type api src/controllers/
/sc:document --style detailed --type guide user-onboarding
/sc:document --type inline src/utils/helpers.js
```

**Gotchas**:
- Better with specific files/functions than entire projects
- Quality depends on how well-structured your code is
- May need some editing to match your project's documentation style

## Project Management Commands ğŸ“Š

### `/estimate` - Project Estimation
**What it does**: Estimates time, effort, and complexity for development tasks.

**When to use it**:
- Planning new features
- Sprint planning
- Understanding project complexity
- Resource allocation

**Basic syntax**:
```bash
/sc:estimate "add user authentication"    # Estimate auth feature
/sc:estimate --detailed shopping-cart     # Detailed breakdown
/sc:estimate --complexity user-dashboard  # Complexity analysis
```

**Useful flags**:
- `--detailed` - Detailed breakdown of tasks
- `--complexity` - Focus on technical complexity
- `--team-size <n>` - Consider team size in estimates

**Real examples**:
```bash
/sc:estimate --detailed "implement payment system"
/sc:estimate --complexity --team-size 3 "migrate to microservices"
/sc:estimate "add real-time chat" --detailed
```

**Gotchas**:
- Estimates are rough - use as starting points, not gospel
- Works better with clear, specific feature descriptions
- Consider your team's experience with the tech stack

---

### `/task` - Long-term Project Management
**What it does**: Manages complex, multi-session development tasks and features.

**When to use it**:
- Planning features that take days/weeks
- Breaking down large projects
- Tracking progress across sessions
- Coordinating team work

**Basic syntax**:
```bash
/sc:task create "implement user dashboard"  # Create new task
/sc:task status                            # Check task status
/sc:task breakdown "payment integration"    # Break down into subtasks
```

**Useful flags**:
- `create` - Create new long-term task
- `status` - Check current task status
- `breakdown` - Break large task into smaller ones
- `--priority high|medium|low` - Set task priority

**Real examples**:
```bash
/sc:task create "migrate from REST to GraphQL" --priority high
/sc:task breakdown "e-commerce checkout flow"
/sc:task status
```

**Gotchas**:
- Still experimental - doesn't always persist across sessions reliably ğŸ˜…
- Better for planning than actual project management
- Works best when you're specific about requirements

---

### `/spawn` - Complex Operation Orchestration
**What it does**: Coordinates complex, multi-step operations and workflows.

**When to use it**:
- Operations involving multiple tools/systems
- Coordinating parallel workflows
- Complex deployment processes
- Multi-stage data processing

**Basic syntax**:
```bash
/sc:spawn deploy-pipeline          # Orchestrate deployment
/sc:spawn --parallel migrate-data  # Parallel data migration
/sc:spawn setup-dev-environment    # Complex environment setup
```

**Useful flags**:
- `--parallel` - Run operations in parallel when possible
- `--sequential` - Force sequential execution
- `--monitor` - Monitor operation progress

**Real examples**:
```bash
/sc:spawn --parallel "test and deploy to staging"
/sc:spawn setup-ci-cd --monitor
/sc:spawn --sequential database-migration
```

**Gotchas**:
- Most complex command - expect some rough edges
- Better for well-defined workflows than ad-hoc operations
- May need multiple iterations to get right

## Version Control Commands ğŸ”„

### `/git` - Enhanced Git Operations
**What it does**: Git operations with intelligent commit messages and workflow optimization.

**When to use it**:
- Making commits with better messages
- Branch management
- Complex git workflows
- Git troubleshooting

**Basic syntax**:
```bash
/sc:git commit                     # Smart commit with auto-generated message
/sc:git --smart-commit add .       # Add and commit with smart message
/sc:git branch feature/new-auth    # Create and switch to new branch
```

**Useful flags**:
- `--smart-commit` - Generate intelligent commit messages
- `--branch-strategy` - Apply branch naming conventions
- `--interactive` - Interactive mode for complex operations

**Real examples**:
```bash
/sc:git --smart-commit "fixed login bug"
/sc:git branch feature/user-dashboard --branch-strategy
/sc:git merge develop --interactive
```

**Gotchas**:
- Smart commit messages are pretty good but review them
- Assumes you're following common git workflows
- Won't fix bad git habits - just makes them easier

## Utility Commands ğŸ”§

### `/index` - Command Navigation
**What it does**: Helps you find the right command for your task.

**When to use it**:
- Not sure which command to use
- Exploring available commands
- Learning about command capabilities

**Basic syntax**:
```bash
/sc:index                          # List all commands
/sc:index testing                  # Find commands related to testing
/sc:index --category analysis      # Commands in analysis category
```

**Useful flags**:
- `--category <cat>` - Filter by command category
- `--search <term>` - Search command descriptions

**Real examples**:
```bash
/sc:index --search "performance"
/sc:index --category quality
/sc:index git
```

**Gotchas**:
- Simple but useful for discovery
- Better than trying to remember all 16 commands

---

### `/load` - Project Context Loading
**What it does**: Loads and analyzes project context for better understanding.

**When to use it**:
- Starting work on unfamiliar project
- Need to understand project structure
- Before making major changes
- Onboarding team members

**Basic syntax**:
```bash
/sc:load                           # Load current project context
/sc:load src/                      # Load specific directory context
/sc:load --deep                    # Deep analysis of project structure
```

**Useful flags**:
- `--deep` - Comprehensive project analysis
- `--focus <area>` - Focus on specific project area
- `--summary` - Generate project summary

**Real examples**:
```bash
/sc:load --deep --summary
/sc:load src/components/ --focus architecture
/sc:load . --focus dependencies
```

**Gotchas**:
- Can take time on large projects
- More useful at project start than during development
- Helps with onboarding but not a replacement for good docs

## Command Tips & Patterns ğŸ’¡

### Effective Flag Combinations
```bash
# Safe improvement workflow
/sc:improve --preview src/component.js    # See what would change
/sc:improve --safe src/component.js       # Apply safe changes only

# Comprehensive analysis
/sc:analyze --focus security --depth deep
/sc:test --coverage
/sc:document --type api

# Smart git workflow
/sc:git add .
/sc:git --smart-commit --branch-strategy

# Project understanding workflow
/sc:load --deep --summary
/sc:analyze --focus architecture
/sc:document --type guide
```

### Common Workflows

**New Project Onboarding**:
```bash
/sc:load --deep --summary
/sc:analyze --focus architecture
/sc:test --coverage
/sc:document README
```

**Bug Investigation**:
```bash
/sc:troubleshoot "specific error message" --logs
/sc:analyze --focus security
/sc:test --type unit affected-component
```

**Code Quality Improvement**:
```bash
/sc:analyze --focus quality
/sc:improve --preview src/
/sc:cleanup --safe
/sc:test --coverage
```

**Pre-deployment Checklist**:
```bash
/sc:test --type all --coverage
/sc:analyze --focus security
/sc:build --type prod --optimize
/sc:git --smart-commit
```

### Troubleshooting Command Issues

**Command not working as expected?**
- Try adding `--help` to see all options
- Use `--preview` or `--safe` flags when available
- Start with smaller scope (single file vs. entire project)

**Analysis taking too long?**
- Use `--focus` to narrow scope
- Try `--depth quick` instead of deep analysis
- Analyze smaller directories first

**Build/test commands failing?**
- Make sure your tools are in PATH
- Check that config files are in expected locations
- Try running the underlying commands directly first

**Not sure which command to use?**
- Use `/index` to browse available commands
- Look at the Quick Reference table above
- Try the most specific command first, then broader ones

---

## Final Notes ğŸ“

**The real truth about these commands** ğŸ’¯:
- **Just try them** - You don't need to study this guide first
- **Start with the basics** - `/analyze`, `/build`, `/improve` cover most needs
- **Let auto-activation work** - SuperClaude usually picks helpful experts
- **Experiment freely** - Use `--preview` if you want to see what would happen first

**Still rough around the edges:**
- Complex orchestration (spawn, task) can be a bit flaky
- Some analysis depends heavily on your project setup  
- Error handling could be better in some commands

**Getting better all the time:**
- We actively improve commands based on user feedback
- Newer commands (analyze, improve) tend to work better
- Auto-activation keeps getting smarter

**Don't stress about memorizing this** ğŸ§˜â€â™‚ï¸
- SuperClaude is designed to be discoverable through use
- Type `/` to see available commands
- Commands suggest what they can do when you use `--help`
- The intelligent routing handles most of the complexity

**Need help?** Check the GitHub issues or create a new one if you're stuck! ğŸš€

---

*Happy coding! Just remember - you can skip most of this guide and learn by doing. ğŸ¯*


================================================
FILE: Docs/flags-guide.md
================================================
# SuperClaude Flags User Guide ğŸ

## ğŸ¤– Most Flags Activate Automatically - Don't Stress About It!

**The honest truth**: You don't need to memorize these flags. SuperClaude usually tries to add helpful ones based on what you're doing! 

**Here's what actually happens:**
- You type `/analyze auth.js` 
- SuperClaude detects it's security-related code
- **Usually adds** `--persona-security`, `--focus security`, `--validate`
- You often get expert security analysis without managing any flags

**When might you manually use flags?**
- You want to **override** what SuperClaude picked (rare)
- You're **curious** about specific aspects (`--focus performance`)
- You want to **experiment** with different approaches

**Bottom line**: Just use basic commands and let the auto-activation work. These flags are here when you want them, not because you need them. ğŸ¯

---

## ğŸš€ Just Try These (No Flag Knowledge Required)

```bash
# These work great with zero flag knowledge:
/sc:analyze src/                    # Auto-picks the right analysis flags
/sc:build                          # Auto-optimizes based on your project  
/sc:improve messy-code.js          # Auto-activates quality and safety flags
/sc:troubleshoot "weird error"     # Auto-activates debugging and analysis flags
```

**See? No flags needed.** Everything below is for when you get curious about what's happening behind the scenes.

---

A practical guide to SuperClaude's flag system. Flags are like command-line options that change how SuperClaude behaves - think of them as superpowers for your commands.

## What Are Flags? ğŸ¤”

**Flags are modifiers** that change how SuperClaude processes your requests. They come after commands and start with `--`.

**Basic syntax** (but you usually don't need to know this):
```bash
/sc:command --flag-name
/sc:command --flag-name value  
/sc:analyze src/ --focus security --depth deep
```

**How flags actually work in practice**:
1. **Auto-activation** - SuperClaude adds them based on context (this is the main way! ğŸ¯)
2. **Manual override** - You can add them explicitly if you want different behavior

**Why flags exist** (mostly automatic benefits):
- Get better, more focused results
- Auto-enable the right thinking depth
- Connect to special capabilities when useful
- Optimize for speed or detail based on your task
- Direct attention to what you're actually working on

**The key point**: SuperClaude handles flag selection intelligently so you don't have to think about it! ğŸ§ 

## Flag Categories ğŸ“‚

### Planning & Analysis Flags ğŸ§ 

These control how deeply SuperClaude thinks about your request.

#### `--plan`
**What it does**: Shows execution plan before doing anything  
**When to use**: When you want to see what SuperClaude will do first  
**Example**: `/build --plan` - See build steps before running

#### `--think`
**What it does**: Multi-file analysis (~4K tokens)  
**When to use**: Complex problems involving several files  
**Auto-activates**: Import chains >5 files, cross-module calls >10 references  
**Example**: `/analyze complex-system/ --think`

#### `--think-hard` 
**What it does**: Deep architectural analysis (~10K tokens)  
**When to use**: System-wide problems, architectural decisions  
**Auto-activates**: System refactoring, bottlenecks >3 modules  
**Example**: `/improve legacy-system/ --think-hard`

#### `--ultrathink`
**What it does**: Maximum depth analysis (~32K tokens)  
**When to use**: Critical system redesign, complex debugging  
**Auto-activates**: Legacy modernization, critical vulnerabilities  
**Example**: `/troubleshoot "entire auth system broken" --ultrathink`

**ğŸ’¡ Tip**: Start with `--think`, only go deeper if needed. More thinking = slower but more thorough.

---

### Efficiency & Control Flags âš¡

Control output style, safety, and performance.

#### `--uc` / `--ultracompressed`
**What it does**: 60-80% token reduction using symbols  
**When to use**: Large operations, when context is getting full  
**Auto-activates**: Context usage >75%, large-scale operations  
**Example**: `/analyze huge-codebase/ --uc`

#### `--safe-mode`
**What it does**: Maximum validation, conservative execution  
**When to use**: Production environments, risky operations  
**Auto-activates**: Resource usage >85%, production environment  
**Example**: `/improve production-code/ --safe-mode`

#### `--validate`
**What it does**: Pre-operation validation and risk assessment  
**When to use**: Want to check before making changes  
**Auto-activates**: Risk score >0.7  
**Example**: `/cleanup legacy/ --validate`

#### `--verbose`
**What it does**: Maximum detail and explanation  
**When to use**: Learning, debugging, need full context  
**Example**: `/build --verbose` - See every build step

#### `--answer-only`
**What it does**: Direct response without task creation  
**When to use**: Quick questions, don't want workflow automation  
**Example**: `/explain React hooks --answer-only`

**ğŸ’¡ Tip**: `--uc` is great for big operations. `--safe-mode` for anything important. `--verbose` when you're learning.

---

### MCP Server Flags ğŸ”§

Enable specialized capabilities through MCP servers.

#### `--c7` / `--context7`
**What it does**: Enables Context7 for official library documentation  
**When to use**: Working with frameworks, need official docs  
**Auto-activates**: External library imports, framework questions  
**Example**: `/build react-app/ --c7` - Get React best practices

#### `--seq` / `--sequential`
**What it does**: Enables Sequential for complex multi-step analysis  
**When to use**: Complex debugging, system design  
**Auto-activates**: Complex debugging, `--think` flags  
**Example**: `/troubleshoot "auth flow broken" --seq`

#### `--magic`
**What it does**: Enables Magic for UI component generation  
**When to use**: Creating UI components, design systems  
**Auto-activates**: UI component requests, frontend persona  
**Example**: `/build dashboard --magic` - Get modern UI components

#### `--play` / `--playwright`
**What it does**: Enables Playwright for browser automation and testing  
**When to use**: E2E testing, performance monitoring  
**Auto-activates**: Test workflows, QA persona  
**Example**: `/test e2e --play`

#### `--all-mcp`
**What it does**: Enables all MCP servers simultaneously  
**When to use**: Complex multi-domain problems  
**Auto-activates**: Problem complexity >0.8, multi-domain indicators  
**Example**: `/analyze entire-app/ --all-mcp`

#### `--no-mcp`
**What it does**: Disables all MCP servers, native tools only  
**When to use**: Faster execution, don't need specialized features  
**Example**: `/analyze simple-script.js --no-mcp`

**ğŸ’¡ Tip**: MCP servers add capabilities but use more tokens. `--c7` for docs, `--seq` for thinking, `--magic` for UI.

---

### Advanced Orchestration Flags ğŸ­

For complex operations and workflows.

#### `--delegate [files|folders|auto]`
**What it does**: Enables sub-agent delegation for parallel processing  
**When to use**: Large codebases, complex analysis  
**Auto-activates**: >7 directories or >50 files  
**Options**:
- `files` - Delegate individual file analysis
- `folders` - Delegate directory-level analysis  
- `auto` - Smart delegation strategy

**Example**: `/analyze monorepo/ --delegate auto`

#### `--wave-mode [auto|force|off]`
**What it does**: Multi-stage execution with compound intelligence  
**When to use**: Complex improvements, systematic analysis  
**Auto-activates**: Complexity >0.8 AND files >20 AND operation types >2  
**Example**: `/improve legacy-system/ --wave-mode force`

#### `--loop`
**What it does**: Iterative improvement mode  
**When to use**: Quality improvement, refinement operations  
**Auto-activates**: Polish, refine, enhance keywords  
**Example**: `/improve messy-code.js --loop`

#### `--concurrency [n]`
**What it does**: Control max concurrent sub-agents (1-15)  
**When to use**: Controlling resource usage  
**Example**: `/analyze --delegate auto --concurrency 3`

**ğŸ’¡ Tip**: These are powerful but complex. Start with `--delegate auto` for big projects, `--loop` for improvements.

---

### Focus & Scope Flags ğŸ¯

Direct SuperClaude's attention to specific areas.

#### `--scope [level]`
**Options**: file, module, project, system  
**What it does**: Sets analysis scope  
**Example**: `/analyze --scope module auth/`

#### `--focus [domain]`
**Options**: performance, security, quality, architecture, accessibility, testing  
**What it does**: Focuses analysis on specific domain  
**Example**: `/analyze --focus security --scope project`

#### Persona Flags
**Available personas**: architect, frontend, backend, analyzer, security, mentor, refactorer, performance, qa, devops, scribe  
**What they do**: Activates specialist behavior patterns  
**Example**: `/analyze --persona-security` - Security-focused analysis

**ğŸ’¡ Tip**: `--focus` is great for targeted analysis. Personas auto-activate but manual control helps.

---

## Common Flag Patterns ğŸ”„

### Quick Analysis
```bash
/sc:analyze src/ --focus quality          # Quick quality check
/sc:analyze --uc --focus security         # Fast security scan
```

### Deep Investigation  
```bash
/sc:troubleshoot "bug" --think --seq      # Systematic debugging
/sc:analyze --think-hard --focus architecture  # Architectural analysis
```

### Large Project Work
```bash
/sc:analyze monorepo/ --delegate auto --uc     # Efficient large analysis
/sc:improve legacy/ --wave-mode auto --safe-mode  # Safe systematic improvement
```

### Learning & Documentation
```bash
/sc:explain React hooks --c7 --verbose    # Detailed explanation with docs
/sc:document api/ --persona-scribe        # Professional documentation
```

### Performance-Focused
```bash
/sc:analyze --focus performance --play     # Performance analysis with testing
/sc:build --uc --no-mcp                   # Fast build without extra features
```

### Security-Focused
```bash
/sc:analyze --focus security --think --validate  # Thorough security analysis
/sc:scan --persona-security --safe-mode         # Conservative security scan
```

## Practical Examples ğŸ’¡

### Before/After: Basic Analysis
**Before** (basic):
```bash
/sc:analyze auth.js
# â†’ Simple file analysis
```

**After** (with flags):
```bash
/sc:analyze auth.js --focus security --think --c7
# â†’ Security-focused analysis with deep thinking and official docs
# â†’ Much more thorough, finds security patterns, checks against best practices
```

### Before/After: Large Project
**Before** (slow):
```bash
/sc:analyze huge-monorepo/
# â†’ Tries to analyze everything at once, may timeout or use too many tokens
```

**After** (efficient):
```bash
/sc:analyze huge-monorepo/ --delegate auto --uc --focus architecture
# â†’ Delegates work to sub-agents, compresses output, focuses on architecture
# â†’ Faster, more focused, better results
```

### Before/After: Improvement Work
**Before** (risky):
```bash
/sc:improve legacy-system/
# â†’ May make too many changes, could break things
```

**After** (safe):
```bash
/sc:improve legacy-system/ --safe-mode --loop --validate --preview
# â†’ Safe changes only, iterative approach, validates first, shows preview
# â†’ Much safer, progressive improvement
```

## Auto-Activation Examples ğŸ¤–

SuperClaude usually adds flags based on context. Here's when it tries:

### Complexity-Based
```bash
/sc:analyze huge-codebase/
# Auto-adds: --delegate auto --uc
# Why: >50 files detected, context management needed

/sc:troubleshoot "complex system issue"  
# Auto-adds: --think --seq
# Why: Multi-component problem detected
```

### Domain-Based
```bash
/sc:build react-app/
# Auto-adds: --c7 --persona-frontend
# Why: Frontend framework detected

/sc:analyze --focus security
# Auto-adds: --persona-security --validate
# Why: Security focus triggers security specialist
```

### Performance-Based
```bash
# When context usage >75%
/sc:analyze large-project/
# Auto-adds: --uc
# Why: Token optimization needed

# When risk score >0.7
/sc:improve production-code/
# Auto-adds: --safe-mode --validate
# Why: High-risk operation detected
```

## Advanced Usage ğŸš€

### Complex Flag Combinations

**Comprehensive Code Review**:
```bash
/sc:review codebase/ --persona-qa --think-hard --focus quality --validate --c7
# â†’ QA specialist + deep thinking + quality focus + validation + docs
```

**Legacy System Modernization**:
```bash
/sc:improve legacy/ --wave-mode force --persona-architect --safe-mode --loop --c7
# â†’ Wave orchestration + architect perspective + safety + iteration + docs
```

**Security Audit**:
```bash
/sc:scan --persona-security --ultrathink --focus security --validate --seq
# â†’ Security specialist + maximum thinking + security focus + validation + systematic analysis
```

### Performance Optimization

**For Speed**:
```bash
/sc:analyze --no-mcp --uc --scope file
# â†’ Disable extra features, compress output, limit scope
```

**For Thoroughness**:
```bash
/sc:analyze --all-mcp --think-hard --delegate auto
# â†’ All capabilities, deep thinking, parallel processing
```

### Custom Workflows

**Bug Investigation Workflow**:
```bash
/sc:troubleshoot "specific error" --seq --think --validate
/sc:analyze affected-files/ --focus quality --persona-analyzer  
/sc:test --play --coverage
```

**Feature Development Workflow**:
```bash
/sc:design new-feature --persona-architect --c7
/sc:build --magic --persona-frontend --validate
/sc:test --play --coverage
/sc:document --persona-scribe --c7
```

## Quick Reference ğŸ“‹

### Most Useful Flags
| Flag | Purpose | When to Use |
|------|---------|-------------|
| `--think` | Deeper analysis | Complex problems |
| `--uc` | Compress output | Large operations |
| `--safe-mode` | Conservative execution | Important code |
| `--c7` | Official docs | Framework work |
| `--seq` | Systematic analysis | Debugging |
| `--focus security` | Security focus | Security concerns |
| `--delegate auto` | Parallel processing | Large codebases |
| `--validate` | Check before action | Risky operations |

### Flag Combinations That Work Well
```bash
# Safe improvement
--safe-mode --validate --preview

# Deep analysis  
--think --seq --c7

# Large project
--delegate auto --uc --focus

# Learning
--verbose --c7 --persona-mentor

# Security work
--persona-security --focus security --validate

# Performance work
--persona-performance --focus performance --play
```

### Auto-Activation Triggers
- **--think**: Complex imports, cross-module calls
- **--uc**: Context >75%, large operations  
- **--safe-mode**: Resource usage >85%, production
- **--delegate**: >7 directories or >50 files
- **--c7**: Framework imports, documentation requests
- **--seq**: Debugging keywords, --think flags
- **Personas**: Domain-specific keywords and patterns

## Troubleshooting Flag Issues ğŸš¨

### Common Problems

**"Flags don't seem to work"**
- Check spelling (common typos: `--ultracompresed`, `--persona-fronted`)
- Some flags need values: `--scope project`, `--focus security`
- Flag conflicts: `--no-mcp` overrides `--c7`, `--seq`, etc.

**"Operation too slow"**
- Try `--uc` for compression
- Use `--no-mcp` to disable extra features
- Limit scope: `--scope file` instead of `--scope project`

**"Too much output"**
- Add `--uc` for compression
- Remove `--verbose` if present
- Use `--answer-only` for simple questions

**"Not thorough enough"**
- Add `--think` or `--think-hard`
- Enable relevant MCP servers: `--seq`, `--c7`
- Use appropriate persona: `--persona-analyzer`

**"Changes too risky"**
- Always use `--safe-mode` for important code
- Add `--validate` to check first
- Use `--preview` to see changes before applying

### Flag Conflicts

**These override others**:
- `--no-mcp` overrides all MCP flags (`--c7`, `--seq`, etc.)
- `--safe-mode` overrides optimization flags
- Last persona flag wins: `--persona-frontend --persona-backend` â†’ backend

**Precedence order**:
1. Safety flags (`--safe-mode`) beat optimization
2. Explicit flags beat auto-activation
3. Thinking depth: `--ultrathink` > `--think-hard` > `--think`
4. Scope: system > project > module > file

## Tips for Effective Flag Usage ğŸ’¡

### Starting Out (The Honest Truth)
1. **Just ignore flags at first** - Auto-activation handles most cases pretty well
2. **Watch what gets auto-activated** - You'll learn by seeing what SuperClaude picks
3. **Use `--help` when curious** - Many commands show what flags are available
4. **Trust the automation** - SuperClaude usually picks reasonable defaults

### Getting Advanced (If You Want To)
1. **Experiment with overrides** - Try `--persona-security` on non-security code for different perspectives
2. **Learn the useful combos** - `--safe-mode --validate` for important stuff
3. **Understand the performance trade-offs** - Fast (`--uc --no-mcp`) vs thorough (`--think-hard --all-mcp`)
4. **Use flags for learning** - `--verbose` when you want to understand what's happening

### Performance Tips (For Power Users)
- **For speed**: `--uc --no-mcp --scope file`
- **For thoroughness**: `--think-hard --all-mcp --delegate auto`
- **For safety**: `--safe-mode --validate --preview`
- **For learning**: `--verbose --c7 --persona-mentor`

---

## Final Notes ğŸ“

**The real truth about flags** ğŸ’¯:
- **Auto-activation usually works pretty well** compared to manual flag selection
- **You can ignore most of this guide** and just use basic commands
- **Flags are here when you want them** - not because you need them
- **Learning happens naturally** through use, not through studying guides ğŸ˜Š

**Don't feel overwhelmed** ğŸ§˜â€â™‚ï¸:
- SuperClaude tries to work well without flag knowledge
- The detailed info above is for curiosity, not necessity
- Auto-activation keeps getting smarter based on usage patterns
- You're not missing out by not memorizing flags

**When you actually need flags**:
- Overriding auto-activation (rare)
- Experimenting with different approaches (fun)
- Optimizing for specific performance needs (advanced)
- Learning about what happened (educational)

**Start simple, stay simple** ğŸ¯:
- Use basic commands: `/analyze`, `/build`, `/improve`
- Let auto-activation handle the complexity
- Add manual flags only when you want to experiment
- Trust that SuperClaude knows what it's doing

---

*Remember: Behind all this apparent complexity, SuperClaude is actually simple to use. Just start typing commands! ğŸš€*


================================================
FILE: Docs/installation-guide.md
================================================
# SuperClaude Installation Guide ğŸ“¦

## ğŸ¯ It's Easier Than It Looks!

**The honest truth**: This guide looks long because we want to cover all the details, but installation is actually pretty simple. Most people are done in 2 minutes with one command! 

### Step 1: Install the Package

**Option A: From PyPI (Recommended)**
```bash
uv add SuperClaude
```

**Option B: From Source**
```bash
git clone https://github.com/NomenAK/SuperClaude.git
cd SuperClaude
uv sync
```
### ğŸ”§ UV / UVX Setup Guide

SuperClaude v3 also supports installation via [`uv`](https://github.com/astral-sh/uv) (a faster, modern Python package manager) or `uvx` for cross-platform usage.

### ğŸŒ€ Install with `uv`

Make sure `uv` is installed:

```bash
curl -Ls https://astral.sh/uv/install.sh | sh
```

> Or follow instructions from: [https://github.com/astral-sh/uv](https://github.com/astral-sh/uv)

Once `uv` is available, you can install SuperClaude like this:

```bash
uv venv
source .venv/bin/activate
uv pip install SuperClaude
```

### âš¡ Install with `uvx` (Cross-platform CLI)

If youâ€™re using `uvx`, just run:

```bash
uvx pip install SuperClaude
```
## ğŸ”§ UV / UVX Setup Guide

SuperClaude v3 also supports installation via [`uv`](https://github.com/astral-sh/uv) (a faster, modern Python package manager) or `uvx` for cross-platform usage.

### ğŸŒ€ Install with `uv`

Make sure `uv` is installed:

```bash
curl -Ls https://astral.sh/uv/install.sh | sh
```

> Or follow instructions from: [https://github.com/astral-sh/uv](https://github.com/astral-sh/uv)

Once `uv` is available, you can install SuperClaude like this:

```bash
uv venv
source .venv/bin/activate
uv pip install SuperClaude
```

### âš¡ Install with `uvx` (Cross-platform CLI)

If youâ€™re using `uvx`, just run:

```bash
uvx pip install SuperClaude
```

### âœ… Finish Installation

After installing, continue with the usual installer step:

```bash
python3 -m SuperClaude install
```

Or using bash-style CLI:

```bash
SuperClaude install
```

### ğŸ§  Note:

* `uv` provides better caching and performance.
* Compatible with Python 3.8+ and works smoothly with SuperClaude.

---

### âš ï¸ Important Note 
**After installing the SuperClaude.**
**You can use `SuperClaude commands`
, `python3 -m SuperClaude commands` or also `python3 SuperClaude commands`**

**What just happened?** SuperClaude tried to set up everything you need. Usually no complex configuration, dependency hunting, or setup headaches! ğŸ‰

---

A comprehensive guide to installing SuperClaude v3. But remember - most people never need to read past the quick start above! ğŸ˜Š

## Before You Start ğŸ”

### What You Need ğŸ’»

SuperClaude works on **Windows**, **macOS**, and **Linux**. Here's what you need:

**Required:**
- **Python 3.8 or newer** - The framework is written in Python
- **Claude CLI** - SuperClaude enhances Claude Code, so you need it installed first

**Optional (but recommended):**
- **Node.js 16+** - Only needed if you want MCP server integration
- **Git** - Helpful for development workflows

### Quick Check ğŸ”

Before installing, let's make sure you have the basics:

```bash
# Check Python version (should be 3.8+)
python3 --version

# Check if Claude CLI is installed
claude --version

# Check Node.js (optional, for MCP servers)
node --version
```

If any of these fail, see the [Prerequisites Setup](#prerequisites-setup-ğŸ› ï¸) section below.

## Quick Start ğŸš€

**ğŸ† The "Just Get It Working" Approach (Recommended for 90% of Users)**
**Option A: From PyPI (Recommended)**
```bash
pip install SuperClaude

# Install with recommended settings  
SuperClaude install --quick

# That's it! ğŸ‰
```
**Option B: From Source**
```bash
# Clone the repo
git clone <repository-url>
cd SuperClaude
pip install .

# Install with recommended settings  
SuperClaude install --quick

# That's it! ğŸ‰
```
**âš ï¸ Important Note**
**After installing the SuperClaude.**
**You can use `SuperClaude commands`
, `python3 -m SuperClaude commands` or also `python3 SuperClaude commands`**

**What you just got:**
- âœ… All 16 smart commands that auto-activate experts
- âœ… 11 specialist personas that know when to help
- âœ… Intelligent routing that figures out complexity for you
- âœ… About 2 minutes of your time and ~50MB disk space

**Seriously, you're done.** Open Claude Code, type `/help`, and watch SuperClaude work its magic.

**Nervous about what it will do?** See first with:
```bash
SuperClaude install --quick --dry-run
```

## Installation Options ğŸ¯

We have three installation profiles to choose from:

### ğŸ¯ Minimal Installation
```bash
SuperClaude install --minimal
```
- **What**: Just the core framework files
- **Time**: ~1 minute
- **Space**: ~20MB  
- **Good for**: Testing, basic enhancement, minimal setups
- **Includes**: Core behavior documentation that guides Claude

### ğŸš€ Quick Installation (Recommended)
```bash
SuperClaude install --quick
```
- **What**: Core framework + 16 slash commands
- **Time**: ~2 minutes
- **Space**: ~50MB
- **Good for**: Most users, general development
- **Includes**: Everything in minimal + specialized commands like `/analyze`, `/build`, `/improve`

### ğŸ”§ Developer Installation  
```bash
SuperClaude install --profile developer
```
- **What**: Everything including MCP server integration
- **Time**: ~5 minutes
- **Space**: ~100MB
- **Good for**: Power users, contributors, advanced workflows
- **Includes**: Everything + Context7, Sequential, Magic, Playwright servers

### ğŸ›ï¸ Interactive Installation
```bash
SuperClaude install
```
- Lets you pick and choose components
- Shows detailed descriptions of what each component does
- Good if you want control over what gets installed

## Step-by-Step Installation ğŸ“‹

### Prerequisites Setup ğŸ› ï¸

**Missing Python?**
```bash
# Linux (Ubuntu/Debian)
sudo apt update && sudo apt install python3 python3-pip

# macOS  
brew install python3

# Windows
# Download from https://python.org/downloads/
#or open command prompt or powershell
winget install python
```

**Missing Claude CLI?**
- Visit https://claude.ai/code for installation instructions
- SuperClaude enhances Claude Code, so you need it first

**Missing Node.js? (Optional)**
```bash
# Linux (Ubuntu/Debian)
sudo apt update && sudo apt install nodejs npm

# macOS
brew install node

# Windows  
# Download from https://nodejs.org/
#or open command prompt or powershell
winget install nodejs
```

### Getting SuperClaude ğŸ“¥

**Option 1: From PyPI (Recommended)**
```bash
pip install SuperClaude
```

**Option 2: Download the latest release**
```bash
# Download and extract the latest release
# (Replace URL with actual release URL)
curl -L <release-url> -o superclaude-v3.zip
unzip superclaude-v3.zip
cd superclaude-v3
pip install .
```

**Option 3: Clone from Git**
```bash
git clone <repository-url>
cd SuperClaude
pip install .
```

### Running the Installer ğŸ¬

The installer is pretty smart and will guide you through the process:

```bash
# See all available options
SuperClaude install --help

# Quick installation (recommended)
SuperClaude install --quick

# Want to see what would happen first?
SuperClaude install --quick --dry-run

# Install everything
SuperClaude install --profile developer

# Quiet installation (minimal output)
SuperClaude install --quick --quiet

# Force installation (skip confirmations)
python3 SuperClaude.py install --quick --force
```

### During Installation ğŸ“±

Here's what happens when you install:

1. **System Check** - Verifies you have required dependencies
2. **Directory Setup** - Creates `~/.claude/` directory structure
3. **Core Files** - Copies framework documentation files
4. **Commands** - Installs slash command definitions (if selected)
5. **MCP Servers** - Downloads and configures MCP servers (if selected)
6. **Configuration** - Sets up `settings.json` with your preferences
7. **Validation** - Tests that everything works

The installer shows progress and will tell you if anything goes wrong.

## After Installation âœ…

### Quick Test ğŸ§ª

Let's make sure everything worked:

```bash
# Check if files were installed
ls ~/.claude/

# Should show: CLAUDE.md, COMMANDS.md, settings.json, etc.
```

**Test with Claude Code:**
1. Open Claude Code
2. Try typing `/help` - you should see SuperClaude commands
3. Try `/analyze --help` - should show command options

### What Got Installed ğŸ“‚

SuperClaude installs to `~/.claude/` by default. Here's what you'll find:

```
~/.claude/
â”œâ”€â”€ CLAUDE.md              # Main framework entry point
â”œâ”€â”€ COMMANDS.md             # Available slash commands  
â”œâ”€â”€ FLAGS.md                # Command flags and options
â”œâ”€â”€ PERSONAS.md             # Smart persona system
â”œâ”€â”€ PRINCIPLES.md           # Development principles
â”œâ”€â”€ RULES.md                # Operational rules
â”œâ”€â”€ MCP.md                  # MCP server integration
â”œâ”€â”€ MODES.md                # Operational modes
â”œâ”€â”€ ORCHESTRATOR.md         # Intelligent routing
â”œâ”€â”€ settings.json           # Configuration file
â””â”€â”€ commands/               # Individual command definitions
    â”œâ”€â”€ analyze.md
    â”œâ”€â”€ build.md
    â”œâ”€â”€ improve.md
    â””â”€â”€ ... (13 more)
```

**What each file does:**
- **CLAUDE.md** - Tells Claude Code about SuperClaude and loads other files
- **settings.json** - Configuration (MCP servers, hooks, etc.)
- **commands/** - Detailed definitions for each slash command

### First Steps ğŸ¯

Try these commands to get started:

```bash
# In Claude Code, try these:
/sc:help                    # See available commands
/sc:analyze README.md       # Analyze a file
/sc:build --help           # See build options
/sc:improve --help         # See improvement options
```

**Don't worry if it seems overwhelming** - SuperClaude enhances Claude Code gradually. You can use as much or as little as you want.

## Managing Your Installation ğŸ› ï¸

### Updates ğŸ“…

Keep SuperClaude up to date:

```bash
# Check for updates
SuperClaude update

# Force update (overwrite local changes)
SuperClaude update --force

# Update specific components only
SuperClaude update --components core,commands

# See what would be updated
SuperClaude update --dry-run
```

**When to update:**
- When new SuperClaude versions are released
- If you're having issues (updates often include fixes)
- When new MCP servers become available

### Backups ğŸ’¾

Create backups before major changes:

```bash
# Create a backup
SuperClaude backup --create

# List existing backups  
SuperClaude backup --list

# Restore from backup
SuperClaude backup --restore

# Create backup with custom name
SuperClaude backup --create --name "before-update"
```

**When to backup:**
- Before updating SuperClaude
- Before experimenting with settings
- Before uninstalling
- Periodically if you've customized heavily

### Uninstallation ğŸ—‘ï¸

If you need to remove SuperClaude:

```bash
# Remove SuperClaude (keeps backups)
SuperClaude uninstall

# Complete removal (removes everything)
SuperClaude uninstall --complete

# See what would be removed
SuperClaude uninstall --dry-run
```

**What gets removed:**
- All files in `~/.claude/` 
- MCP server configurations
- SuperClaude settings from Claude Code

**What stays:**
- Your backups (unless you use `--complete`)
- Claude Code itself (SuperClaude doesn't touch it)
- Your projects and other files

## Troubleshooting ğŸ”§

### Common Issues ğŸš¨

**"Python not found"**
```bash
# Try python instead of python3
python --version

# Or check if it's installed but not in PATH
which python3
```

**"Claude CLI not found"**
- Make sure Claude Code is installed first
- Try `claude --version` to verify
- Visit https://claude.ai/code for installation help

**"Permission denied"**
```bash
# Try with explicit Python path
/usr/bin/python3 SuperClaude.py install --quick

# Or check if you need different permissions
ls -la ~/.claude/
```

**"MCP servers won't install"**
- Check that Node.js is installed: `node --version`
- Check that npm is available: `npm --version`  
- Try installing without MCP first: `--minimal` or `--quick`

**"Installation fails partway through"**
```bash
# Try with verbose output to see what's happening
SuperClaude install --quick --verbose

# Or try a dry run first
SuperClaude install --quick --dry-run
```

### Platform-Specific Issues ğŸ–¥ï¸

**Windows:**
- Use `python` instead of `python3` if you get "command not found"
- Run Command Prompt as Administrator if you get permission errors
- Make sure Python is in your PATH

**macOS:**  
- You might need to approve SuperClaude in Security & Privacy settings
- Use `brew install python3` if you don't have Python 3.8+
- Try using `python3` explicitly instead of `python`

**Linux:**
- Make sure you have `python3-pip` installed
- You might need `sudo` for some package installations
- Check that `~/.local/bin` is in your PATH

### Still Having Issues? ğŸ¤”

**Check our troubleshooting resources:**
- GitHub Issues: https://github.com/NomenAK/SuperClaude/issues
- Look for existing issues similar to yours
- Create a new issue if you can't find a solution

**When reporting bugs, please include:**
- Your operating system and version
- Python version (`python3 --version`)
- Claude CLI version (`claude --version`)
- The exact command you ran
- The complete error message
- What you expected to happen

**Getting Help:**
- GitHub Discussions for general questions
- Check the README.md for latest updates
- Look at the ROADMAP.md to see if your issue is known

## Advanced Options âš™ï¸

### Custom Installation Directory

```bash
# Install to custom location
SuperClaude install --quick --install-dir /custom/path

# Use environment variable
export SUPERCLAUDE_DIR=/custom/path
SuperClaude install --quick
```

### Component Selection

```bash
# See available components
SuperClaude install --list-components

# Install specific components only
SuperClaude install --components core,commands

# Skip certain components
SuperClaude install --quick --skip mcp
```

### Development Setup

If you're planning to contribute or modify SuperClaude:

```bash
# Developer installation with all components
SuperClaude install --profile developer

# Install in development mode (symlinks instead of copies)
SuperClaude install --profile developer --dev-mode

# Install with git hooks for development
SuperClaude install --profile developer --dev-hooks
```

## What's Next? ğŸš€

**Now that SuperClaude is installed (that was easy, right?):**

1. **Just start using it** - Try `/analyze some-file.js` or `/build` and see what happens âœ¨
2. **Don't stress about learning** - SuperClaude usually figures out what you need
3. **Experiment freely** - Commands like `/improve` and `/troubleshoot` are pretty forgiving
4. **Read guides if curious** - Check `Docs/` when you want to understand what just happened
5. **Give feedback** - Let us know what works and what doesn't

**The real secret**: SuperClaude is designed to enhance your existing workflow without you having to learn a bunch of new stuff. Just use it like you'd use regular Claude Code, but notice how much smarter it gets! ğŸ¯

**Still feeling uncertain?** Start with just `/help` and `/analyze README.md` - you'll see how non-intimidating it actually is.

---

## Final Notes ğŸ“

- **Installation takes 1-5 minutes** depending on what you choose
- **Disk space needed: 20-100MB** (not much!)
- **Works alongside existing tools** - doesn't interfere with your setup
- **Easy to uninstall** if you change your mind
- **Community supported** - we actually read and respond to issues
- ### âš ï¸ Important Note 
**After installing the SuperClaude.**
**You can use `SuperClaude commands`
, `python3 -m SuperClaude commands` or also `python3 SuperClaude commands`**

Thanks for trying SuperClaude! We hope it makes your development workflow a bit smoother. ğŸ™‚

---

*Last updated: July 2024 - Let us know if anything in this guide is wrong or confusing!*



================================================
FILE: Docs/personas-guide.md
================================================
# SuperClaude Personas User Guide ğŸ­

## ğŸ­ Personas Auto-Activate - No Need to Choose!

**The simple truth**: You don't need to pick personas or memorize what they do. SuperClaude usually tries to bring in helpful experts for each situation! 

**Here's what actually happens:**
- You type `/analyze auth.js` â†’ Security expert usually jumps in ğŸ›¡ï¸
- You work on React components â†’ Frontend specialist often takes over ğŸ¨  
- You debug performance issues â†’ Performance optimizer often helps âš¡
- You write documentation â†’ Professional writer usually helps out âœï¸

**It's like having a smart team** that knows when to jump in and help, without you managing who does what. 

**Manual control available** when you want it (like asking specifically for a security review of frontend code), but most of the time you can just... let it work. ğŸª„

---

## ğŸš€ Just Try These (No Persona Knowledge Required)

```bash
# These automatically activate the right experts:
/sc:analyze payment-system/         # â†’ Security + backend experts auto-activate
/sc:build react-app/               # â†’ Frontend specialist takes over  
/sc:improve slow-queries.sql       # â†’ Performance optimizer jumps in
/sc:troubleshoot "auth failing"    # â†’ Debug specialist + security expert coordinate
```

**See the pattern?** You focus on what you want to do, SuperClaude figures out who should help. Everything below is for when you get curious about who's on the team.

---

Think of SuperClaude personas as having a team of specialists on demand. Each persona brings different expertise, priorities, and perspectives to help you with specific types of work.

## What Are Personas? ğŸ¤”

**Personas are AI specialists** that try to adapt SuperClaude's behavior for different types of work. Instead of generic responses, you often get expert-level help from relevant specialists.

**How they actually work in practice:**
- **Auto-activation** - SuperClaude usually tries to pick helpful experts (most of the time this works pretty well!)
- **Smart detection** - Recognizes security work, frontend tasks, performance issues, etc.
- **Seamless switching** - Different experts jump in as needed within the same conversation
- **Team coordination** - Multiple experts often coordinate on complex tasks
- **Manual override available** - You can explicitly choose with `--persona-name` flags when you want a different perspective

**Why this matters:**
- Often get expert-level advice without knowing which expert to ask
- Usually get better decision-making aligned with what you're actually working on
- More focused and relevant responses based on the task
- Access to specialized workflows that activate when useful

**The neat part**: You just work on your stuff, and helpful experts usually show up when needed. ğŸ¯

## The SuperClaude Team ğŸ‘¥

### Technical Specialists ğŸ”§

#### ğŸ—ï¸ `architect` - Systems Design Specialist
**What they do**: Long-term architecture planning, system design, scalability decisions

**Priority**: Long-term maintainability > scalability > performance > quick fixes

**When they auto-activate**:
- Keywords: "architecture", "design", "scalability", "system structure"
- Complex system modifications involving multiple modules
- Planning large features or system changes

**Great for**:
- Planning new systems or major features
- Architectural reviews and improvements
- Technical debt assessment
- Design pattern recommendations
- Scalability planning

**Example workflows**:
```bash
/sc:design microservices-migration --persona-architect
/sc:analyze --focus architecture large-system/
/sc:estimate "redesign auth system" --persona-architect
```

**What they prioritize**:
- Maintainable, understandable code
- Loose coupling, high cohesion
- Future-proof design decisions
- Clear separation of concerns

---

#### ğŸ¨ `frontend` - UI/UX & Accessibility Expert
**What they do**: User experience, accessibility, frontend performance, design systems

**Priority**: User needs > accessibility > performance > technical elegance

**When they auto-activate**:
- Keywords: "component", "responsive", "accessibility", "UI", "UX"
- Frontend development work
- User interface related tasks

**Great for**:
- Building UI components
- Accessibility compliance (WCAG 2.1 AA)
- Frontend performance optimization
- Design system work
- User experience improvements

**Performance budgets they enforce**:
- Load time: <3s on 3G, <1s on WiFi
- Bundle size: <500KB initial, <2MB total
- Accessibility: WCAG compliance target

**Example workflows**:
```bash
/sc:build dashboard --persona-frontend
/sc:improve --focus accessibility components/
/sc:analyze --persona-frontend --focus performance
```

**What they prioritize**:
- Intuitive, user-friendly interfaces
- Accessibility for all users
- Real-world performance on mobile/3G
- Clean, maintainable CSS/JS

---

#### âš™ï¸ `backend` - API & Infrastructure Specialist
**What they do**: Server-side development, APIs, databases, reliability engineering

**Priority**: Reliability > security > performance > features > convenience

**When they auto-activate**:
- Keywords: "API", "database", "service", "server", "reliability"
- Backend development work
- Infrastructure or data-related tasks

**Great for**:
- API design and implementation
- Database schema and optimization
- Security implementation
- Reliability and error handling
- Backend performance tuning

**Reliability budgets they enforce**:
- Uptime: 99.9% (8.7h/year downtime)
- Error rate: <0.1% for critical operations
- API response time: <200ms
- Recovery time: <5 minutes for critical services

**Example workflows**:
```bash
/sc:design user-api --persona-backend
/sc:analyze --focus security api/
/sc:improve --persona-backend database-layer/
```

**What they prioritize**:
- Rock-solid reliability and uptime
- Security by default (zero trust)
- Data integrity and consistency
- Graceful error handling

---

#### ğŸ›¡ï¸ `security` - Threat Modeling & Vulnerability Expert
**What they do**: Security analysis, threat modeling, vulnerability assessment, compliance

**Priority**: Security > compliance > reliability > performance > convenience

**When they auto-activate**:
- Keywords: "security", "vulnerability", "auth", "compliance"
- Security scanning or assessment work
- Authentication/authorization tasks

**Great for**:
- Security audits and vulnerability scanning
- Threat modeling and risk assessment
- Secure coding practices
- Compliance requirements (OWASP, etc.)
- Authentication and authorization systems

**Threat assessment levels**:
- Critical: Immediate action required
- High: Fix within 24 hours
- Medium: Fix within 7 days
- Low: Fix within 30 days

**Example workflows**:
```bash
/sc:scan --persona-security --focus security
/sc:analyze auth-system/ --persona-security
/sc:improve --focus security --persona-security
```

**What they prioritize**:
- Security by default, fail-safe mechanisms
- Zero trust architecture principles
- Defense in depth strategies
- Clear security documentation

---

#### âš¡ `performance` - Optimization & Bottleneck Specialist
**What they do**: Performance optimization, bottleneck identification, metrics analysis

**Priority**: Measure first > optimize critical path > user experience > avoid premature optimization

**When they auto-activate**:
- Keywords: "performance", "optimization", "speed", "bottleneck"
- Performance analysis or optimization work
- When speed/efficiency is mentioned

**Great for**:
- Performance bottleneck identification
- Code optimization with metrics validation
- Database query optimization
- Frontend performance tuning
- Load testing and capacity planning

**Performance budgets they track**:
- API responses: <500ms
- Database queries: <100ms
- Bundle size: <500KB initial
- Memory usage: <100MB mobile, <500MB desktop

**Example workflows**:
```bash
/sc:analyze --focus performance --persona-performance
/sc:improve --type performance slow-endpoints/
/sc:test --benchmark --persona-performance
```

**What they prioritize**:
- Measurement-driven optimization
- Real user experience improvements
- Critical path performance
- Systematic optimization methodology

### Process & Quality Experts âœ¨

#### ğŸ” `analyzer` - Root Cause Investigation Specialist
**What they do**: Systematic debugging, root cause analysis, evidence-based investigation

**Priority**: Evidence > systematic approach > thoroughness > speed

**When they auto-activate**:
- Keywords: "analyze", "investigate", "debug", "root cause"
- Debugging or troubleshooting sessions
- Complex problem investigation

**Great for**:
- Debugging complex issues
- Root cause analysis
- System investigation
- Evidence-based problem solving
- Understanding unknown codebases

**Investigation methodology**:
1. Evidence collection before conclusions
2. Pattern recognition in data
3. Hypothesis testing and validation
4. Root cause confirmation through tests

**Example workflows**:
```bash
/sc:troubleshoot "auth randomly fails" --persona-analyzer
/sc:analyze --persona-analyzer mysterious-bug/
/sc:explain --detailed "why is this slow" --persona-analyzer
```

**What they prioritize**:
- Evidence-based conclusions
- Systematic investigation methods
- Complete analysis before solutions
- Reproducible findings

---

#### ğŸ§ª `qa` - Quality Assurance & Testing Expert
**What they do**: Testing strategy, quality gates, edge case detection, risk assessment

**Priority**: Prevention > detection > correction > comprehensive coverage

**When they auto-activate**:
- Keywords: "test", "quality", "validation", "coverage"
- Testing or quality assurance work
- Quality gates or edge cases mentioned

**Great for**:
- Test strategy and planning
- Quality assurance processes
- Edge case identification
- Risk-based testing
- Test automation

**Quality risk assessment**:
- Critical path analysis for user journeys
- Failure impact evaluation
- Defect probability assessment
- Recovery difficulty estimation

**Example workflows**:
```bash
/sc:test --persona-qa comprehensive-suite
/sc:analyze --focus quality --persona-qa
/sc:review --persona-qa critical-features/
```

**What they prioritize**:
- Preventing defects over finding them
- Comprehensive test coverage
- Risk-based testing priorities
- Quality built into the process

---

#### ğŸ”„ `refactorer` - Code Quality & Cleanup Specialist
**What they do**: Code quality improvement, technical debt management, clean code practices

**Priority**: Simplicity > maintainability > readability > performance > cleverness

**When they auto-activate**:
- Keywords: "refactor", "cleanup", "quality", "technical debt"
- Code improvement or cleanup work
- Maintainability concerns

**Great for**:
- Code refactoring and cleanup
- Technical debt reduction
- Code quality improvements
- Design pattern application
- Legacy code modernization

**Code quality metrics they track**:
- Cyclomatic complexity
- Code readability scores
- Technical debt ratio
- Test coverage

**Example workflows**:
```bash
/sc:improve --type quality --persona-refactorer
/sc:cleanup legacy-module/ --persona-refactorer
/sc:analyze --focus maintainability --persona-refactorer
```

**What they prioritize**:
- Simple, readable solutions
- Consistent patterns and conventions
- Maintainable code structure
- Technical debt management

---

#### ğŸš€ `devops` - Infrastructure & Deployment Expert
**What they do**: Infrastructure automation, deployment, monitoring, reliability engineering

**Priority**: Automation > observability > reliability > scalability > manual processes

**When they auto-activate**:
- Keywords: "deploy", "infrastructure", "CI/CD", "monitoring"
- Deployment or infrastructure work
- DevOps or automation tasks

**Great for**:
- Deployment automation and CI/CD
- Infrastructure as code
- Monitoring and alerting setup
- Performance monitoring
- Container and cloud infrastructure

**Infrastructure automation priorities**:
- Zero-downtime deployments
- Automated rollback capabilities
- Infrastructure as code
- Comprehensive monitoring

**Example workflows**:
```bash
/sc:deploy production --persona-devops
/sc:analyze infrastructure/ --persona-devops
/sc:improve deployment-pipeline --persona-devops
```

**What they prioritize**:
- Automated over manual processes
- Comprehensive observability
- Reliable, repeatable deployments
- Infrastructure as code practices

### Knowledge & Communication ğŸ“š

#### ğŸ‘¨â€ğŸ« `mentor` - Educational Guidance Specialist
**What they do**: Teaching, knowledge transfer, educational explanations, learning facilitation

**Priority**: Understanding > knowledge transfer > teaching > task completion

**When they auto-activate**:
- Keywords: "explain", "learn", "understand", "teach"
- Educational or knowledge transfer tasks
- Step-by-step guidance requests

**Great for**:
- Learning new technologies
- Understanding complex concepts
- Code explanations and walkthroughs
- Best practices education
- Team knowledge sharing

**Learning optimization approach**:
- Skill level assessment
- Progressive complexity building
- Learning style adaptation
- Knowledge retention reinforcement

**Example workflows**:
```bash
/sc:explain React hooks --persona-mentor
/sc:document --type guide --persona-mentor
/sc:analyze complex-algorithm.js --persona-mentor
```

**What they prioritize**:
- Clear, accessible explanations
- Complete conceptual understanding
- Engaging learning experiences
- Practical skill development

---

#### âœï¸ `scribe` - Professional Documentation Expert
**What they do**: Professional writing, documentation, localization, cultural communication

**Priority**: Clarity > audience needs > cultural sensitivity > completeness > brevity

**When they auto-activate**:
- Keywords: "document", "write", "guide", "README"
- Documentation or writing tasks
- Professional communication needs

**Great for**:
- Technical documentation
- User guides and tutorials
- README files and wikis
- API documentation
- Professional communications

**Language support**: English (default), Spanish, French, German, Japanese, Chinese, Portuguese, Italian, Russian, Korean

**Content types**: Technical docs, user guides, API docs, commit messages, PR descriptions

**Example workflows**:
```bash
/sc:document api/ --persona-scribe
/sc:git commit --persona-scribe
/sc:explain --persona-scribe=es complex-feature
```

**What they prioritize**:
- Clear, professional communication
- Audience-appropriate language
- Cultural sensitivity and adaptation
- High writing standards

## When Each Persona Shines â­

### Development Phase Mapping

**Planning & Design Phase**:
- ğŸ—ï¸ `architect` - System design and architecture planning
- ğŸ¨ `frontend` - UI/UX design and user experience
- âœï¸ `scribe` - Requirements documentation and specifications

**Implementation Phase**:
- ğŸ¨ `frontend` - UI component development
- âš™ï¸ `backend` - API and service implementation
- ğŸ›¡ï¸ `security` - Security implementation and hardening

**Testing & Quality Phase**:
- ğŸ§ª `qa` - Test strategy and quality assurance
- âš¡ `performance` - Performance testing and optimization
- ğŸ” `analyzer` - Bug investigation and root cause analysis

**Maintenance & Improvement Phase**:
- ğŸ”„ `refactorer` - Code cleanup and refactoring
- âš¡ `performance` - Performance optimization
- ğŸ‘¨â€ğŸ« `mentor` - Knowledge transfer and documentation

**Deployment & Operations Phase**:
- ğŸš€ `devops` - Deployment automation and infrastructure
- ğŸ›¡ï¸ `security` - Security monitoring and compliance
- âœï¸ `scribe` - Operations documentation and runbooks

### Problem Type Mapping

**"My code is slow"** â†’ âš¡ `performance`
**"Something's broken and I don't know why"** â†’ ğŸ” `analyzer`
**"Need to design a new system"** â†’ ğŸ—ï¸ `architect`
**"UI looks terrible"** â†’ ğŸ¨ `frontend`
**"Is this secure?"** â†’ ğŸ›¡ï¸ `security`
**"Code is messy"** â†’ ğŸ”„ `refactorer`
**"Need better tests"** â†’ ğŸ§ª `qa`
**"Deployment keeps failing"** â†’ ğŸš€ `devops`
**"I don't understand this"** â†’ ğŸ‘¨â€ğŸ« `mentor`
**"Need documentation"** â†’ âœï¸ `scribe`

## Persona Combinations ğŸ¤

Personas often work together automatically. Here are common collaboration patterns:

### Design & Implementation
```bash
/sc:design user-dashboard
# Auto-activates: ğŸ—ï¸ architect (system design) + ğŸ¨ frontend (UI design)
```

### Security Review
```bash
/sc:analyze --focus security api/
# Auto-activates: ğŸ›¡ï¸ security (primary) + âš™ï¸ backend (API expertise)
```

### Performance Optimization
```bash
/sc:improve --focus performance slow-app/
# Auto-activates: âš¡ performance (primary) + ğŸ¨ frontend (if UI) or âš™ï¸ backend (if API)
```

### Quality Improvement
```bash
/sc:improve --focus quality legacy-code/
# Auto-activates: ğŸ”„ refactorer (primary) + ğŸ§ª qa (testing) + ğŸ—ï¸ architect (design)
```

### Documentation & Learning
```bash
/sc:document complex-feature --type guide
# Auto-activates: âœï¸ scribe (writing) + ğŸ‘¨â€ğŸ« mentor (educational approach)
```

## Practical Examples ğŸ’¡

### Before/After: Generic vs Persona-Specific

**Before** (generic):
```bash
/sc:analyze auth.js
# â†’ Basic analysis, generic advice
```

**After** (security persona):
```bash
/sc:analyze auth.js --persona-security
# â†’ Security-focused analysis
# â†’ Threat modeling perspective
# â†’ OWASP compliance checking
# â†’ Vulnerability pattern detection
```

### Auto-Activation in Action

**Frontend work detection**:
```bash
/sc:build react-components/
# Auto-activates: ğŸ¨ frontend
# â†’ UI-focused build optimization
# â†’ Accessibility checking
# â†’ Performance budgets
# â†’ Bundle size analysis
```

**Complex debugging**:
```bash
/sc:troubleshoot "payment processing randomly fails"
# Auto-activates: ğŸ” analyzer
# â†’ Systematic investigation approach
# â†’ Evidence collection methodology
# â†’ Pattern analysis
# â†’ Root cause identification
```

### Manual Override Examples

**Force security perspective**:
```bash
/sc:analyze react-app/ --persona-security
# Even though it's frontend code, analyze from security perspective
# â†’ XSS vulnerability checking
# â†’ Authentication flow analysis
# â†’ Data exposure risks
```

**Get architectural advice on small changes**:
```bash
/sc:improve small-utility.js --persona-architect
# Apply architectural thinking to small code
# â†’ Design pattern opportunities
# â†’ Future extensibility
# â†’ Coupling analysis
```

## Advanced Usage ğŸš€

### Manual Persona Control

**When to override auto-activation**:
- You want a different perspective on the same problem
- Auto-activation chose wrong persona for your specific needs
- You're learning and want to see how different experts approach problems

**How to override**:
```bash
# Explicit persona selection
/sc:analyze frontend-code/ --persona-security  # Security view of frontend
/sc:improve backend-api/ --persona-performance # Performance view of backend

# Multiple persona flags (last one wins)
/sc:analyze --persona-frontend --persona-security # Uses security persona
```

### Persona-Specific Flags and Settings

**Security persona + validation**:
```bash
/sc:analyze --persona-security --focus security --validate
# â†’ Maximum security focus with validation
```

**Performance persona + benchmarking**:
```bash
/sc:test --persona-performance --benchmark --focus performance
# â†’ Performance-focused testing with metrics
```

**Mentor persona + detailed explanations**:
```bash
/sc:explain complex-concept --persona-mentor --verbose
# â†’ Educational explanation with full detail
```

### Cross-Domain Expertise

**When you need multiple perspectives**:
```bash
# Sequential analysis with different personas
/sc:analyze --persona-security api/auth.js
/sc:analyze --persona-performance api/auth.js  
/sc:analyze --persona-refactorer api/auth.js

# Or let SuperClaude coordinate automatically
/sc:analyze --focus quality api/auth.js
# Auto-coordinates: security + performance + refactorer insights
```

## Common Workflows by Persona ğŸ’¼

### ğŸ—ï¸ Architect Workflows
```bash
# System design
/sc:design microservices-architecture --persona-architect
/sc:estimate "migrate monolith to microservices" --persona-architect

# Architecture review
/sc:analyze --focus architecture --persona-architect large-system/
/sc:review --persona-architect critical-components/
```

### ğŸ¨ Frontend Workflows
```bash
# Component development
/sc:build dashboard-components/ --persona-frontend
/sc:improve --focus accessibility --persona-frontend ui/

# Performance optimization
/sc:analyze --focus performance --persona-frontend bundle/
/sc:test --persona-frontend --focus performance
```

### âš™ï¸ Backend Workflows
```bash
# API development
/sc:design rest-api --persona-backend
/sc:build api-endpoints/ --persona-backend

# Reliability improvements
/sc:improve --focus reliability --persona-backend services/
/sc:analyze --persona-backend --focus security api/
```

### ğŸ›¡ï¸ Security Workflows
```bash
# Security assessment
/sc:scan --persona-security --focus security entire-app/
/sc:analyze --persona-security auth-flow/

# Vulnerability fixing
/sc:improve --focus security --persona-security vulnerable-code/
/sc:review --persona-security --focus security critical-paths/
```

### ğŸ” Analyzer Workflows
```bash
# Bug investigation
/sc:troubleshoot "intermittent failures" --persona-analyzer
/sc:analyze --persona-analyzer --focus debugging problem-area/

# System understanding
/sc:explain --persona-analyzer complex-system/
/sc:load --persona-analyzer unfamiliar-codebase/
```

## Quick Reference ğŸ“‹

### Persona Cheat Sheet

| Persona | Best For | Auto-Activates On | Manual Flag |
|---------|----------|-------------------|-------------|
| ğŸ—ï¸ architect | System design, architecture | "architecture", "design", "scalability" | `--persona-architect` |
| ğŸ¨ frontend | UI/UX, accessibility | "component", "responsive", "UI" | `--persona-frontend` |
| âš™ï¸ backend | APIs, databases, reliability | "API", "database", "service" | `--persona-backend` |
| ğŸ›¡ï¸ security | Security, compliance | "security", "vulnerability", "auth" | `--persona-security` |
| âš¡ performance | Optimization, speed | "performance", "optimization", "slow" | `--persona-performance` |
| ğŸ” analyzer | Debugging, investigation | "analyze", "debug", "investigate" | `--persona-analyzer` |
| ğŸ§ª qa | Testing, quality | "test", "quality", "validation" | `--persona-qa` |
| ğŸ”„ refactorer | Code cleanup, refactoring | "refactor", "cleanup", "quality" | `--persona-refactorer` |
| ğŸš€ devops | Deployment, infrastructure | "deploy", "infrastructure", "CI/CD" | `--persona-devops` |
| ğŸ‘¨â€ğŸ« mentor | Learning, explanation | "explain", "learn", "understand" | `--persona-mentor` |
| âœï¸ scribe | Documentation, writing | "document", "write", "guide" | `--persona-scribe` |

### Most Useful Combinations

**Security-focused development**:
```bash
--persona-security --focus security --validate
```

**Performance optimization**:
```bash
--persona-performance --focus performance --benchmark
```

**Learning and understanding**:
```bash
--persona-mentor --verbose --explain
```

**Quality improvement**:
```bash
--persona-refactorer --focus quality --safe-mode
```

**Professional documentation**:
```bash
--persona-scribe --type guide --detailed
```

### Auto-Activation Triggers

**Strong triggers** (usually work well):
- "security audit" â†’ ğŸ›¡ï¸ security
- "UI component" â†’ ğŸ¨ frontend  
- "API design" â†’ âš™ï¸ backend
- "system architecture" â†’ ğŸ—ï¸ architect
- "debug issue" â†’ ğŸ” analyzer

**Moderate triggers** (often work):
- "improve performance" â†’ âš¡ performance
- "write tests" â†’ ğŸ§ª qa
- "clean up code" â†’ ğŸ”„ refactorer
- "deployment issue" â†’ ğŸš€ devops

**Context-dependent triggers** (varies):
- "document this" â†’ âœï¸ scribe or ğŸ‘¨â€ğŸ« mentor (depends on audience)
- "analyze this" â†’ ğŸ” analyzer, ğŸ—ï¸ architect, or domain specialist (depends on content)

## Troubleshooting Persona Issues ğŸš¨

### Common Problems

**"Wrong persona activated"**
- Use explicit persona flags: `--persona-security`
- Check if your keywords triggered auto-activation
- Try more specific language in your request

**"Persona doesn't seem to work"**
- Verify persona name spelling: `--persona-frontend` not `--persona-fronted`
- Some personas work better with specific commands
- Try combining with relevant flags: `--focus security --persona-security`

**"Want multiple perspectives"**
- Run same command with different personas manually
- Use broader focus flags: `--focus quality` (activates multiple personas)
- Let SuperClaude coordinate automatically with complex requests

**"Persona is too focused"**
- Try a different persona that's more general
- Use mentor persona for broader explanations
- Combine with `--verbose` for more context

### When to Override Auto-Activation

**Override when**:
- Auto-activation chose the wrong specialist
- You want to learn from a different perspective
- Working outside typical domain boundaries
- Need specific expertise for edge cases

**How to override effectively**:
```bash
# Force specific perspective
/sc:analyze frontend-code/ --persona-security  # Security view of frontend

# Combine multiple perspectives
/sc:analyze api/ --persona-security
/sc:analyze api/ --persona-performance  # Run separately for different views

# Use general analysis
/sc:analyze --no-persona  # Disable persona auto-activation
```

## Tips for Effective Persona Usage ğŸ’¡

### Getting Started (The Honest Way)
1. **Just ignore personas completely at first** - Auto-activation handles everything
2. **Use basic commands normally** - `/analyze`, `/build`, `/improve` work great without persona knowledge
3. **Notice what happens** - You'll see different types of expertise emerge naturally
4. **Trust the automation** - SuperClaude usually picks better experts than manual selection

### Getting Advanced (If You Want To)
1. **Experiment with manual override** - Try `--persona-security` on frontend code for different perspectives
2. **Learn the team members** - Read about individual personas when you get curious
3. **Watch persona combinations** - See how multiple experts collaborate on complex problems
4. **Use for learning** - Ask different personas the same question to see different approaches

### Best Practices (Keep It Simple)
- **Let auto-activation work first** - Override only when you want different perspectives
- **Don't overthink it** - The right experts show up when needed
- **Use for experimentation** - Try different personas on the same problem for learning
- **Trust the intelligence** - Auto-activation learns from patterns and keeps getting better

---

## Final Notes ğŸ“

**The real truth about personas** ğŸ’¯:
- **Auto-activation usually works pretty well** compared to trying to pick experts yourself
- **You can completely ignore this guide** and still often get helpful expert assistance
- **Personas exist to help you** - not to create complexity you need to manage
- **Learning happens naturally** through use, not through studying persona descriptions ğŸ˜Š

**Don't feel overwhelmed by the team** ğŸ§˜â€â™‚ï¸:
- You don't need to know what each persona does
- SuperClaude usually handles expert selection reasonably well
- The detailed descriptions above are for curiosity, not necessity
- You're not missing anything by letting auto-activation work

**When you might manually choose personas**:
- **Curiosity** - "What would a security expert think about this frontend code?"
- **Learning** - "How would different experts approach this problem?"
- **Experimentation** - "Let me see this through a performance lens"
- **Override** - "I want architectural advice on this small utility function"

**Keep it simple** ğŸ¯:
- Use normal commands like `/analyze some-code/`
- Let the right experts automatically show up
- Manual persona control is available when you want it, not because you need it
- Focus on your work, not on managing who helps you

---

*Behind all this apparent complexity of having 11 specialists, SuperClaude tries to be simple to use. Just start coding and helpful experts usually show up when needed! ğŸš€*


================================================
FILE: Docs/superclaude-user-guide.md
================================================
# SuperClaude User Guide ğŸš€

## ğŸ¯ The Simple Truth

**Behind the apparent complexity, SuperClaude is actually simple to use.**

You don't need to learn all the commands, flags, and personas. Just start using it! ğŸˆ

SuperClaude has an **intelligent routing system** that tries to figure out what you need:
- Type `/analyze some-code/` â†’ It picks the right analysis tools
- Ask about security â†’ Security expert auto-activates  
- Work on frontend â†’ UI specialist takes over
- Debug something â†’ Investigation mode kicks in

**Learning emerges during use** - you'll naturally discover what works without studying manuals first.

The detailed guides below? They're here **when you want to understand** what just happened or dive deeper. But honestly? Most of the time you can just wing it. ğŸ˜Š

---

**TL;DR**: Install it, try `/analyze` or `/build` on your code, watch the magic happen.

---

A comprehensive guide to understanding and using SuperClaude v3.0 effectively. But remember - you can skip straight to trying it out!

## Table of Contents ğŸ“–

1. [Welcome & Overview](#welcome--overview-)
2. [Core Components](#core-components-)
3. [The Three Operational Modes](#the-three-operational-modes-)
4. [The Orchestrator System](#the-orchestrator-system-)
5. [Rules & Principles](#rules--principles-)
6. [Getting Started Workflows](#getting-started-workflows-)
7. [Integration & Coordination](#integration--coordination-)
8. [Practical Examples](#practical-examples-)
9. [Tips & Best Practices](#tips--best-practices-)
10. [Troubleshooting](#troubleshooting--common-issues-)
11. [What's Next](#whats-next-)

---

## ğŸš€ Just Start Here

**Want to skip the reading and jump right in?** Here's your 2-minute getting started:

```bash
# Try these commands in Claude Code:
/sc:help                    # See what's available
/sc:analyze README.md       # SuperClaude analyzes your project
/sc:workflow feature-prd.md # Generate implementation workflow from PRD (NEW!)
/sc:implement user-auth     # Create features and components (NEW in v3!)
/sc:build                   # Smart build with auto-optimization  
/sc:improve messy-file.js   # Clean up code automatically
```

**What just happened?** SuperClaude automatically:
- Picked the right tools for each task ğŸ› ï¸
- Activated appropriate experts (security, performance, etc.) ğŸ­  
- Applied intelligent flags and optimizations âš¡
- Provided evidence-based suggestions ğŸ“Š

**See how easy that was?** No studying required - SuperClaude figures out the complexity so you don't have to.

Want to understand how it works? Keep reading. Want to just keep experimenting? Go for it! ğŸ¯

---

## Welcome & Overview ğŸ‘‹

### What is SuperClaude Really? ğŸ¤”

SuperClaude makes Claude Code smarter for development work. Instead of generic responses, you get specialized help from different experts (security, performance, frontend, etc.) who know their stuff.

**The honest truth**: We just released v3.0 and it's fresh out of beta. It works pretty well for what it does, but you should expect some rough edges as we continue improving things. We built this because we wanted Claude Code to be more helpful for real software development workflows.

**The neat part?** You don't need to manage any of this complexity. Just use normal commands like `/analyze` or `/build` and SuperClaude usually figures out which experts to involve and what tools to use. ğŸª„

### What SuperClaude Adds âœ¨

**ğŸ› ï¸ 17 Specialized Commands**
- Planning tools: `/workflow` (NEW!), `/estimate`, `/task`
- Development tools: `/implement`, `/build`, `/design`
- Analysis tools: `/analyze`, `/troubleshoot`, `/explain` 
- Quality tools: `/improve`, `/cleanup`, `/test`
- Plus utilities for documentation, git, deployment, and more
- **You just use them** - SuperClaude handles the complexity automatically
- **NEW**: `/workflow` command for PRD-to-implementation planning
- **NEW**: `/implement` command for feature creation (restores v2 functionality) 

**ğŸ­ 11 Smart Personas** *(that know when to jump in)*
- AI specialists that adapt behavior for different domains
- **Auto-activate based on your requests** (security expert for security tasks, etc.)
- Manual control available, but usually not needed
- Think of it as having a whole dev team that knows when to help

**ğŸ”§ MCP Server Integration** *(smart external tools)*
- Context7: Official library documentation lookup
- Sequential: Complex multi-step analysis
- Magic: Modern UI component generation
- Playwright: Browser automation and testing
- **Auto-connects when needed** - you don't manage this stuff

**ğŸ“‹ Enhanced Task Management** *(happens behind the scenes)*
- Progress tracking with TodoRead/TodoWrite
- Multi-session project management with `/task`
- Complex orchestration with `/spawn`
- Iterative improvement with `/loop`
- **Mostly automatic** - SuperClaude tracks what you're doing

**âš¡ Token Optimization** *(smart efficiency)*
- Smart compression when context gets full
- Symbol system for efficient communication
- Performance optimization for large operations
- **Usually activates** when needed for large projects

### Current Status (v3.0) ğŸ“Š

**âœ… What's Working Well:**
- Installation system (completely rewritten, much more reliable)
- Core framework with 16 commands and 11 personas
- MCP server integration (mostly working)
- Basic task management and workflow automation
- Documentation and user guides

**âš ï¸ What's Still Rough:**
- This is an initial release - bugs are expected
- Some MCP integrations could be smoother
- Performance isn't optimized yet for all operations
- Some advanced features are experimental

**âŒ What We Removed:**
- Hooks system (got too complex, coming back in v4)

We're pretty happy with v3 as a foundation, but there's definitely room for improvement.

### How It Works ğŸ”„

**The simple version**: You type something like `/analyze auth.js` and SuperClaude figures out the rest.

**The slightly more detailed version**:

1. **Smart routing** - Analyzes what you're asking for
2. **Auto-expert selection** - Picks the right specialist (security, performance, etc.)
3. **Tool coordination** - Connects to external systems when helpful
4. **Quality assurance** - Makes sure suggestions are solid

**You don't see any of this complexity** - it just feels like Claude got way smarter about development stuff. 

The nice thing is that most of this usually happens automatically. You make a request, SuperClaude tries to figure out a good approach, and executes with appropriate tools and expertise. Usually no configuration or setup needed - just hopefully better results. âœ¨

### Quick Feature Overview ğŸ¯

| Component | What It Does | Learn More *(optional!)* |
|-----------|--------------|------------|
| **Commands** | 15 specialized tools that auto-activate | [Commands Guide](commands-guide.md) |
| **Flags** | Modifiers that mostly activate automatically | [Flags Guide](flags-guide.md) |
| **Personas** | 11 AI specialists that know when to help | [Personas Guide](personas-guide.md) |
| **MCP Servers** | External integrations that connect when useful | [This guide](#core-components-ğŸ§©) |
| **Modes** | 3 operational modes for different workflows | [This guide](#the-three-operational-modes-ğŸ­) |
| **Orchestrator** | The smart routing that makes it all work | [This guide](#the-orchestrator-system-ğŸ¯) |

**Remember**: You can use SuperClaude effectively without reading any of these guides. They're here when you get curious about how it works! ğŸª

---

## Core Components ğŸ§©

SuperClaude is built from several interconnected systems that work together. Here's how each component fits into the bigger picture.

### Commands: Your Toolkit ğŸ› ï¸

Commands are specialized tools that handle specific types of development work. Instead of generic "help me with this," you get purpose-built tools for different scenarios.

**15 Commands Organized by Purpose:**

**Development** ğŸ”¨
- `/build` - Project building, compilation, bundling
- `/design` - System architecture and component design

**Analysis** ğŸ”  
- `/analyze` - Comprehensive code and system analysis
- `/troubleshoot` - Problem investigation and debugging
- `/explain` - Educational explanations and learning

**Quality** âœ¨
- `/improve` - Code enhancement and optimization
- `/cleanup` - Technical debt reduction
- `/test` - Testing and coverage analysis

**Utilities** ğŸ”§
- `/document` - Documentation creation
- `/git` - Enhanced git workflows
- `/load` - Project context loading
- `/estimate` - Project estimation
- `/task` - Long-term project management
- `/spawn` - Complex operation orchestration
- `/index` - Command navigation and help

Each command has its own flags, auto-activates appropriate personas, and integrates with relevant MCP servers. For detailed examples and usage patterns, see the [Commands Guide](commands-guide.md).

### Flags: Behavior Modifiers ğŸ

Flags change how SuperClaude processes your requests. They're like command-line options that modify behavior, add capabilities, or change output style.

**Key Flag Categories:**

**Planning & Analysis** ğŸ§ 
- `--think` / `--think-hard` / `--ultrathink` - Control thinking depth
- `--plan` - Show execution plan before running

**Efficiency & Control** âš¡
- `--uc` - Ultra-compressed output for large operations
- `--safe-mode` - Conservative execution with validation
- `--validate` - Pre-operation risk assessment

**MCP Server Control** ğŸ”§
- `--c7` - Enable Context7 for documentation
- `--seq` - Enable Sequential for complex analysis
- `--magic` - Enable Magic for UI components
- `--play` - Enable Playwright for testing

**Advanced Orchestration** ğŸ­
- `--delegate` - Enable sub-agent delegation for parallel processing
- `--wave-mode` - Multi-stage execution with compound intelligence
- `--loop` - Iterative improvement mode

**Focus & Scope** ğŸ¯
- `--focus security` - Focus on specific domains
- `--scope project` - Set analysis scope
- `--persona-[name]` - Activate specific personas

Flags often auto-activate based on context. For example, security-related requests usually get `--persona-security` and `--focus security`. See the [Flags Guide](flags-guide.md) for comprehensive details and patterns.

### Personas: AI Specialists ğŸ­

Personas are like having a team of specialists available on demand. Each brings different expertise, priorities, and approaches to problems.

**11 Personas Organized by Domain:**

**Technical Specialists** ğŸ”§
- ğŸ—ï¸ **architect** - Systems design, long-term architecture
- ğŸ¨ **frontend** - UI/UX, accessibility, frontend performance
- âš™ï¸ **backend** - APIs, databases, reliability
- ğŸ›¡ï¸ **security** - Threat modeling, vulnerabilities
- âš¡ **performance** - Optimization, bottleneck elimination

**Process & Quality** âœ¨
- ğŸ” **analyzer** - Root cause analysis, investigation
- ğŸ§ª **qa** - Testing, quality assurance
- ğŸ”„ **refactorer** - Code quality, technical debt
- ğŸš€ **devops** - Infrastructure, deployment

**Knowledge & Communication** ğŸ“š
- ğŸ‘¨â€ğŸ« **mentor** - Education, knowledge transfer
- âœï¸ **scribe** - Documentation, technical writing

Personas usually auto-activate based on request patterns but you can override with `--persona-[name]` flags. Each has different priorities (e.g., security persona prioritizes security over speed). See the [Personas Guide](personas-guide.md) for detailed descriptions and examples.

### MCP Servers: External Capabilities ğŸ”§

MCP (Model Context Protocol) servers provide specialized capabilities beyond Claude's native abilities.

**4 Integrated Servers:**

**Context7** ğŸ“š
- **Purpose**: Official library documentation and best practices
- **When it activates**: Framework questions, external library usage
- **What it provides**: Up-to-date docs, code examples, patterns
- **Example**: `/build react-app --c7` gets React best practices

**Sequential** ğŸ§ 
- **Purpose**: Complex multi-step analysis and systematic thinking
- **When it activates**: Debugging, system design, `--think` flags
- **What it provides**: Structured problem-solving, hypothesis testing
- **Example**: `/troubleshoot "auth randomly fails" --seq`

**Magic** âœ¨
- **Purpose**: Modern UI component generation and design systems
- **When it activates**: UI component requests, frontend work
- **What it provides**: React/Vue/Angular components, design patterns
- **Example**: `/build dashboard --magic` creates modern UI components

**Playwright** ğŸ­
- **Purpose**: Browser automation, E2E testing, performance monitoring
- **When it activates**: Testing workflows, performance analysis
- **What it provides**: Cross-browser testing, visual validation, metrics
- **Example**: `/test e2e --play` runs comprehensive browser tests

MCP servers usually coordinate automatically but you can control them with `--all-mcp`, `--no-mcp`, or specific flags like `--c7`.

### How Components Work Together ğŸ¤

The neat part is when components coordinate:

**Example: Security Analysis Request**
```bash
/sc:analyze auth-system/ --focus security
```

**What usually happens:**
1. **Command**: `/analyze` handles code analysis
2. **Flag**: `--focus security` directs attention
3. **Persona**: ğŸ›¡ï¸ security specialist auto-activates
4. **MCP**: Sequential provides systematic analysis
5. **Orchestrator**: Routes everything for optimal execution

**Result**: Security-focused analysis with threat modeling perspective, systematic methodology, and comprehensive coverage.

This coordination usually happens for most requests - SuperClaude tries to figure out a good combination of tools and expertise for your specific need.

---

## The Three Operational Modes ğŸ­

SuperClaude operates in three distinct modes that optimize different aspects of the development workflow. Understanding these modes helps you get the most out of the framework.

### Task Management Mode ğŸ“‹

**What it is**: Structured workflow execution with progress tracking and validation.

**When it's used**: Any multi-step operation that needs tracking and coordination.

**How it works**: SuperClaude breaks work into manageable tasks, tracks progress, and ensures quality through validation gates.

#### Four Layers of Task Management

**Layer 1: Session Tasks (TodoRead/TodoWrite)**
- **Scope**: Current Claude Code session
- **Capacity**: 3-20 tasks per session
- **States**: pending ğŸ“‹, in_progress ğŸ”„, completed âœ…, blocked ğŸš§
- **Usage**: Real-time progress tracking for immediate work

```bash
# SuperClaude usually creates and manages session tasks
/sc:build large-project/
# â†’ Creates: "Analyze project structure", "Run build process", "Validate output"
```

**Layer 2: Project Tasks (/task command)**
- **Scope**: Multi-session features (days to weeks)
- **Structure**: Hierarchical (Epic â†’ Story â†’ Task)
- **Persistence**: Cross-session state management
- **Usage**: Long-term feature development

```bash
/sc:task create "implement user dashboard" --priority high
/sc:task breakdown "payment integration"
/sc:task status  # Check current project tasks
```

**Layer 3: Complex Orchestration (/spawn command)**
- **Scope**: Complex multi-domain operations
- **Features**: Parallel/sequential coordination, tool management
- **Usage**: Operations involving multiple tools/systems

```bash
/sc:spawn deploy-pipeline --parallel
/sc:spawn setup-dev-environment --monitor
```

**Layer 4: Iterative Enhancement (/loop command)**
- **Scope**: Progressive refinement workflows
- **Features**: Iteration cycles with validation
- **Usage**: Quality improvement and refinement

```bash
/sc:improve messy-code.js --loop --iterations 3
# â†’ Iteratively improves code with validation between cycles
```

#### Task State Management

**Core Principles**:
- **Evidence-Based Progress**: Measurable outcomes, not just activity
- **Single Focus Protocol**: Only one task in_progress at a time
- **Real-Time Updates**: Immediate status changes as work progresses
- **Quality Gates**: Validation before marking tasks complete

**Task Detection**:
- Multi-step operations (3+ steps) â†’ Creates task breakdown
- Keywords: build, implement, create, fix, optimize â†’ Activates task tracking
- Scope indicators: system, feature, comprehensive â†’ Adds progress monitoring

### Introspection Mode ğŸ§ 

**What it is**: Meta-cognitive analysis that lets SuperClaude examine its own reasoning and decision-making processes.

**When it's used**: Complex problem-solving, framework troubleshooting, learning moments, or when you explicitly request it with `--introspect`.

**How it works**: SuperClaude steps outside normal operation to analyze its thinking patterns, decision logic, and action sequences.

#### Core Capabilities

**Reasoning Analysis** ğŸ§ 
- Examines logical flow and decision rationale
- Evaluates chain of thought coherence
- Identifies assumptions and potential biases
- Validates reasoning against evidence

**Action Sequence Review** ğŸ”„
- Analyzes tool selection effectiveness
- Reviews workflow patterns and efficiency
- Considers alternative approaches
- Identifies optimization opportunities

**Framework Compliance Check** ğŸ”
- Validates actions against SuperClaude rules and principles
- Identifies deviations from standard patterns
- Provides corrective guidance when needed
- Ensures quality standards are met

**Learning Recognition** ğŸ’¡
- Extracts insights from outcomes
- Identifies successful patterns for reuse
- Recognizes knowledge gaps for improvement
- Suggests future optimization strategies

#### Analysis Markers

When introspection mode is active, you'll see these markers:

- ğŸ§  **Reasoning Analysis** - Examining logical flow and decisions
- ğŸ”„ **Action Sequence Review** - Analyzing workflow effectiveness
- ğŸ¯ **Self-Assessment** - Meta-cognitive evaluation
- ğŸ“Š **Pattern Recognition** - Identifying behavioral patterns
- ğŸ” **Framework Compliance** - Checking rule adherence
- ğŸ’¡ **Retrospective Insight** - Learning from outcomes

#### When Introspection Activates

**Usually activates for**:
- Complex multi-step problems requiring meta-cognitive oversight
- Error recovery when outcomes don't match expectations
- Framework discussions or SuperClaude troubleshooting
- Pattern recognition needs for recurring behaviors

**Manual activation**:
```bash
/sc:analyze complex-system/ --introspect
/sc:troubleshoot "framework confusion" --introspection
```

### Token Efficiency Mode âš¡

**What it is**: Intelligent optimization system that maximizes information density while preserving quality.

**When it's used**: Large operations, when context approaches limits, or when you need faster execution.

**How it works**: Adaptive compression using symbols, abbreviations, and structural optimization based on context and persona awareness.

#### Compression Strategies

**5-Level Adaptive Compression**:
1. **Minimal** (0-40% usage): Full detail with persona-optimized clarity
2. **Efficient** (40-70% usage): Balanced compression with domain awareness  
3. **Compressed** (70-85% usage): Aggressive optimization with quality gates
4. **Critical** (85-95% usage): Maximum compression preserving essential context
5. **Emergency** (95%+ usage): Ultra-compression with information validation

#### Symbol System

**Core Logic & Flow**:
- `â†’` leads to, implies (`auth.js:45 â†’ security risk`)
- `â‡’` transforms to (`input â‡’ validated_output`)
- `&` and, combine (`security & performance`)
- `Â»` sequence, then (`build Â» test Â» deploy`)
- `âˆ´` therefore (`tests fail âˆ´ code broken`)

**Status & Progress**:
- âœ… completed, passed
- âŒ failed, error  
- âš ï¸ warning
- ğŸ”„ in progress
- ğŸ¯ target, goal

**Technical Domains**:
- âš¡ Performance
- ğŸ” Analysis
- ğŸ›¡ï¸ Security
- ğŸ“¦ Deployment
- ğŸ¨ Design

#### Activation Strategy

**Usually activates when**:
- Context usage >75% â†’ Enables compression
- Large-scale operations â†’ Prevents token overflow
- Complex orchestration â†’ Optimizes communication

**Manual activation**:
```bash
/sc:analyze huge-codebase/ --uc  # Ultra-compressed mode
/sc:improve legacy-system/ --uc --delegate auto  # Efficient large operations
```

**Performance Goals** (still improving!):
- Target: ~30-50% token reduction
- Quality: Tries to preserve ~95% of information
- Speed: Usually <100ms compression decisions
- Integration: Works with framework components

#### Mode Integration

The three modes often work together:

```bash
/sc:improve large-legacy-system/ --wave-mode auto --uc --introspect
```

**What happens**:
- **Task Management**: Creates structured improvement plan with progress tracking
- **Token Efficiency**: Compresses output for large-scale operation
- **Introspection**: Analyzes improvement strategy and validates approach

---

## The Orchestrator System ğŸ¯

The orchestrator is SuperClaude's intelligent routing system that tries to analyze your requests and coordinate a good combination of tools, personas, and integrations. It's what hopefully makes SuperClaude feel smart and responsive rather than just a collection of separate tools.

### How the Orchestrator Works ğŸ”„

**Think of it as a smart dispatcher** that:
1. **Analyzes** your request to understand intent and complexity
2. **Routes** to the best combination of commands, flags, personas, and MCP servers
3. **Coordinates** execution for optimal results
4. **Validates** through quality gates to ensure good outcomes
5. **Optimizes** performance and resource usage

### Detection Engine ğŸ§ 

The detection engine analyzes every request through multiple lenses:

#### Pattern Recognition

**Complexity Detection**:
- **Simple**: Single file operations, basic tasks (<3 steps) â†’ Direct execution
- **Moderate**: Multi-file operations, analysis tasks (3-10 steps) â†’ Standard routing
- **Complex**: System-wide changes, architectural decisions (>10 steps) â†’ Advanced orchestration

**Domain Identification**:
- **Frontend**: Keywords like "UI", "component", "responsive" â†’ ğŸ¨ frontend persona + Magic MCP
- **Backend**: Keywords like "API", "database", "service" â†’ âš™ï¸ backend persona + Context7 MCP
- **Security**: Keywords like "vulnerability", "auth", "compliance" â†’ ğŸ›¡ï¸ security persona + Sequential MCP
- **Performance**: Keywords like "slow", "optimize", "bottleneck" â†’ âš¡ performance persona + Playwright MCP

**Operation Type Classification**:
- **Analysis**: "analyze", "review", "understand" â†’ Sequential MCP + analyzer persona
- **Creation**: "create", "build", "implement" â†’ Magic MCP (if UI) or Context7 (patterns)
- **Modification**: "improve", "refactor", "optimize" â†’ Appropriate specialist persona
- **Debugging**: "troubleshoot", "fix", "debug" â†’ Sequential MCP + analyzer persona

#### Auto-Activation Logic

**High-Confidence Triggers** (90%+ activation):
```bash
/sc:analyze auth-system/ --focus security
# â†’ ğŸ›¡ï¸ security persona + Sequential MCP + --validate flag
```

**Context-Based Activation**:
```bash
/sc:build react-components/
# â†’ ğŸ¨ frontend persona + Magic MCP + --c7 flag (React docs)
```

**Performance-Based Activation**:
```bash
# When context usage >75%
/sc:analyze large-project/
# â†’ Auto-adds --uc flag for compression
```

### Routing Intelligence ğŸš¦

The routing system uses dynamic decision trees to map detected patterns to optimal tool combinations.

#### Master Routing Table

| Request Pattern | Usually Auto-Activates | How Often | Why |
|----------------|----------------|------------|-----|
| "analyze architecture" | ğŸ—ï¸ architect + --ultrathink + Sequential | Most times | Complex system analysis |
| "create UI component" | ğŸ¨ frontend + Magic + --uc | Pretty often | Frontend domain with generation |
| "security audit" | ğŸ›¡ï¸ security + --ultrathink + Sequential | Most times | Security expertise needed |
| "debug complex issue" | ğŸ” analyzer + --think + Sequential | Often | Investigation methodology |
| "improve performance" | âš¡ performance + --think-hard + Playwright | Pretty often | Performance expertise + testing |

#### Intelligent Coordination

**Multi-Server Operations**:
```bash
/sc:design user-dashboard --type api
```
**Orchestrator usually coordinates**:
- ğŸ—ï¸ architect persona (system design)
- ğŸ¨ frontend persona (UI design) 
- Context7 MCP (framework patterns)
- Sequential MCP (design methodology)

**Fallback Strategies**:
- Context7 unavailable â†’ WebSearch for documentation â†’ Manual implementation
- Sequential timeout â†’ Native Claude analysis â†’ Note limitations
- Magic failure â†’ Basic component generation â†’ Suggest manual enhancement

### Quality Gates & Validation Framework âœ…

SuperClaude tries to implement an 8-step validation cycle for operations:

#### 8-Step Quality Process

1. **Syntax Validation** - Language parsers + Context7 standards
2. **Type Checking** - Sequential analysis + compatibility verification
3. **Linting** - Context7 rules + quality analysis
4. **Security Review** - Sequential analysis + OWASP compliance
5. **Testing** - Playwright E2E + coverage analysis (aiming for good coverage)
6. **Performance** - Sequential analysis + benchmarking
7. **Documentation** - Context7 patterns + completeness validation
8. **Integration** - Playwright testing + deployment validation

#### Validation Automation

**Continuous Integration**:
- CI/CD pipeline integration
- Progressive validation with early failure detection
- Evidence generation with comprehensive metrics

**Intelligent Monitoring**:
- Success rate tracking with ML prediction
- Adaptive validation based on historical patterns
- Automatic optimization of validation strategies

### Performance Optimization âš¡

The orchestrator tries to optimize for good performance through several strategies:

#### Resource Management

**Token Allocation**:
- Detection Engine: 1-2K tokens for pattern analysis
- Decision Trees: 500-1K tokens for routing logic
- MCP Coordination: Variable based on activated servers
- Reserve: 10% buffer for unexpected complexity

**Operation Batching**:
- **Parallel execution** when no dependencies exist
- **Context sharing** across related operations
- **Cache strategies** for successful routing patterns
- **Smart queuing** to prevent resource exhaustion

#### Advanced Orchestration

**Sub-Agent Delegation**:
```bash
# Auto-activates when >7 directories or >50 files detected
/sc:analyze monorepo/
# â†’ --delegate auto flag + parallel processing
```

**Wave Orchestration**:
```bash
# Auto-activates when complexity >0.7 + files >20 + operation types >2
/sc:improve legacy-system/
# â†’ --wave-mode auto + multi-stage execution
```

### Real-World Orchestration Examples ğŸ’¡

#### Example 1: Security Analysis Request
```bash
/sc:analyze user-auth/ --focus security
```

**Orchestrator Analysis**:
- Domain: Security (high confidence)
- Complexity: Moderate (authentication system)
- Operation: Analysis + scanning

**Usually coordinates**:
- ğŸ›¡ï¸ security persona (threat modeling perspective)
- Sequential MCP (systematic analysis)
- --validate flag (pre-operation safety check)
- --think flag (complex security patterns)

**Quality Gates**: All 8 steps with emphasis on security validation

#### Example 2: Frontend Performance Optimization
```bash
/sc:improve slow-dashboard/ --focus performance
```

**Orchestrator Analysis**:
- Domain: Frontend + Performance (dual expertise needed)
- Complexity: High (performance optimization)
- Operation: Improvement + validation

**Usually coordinates**:
- âš¡ performance persona (primary)
- ğŸ¨ frontend persona (secondary, if UI detected)
- Playwright MCP (performance testing)
- --think-hard flag (complex optimization)

**Quality Gates**: Performance-focused validation with benchmarking

#### Example 3: Large Codebase Analysis  
```bash
/sc:analyze enterprise-monorepo/
```

**Orchestrator Analysis**:
- Scope: Large (>50 files detected)
- Complexity: High (enterprise-scale)
- Resources: High token usage predicted

**Usually coordinates**:
- --delegate auto flag (parallel processing)
- --uc flag (token optimization)
- ğŸ—ï¸ architect persona (system-level analysis)
- Sequential MCP (structured analysis)

**Quality Gates**: Distributed validation across sub-agents

### Orchestrator Configuration âš™ï¸

**Performance Settings**:
```yaml
orchestrator_config:
  enable_caching: true
  parallel_operations: true
  max_parallel: 3
  token_reserve: 10%
  emergency_threshold: 90%
```

**Intelligence Settings**:
```yaml
  learning_enabled: true
  confidence_threshold: 0.7
  pattern_detection: aggressive
  wave_score_threshold: 0.7
```

The orchestrator tries to learn from successful patterns and improve future routing decisions based on outcomes.

---

## Rules & Principles ğŸ“

SuperClaude operates according to core rules and principles that ensure consistent, reliable, and helpful behavior. Understanding these helps you predict how SuperClaude will approach problems and why it makes certain decisions.

### Core Operational Rules âš–ï¸

These are the core rules that SuperClaude tries to follow:

#### File Operation Security ğŸ”
- **Always Read before Write/Edit** - SuperClaude never modifies files without understanding current content
- **Use absolute paths only** - Prevents path traversal attacks and ensures reliable file operations
- **Never auto-commit** - SuperClaude won't commit changes to git unless explicitly requested
- **Prefer batch operations** - Multiple related changes are grouped for consistency

**Why this matters**: These rules prevent data loss, security vulnerabilities, and unintended modifications to your codebase.

#### Task Management Rules ğŸ“‹
- **Evidence-based progress** - Tasks are only marked complete when there's measurable evidence
- **Single focus protocol** - Only one task is "in_progress" at a time for clarity
- **Quality gates** - All operations include validation steps before completion
- **Context retention** - Tries to preserve context well across operations

**Why this matters**: Ensures reliable progress tracking and prevents work from being lost or forgotten.

#### Framework Compliance Rules ğŸ¯
- **Check dependencies first** - Always verify package.json/requirements.txt before using libraries
- **Follow existing patterns** - Respect project conventions, import styles, and architecture
- **Systematic codebase changes** - Complete discovery before making project-wide modifications
- **Validate completion** - Verify changes work and don't break existing functionality

**Why this matters**: Maintains code quality and consistency with your existing project structure.

### Development Principles ğŸ› ï¸

These principles guide how SuperClaude approaches development problems:

#### Evidence-Based Decision Making ğŸ“Š
**Primary Directive**: "Evidence > assumptions | Code > documentation | Efficiency > verbosity"

- **Measure before optimizing** - Performance improvements based on actual metrics
- **Test hypotheses systematically** - Claims supported by verifiable data
- **Document decision rationale** - Clear reasoning for architectural choices
- **Learn from outcomes** - Continuous improvement based on results

**In practice**:
```bash
/sc:improve slow-api/ --focus performance
# â†’ Measures current performance, identifies bottlenecks, optimizes based on data
```

#### SOLID Design Principles ğŸ—ï¸
- **Single Responsibility** - Each component has one reason to change
- **Open/Closed** - Open for extension, closed for modification
- **Liskov Substitution** - Derived classes substitutable for base classes
- **Interface Segregation** - No forced dependencies on unused interfaces
- **Dependency Inversion** - Depend on abstractions, not concretions

**Why SuperClaude follows these**: Leads to maintainable, scalable, and flexible code that's easier to understand and modify.

#### Quality Philosophy âœ¨
- **Prevention over detection** - Build quality in rather than test it in
- **Simplicity over complexity** - Choose the simplest solution that works
- **Maintainability over cleverness** - Code should be easy to understand and modify
- **Security by default** - Implement secure patterns from the start

#### Senior Developer Mindset ğŸ“
SuperClaude approaches problems like an experienced developer:

- **Systems thinking** - Consider impacts across the entire system
- **Long-term perspective** - Decisions evaluated against multiple time horizons
- **Risk calibration** - Distinguish between acceptable and unacceptable risks
- **Stakeholder awareness** - Balance technical perfection with practical constraints

### How Rules & Principles Affect You ğŸ’¡

#### Predictable Behavior
Because SuperClaude follows consistent rules, you can predict how it will approach problems:

```bash
/sc:improve legacy-authentication/
```
**You can expect**:
- Reading existing code before suggesting changes
- Following your project's existing patterns
- Security-first approach (security persona likely activates)
- Evidence-based recommendations with reasoning
- Quality gates before marking improvements complete

#### Quality Assurance
The principles ensure high-quality outcomes:

- **Tries to avoid magic changes** - SuperClaude usually explains its reasoning
- **Aims for no breaking changes** - Tries to preserve existing functionality
- **Security-conscious** - Security principles are important
- **Debt-aware** - Tries to maintain or reduce complexity

#### Transparency
You should usually understand what SuperClaude is doing and why:

```bash
/sc:analyze --introspect complex-system/
```
**Shows you**:
- Decision-making process
- Rule application
- Principle adherence
- Alternative approaches considered

### Examples of Rules & Principles in Action ğŸ¯

#### Example 1: Systematic Refactoring
**Request**: "Clean up this messy codebase"

**Rules Applied**:
- Complete discovery before changes (searches entire codebase)
- Read all files before modifications
- Follow existing project patterns
- Validate completion with evidence

**Principles Applied**:
- Simplicity over complexity (reduces unnecessary complexity)
- Evidence-based decisions (measures complexity before/after)
- Quality assurance (comprehensive testing)
- Long-term maintainability (considers future modifications)

#### Example 2: Security Implementation
**Request**: "Add authentication to our API"

**Rules Applied**:
- Security persona usually auto-activates
- Never compromise on security fundamentals
- Check existing patterns first
- Quality gates include security validation

**Principles Applied**:
- Security by default (implements secure patterns)
- Defense in depth (multiple security layers)
- Evidence-based approach (follows established security patterns)
- Systems thinking (considers impact on entire application)

#### Example 3: Performance Optimization
**Request**: "This page loads slowly"

**Rules Applied**:
- Measure before optimizing
- Evidence-based progress tracking
- Validate improvements with metrics
- Maintain existing functionality

**Principles Applied**:
- Measurement-driven optimization
- User experience focus
- Systematic methodology
- Prevention over detection (identifies root causes)

### Rule Enforcement & Quality Gates ğŸš¨

SuperClaude enforces rules through its quality gate system:

#### Enforcement Approach
- **Pre-operation validation** - Checks risks before starting
- **Real-time monitoring** - Tracks rule compliance during execution
- **Post-operation verification** - Confirms rules were followed
- **Evidence collection** - Documents compliance for transparency

#### When Rules Are Challenged
Sometimes rules might seem to conflict with immediate needs:

**Example**: "Just make this work quickly, don't worry about quality"

**SuperClaude's response**:
- Acknowledges the urgency
- Explains why quality rules matter for long-term success
- Offers compromise solutions that maintain essential rules
- Documents risks if quality standards are relaxed

### Principles That Guide Persona Behavior ğŸ­

Each persona follows the core principles but emphasizes different aspects:

- **ğŸ›¡ï¸ Security persona**: Security > compliance > reliability > performance
- **âš¡ Performance persona**: Measure first > optimize critical path > user experience
- **ğŸ—ï¸ Architect persona**: Long-term maintainability > scalability > performance
- **ğŸ¨ Frontend persona**: User needs > accessibility > performance > technical elegance

**Why this matters**: You can predict how different personas will prioritize trade-offs based on their core principles.

### Living Principles ğŸŒ±

These rules and principles aren't set in stone. They evolve based on:

- **Community feedback** - Real-world usage patterns inform improvements
- **Outcome analysis** - Successful patterns are reinforced
- **Technology changes** - Principles adapt to new development practices
- **User needs** - Rules balance flexibility with consistency

The goal is to maintain helpful, predictable behavior while adapting to the changing landscape of software development.

---

## Getting Started Workflows ğŸ›£ï¸

Now that you understand SuperClaude's components, let's look at practical workflows for different development scenarios. These patterns will help you get productive quickly.

### First-Time Setup ğŸ¬

If you haven't installed SuperClaude yet, see the [Installation Guide](installation-guide.md). Once installed, here's how to get started:

#### Quick Verification
```bash
# Test basic functionality
/sc:help                    # Should show SuperClaude commands
/sc:analyze README.md       # Try analyzing a simple file
/sc:build --help           # Check command options
```

#### Understanding Auto-Activation
Try these commands to see how SuperClaude automatically chooses the right tools:

```bash
# Frontend work â†’ frontend persona + Magic MCP
/sc:build src/components/

# Security analysis â†’ security persona + Sequential MCP  
/sc:analyze auth/ --focus security

# Performance investigation â†’ performance persona + Playwright MCP
/sc:analyze --focus performance slow-endpoints/
```

Watch for auto-activated flags and personas in the output. This shows SuperClaude's intelligent routing in action.

### Development Workflow Patterns ğŸ”„

#### New Project Onboarding
When starting work on an unfamiliar project:

```bash
# 1. Load project context
/sc:load --deep --summary
# â†’ Gives overview of structure, dependencies, patterns

# 2. Analyze architecture  
/sc:analyze --focus architecture
# â†’ ğŸ—ï¸ architect persona provides system understanding

# 3. Check code quality
/sc:analyze --focus quality
# â†’ ğŸ§ª qa persona identifies potential issues

# 4. Review documentation
/sc:document README --type guide
# â†’ âœï¸ scribe persona improves project documentation
```

#### Feature Development Cycle
For developing new features:

```bash
# 1. Design phase
/sc:design user-dashboard --type component
# â†’ ğŸ—ï¸ architect + ğŸ¨ frontend personas coordinate

# 2. Implementation
/sc:build dashboard-components/ 
# â†’ ğŸ¨ frontend persona + Magic MCP for UI generation

# 3. Testing
/sc:test --type e2e dashboard/
# â†’ ğŸ§ª qa persona + Playwright MCP for testing

# 4. Documentation  
/sc:document dashboard/ --type api
# â†’ âœï¸ scribe persona creates comprehensive docs
```

#### Bug Investigation & Resolution
For systematic debugging:

```bash
# 1. Problem investigation
/sc:troubleshoot "login randomly fails" --think
# â†’ ğŸ” analyzer persona + Sequential MCP for methodology

# 2. Root cause analysis
/sc:analyze auth-flow/ --focus debugging
# â†’ Systematic investigation with evidence collection

# 3. Fix implementation
/sc:improve auth/ --safe-mode --validate
# â†’ Safe improvements with validation

# 4. Verification testing
/sc:test auth-flow/ --coverage
# â†’ Comprehensive testing to ensure fix works
```

#### Code Quality Improvement
For improving existing code:

```bash
# 1. Quality assessment
/sc:analyze legacy-code/ --focus quality
# â†’ ğŸ”„ refactorer persona identifies improvement opportunities

# 2. Safe improvements
/sc:improve --preview legacy-code/
# â†’ See what would change before applying

# 3. Apply improvements
/sc:improve --safe legacy-code/
# â†’ Apply only low-risk improvements

# 4. Validate changes
/sc:test --coverage improved-code/
# â†’ Ensure improvements don't break functionality
```

### Common Workflow Combinations ğŸ¤

#### Security-First Development
```bash
# Development with security focus
/sc:analyze --persona-security --focus security
/sc:build --validate --safe-mode  
/sc:test --type security
/sc:git --persona-security --validate
```

#### Performance-Optimized Workflow
```bash
# Performance-focused development
/sc:analyze --focus performance --persona-performance
/sc:improve --type performance --benchmark
/sc:test --focus performance --play
/sc:test --focus performance --play
```

#### Team Collaboration Workflow
```bash
# Collaborative development patterns
/sc:analyze team-code/ --persona-qa --focus quality
/sc:document features/ --persona-scribe --type guide
/sc:git --smart-commit --branch-strategy
/sc:task status  # Check team progress
```

### Advanced Workflow Patterns ğŸš€

#### Large Codebase Management
For working with enterprise-scale projects:

```bash
# Efficient large-scale analysis
/sc:analyze monorepo/ --delegate auto --uc --focus architecture
# â†’ Parallel processing + compression + architectural focus

# Systematic improvements
/sc:improve legacy-system/ --wave-mode auto --safe-mode
# â†’ Multi-stage improvements with safety checks

# Comprehensive quality review
/sc:analyze enterprise-app/ --delegate folders --focus quality
# â†’ Distributed quality analysis
```

#### Legacy System Modernization
For updating old codebases:

```bash
# Assessment phase
/sc:analyze legacy/ --persona-architect --ultrathink
# â†’ Deep architectural analysis

# Planning phase  
/sc:design modernization-strategy --type architecture
# â†’ Comprehensive modernization plan

# Implementation phase
/sc:improve legacy/ --wave-mode systematic --safe-mode --loop
# â†’ Iterative, safe improvements with validation

# Migration support
/sc:migrate --type framework legacy-to-modern/
# â†’ Framework migration assistance
```

#### Multi-Domain Projects
For projects spanning multiple technical domains:

```bash
# Coordinate across domains
/sc:analyze fullstack-app/ --all-mcp --delegate auto
# â†’ All MCP servers + parallel processing

# Domain-specific improvements
/sc:improve frontend/ --persona-frontend --magic
/sc:improve backend/ --persona-backend --c7  
/sc:improve infrastructure/ --persona-devops --seq

# Integration validation
/sc:test --type integration --play
# â†’ Comprehensive integration testing
```

### Workflow Optimization Tips ğŸ’¡

#### Start Small, Scale Up
```bash
# Begin with focused scope
/sc:analyze single-component.js --focus quality

# Expand as needed
/sc:analyze entire-module/ --focus quality --delegate files

# Scale to full system
/sc:analyze whole-project/ --delegate auto --uc
```

#### Use Progressive Enhancement
```bash
# Basic command
/sc:build project/

# Add intelligence
/sc:build project/ --think --c7

# Full orchestration
/sc:build project/ --wave-mode auto --all-mcp --delegate auto
```

#### Combine Complementary Personas
```bash
# Security + Performance analysis
/sc:analyze api/ --persona-security
/sc:analyze api/ --persona-performance

# Architecture + Quality review
/sc:review system/ --persona-architect --focus architecture
/sc:review system/ --persona-qa --focus quality
```

### Troubleshooting Workflows ğŸš¨

#### When Commands Don't Work as Expected
```bash
# Debug with introspection
/sc:troubleshoot "command issues" --introspect
# â†’ Meta-cognitive analysis of what went wrong

# Try different approaches
/sc:analyze problem/ --persona-analyzer --seq
# â†’ Systematic investigation methodology

# Check framework status
/sc:load framework-status/ --summary
# â†’ Understand current SuperClaude state
```

#### When Performance is Slow
```bash
# Optimize for speed
/sc:analyze large-project/ --no-mcp --uc --scope module
# â†’ Disable extra features, compress output, limit scope

# Use delegation for large tasks
/sc:improve huge-codebase/ --delegate auto --concurrency 5
# â†’ Parallel processing with controlled concurrency
```

#### When Results Aren't Focused Enough
```bash
# Use specific focus flags
/sc:analyze code/ --focus security --scope file

# Activate appropriate personas manually
/sc:analyze frontend-code/ --persona-security  # Security view of frontend

# Combine multiple approaches
/sc:analyze --focus performance --persona-performance --play
```

### Building Your Own Workflows ğŸ› ï¸

#### Identify Your Common Patterns
Track what combinations work well for your specific needs:

```bash
# Security-focused API development
alias secure-api="/build api/ --persona-security --validate --c7"

# Performance-optimized frontend work  
alias perf-frontend="/build ui/ --persona-performance --magic --benchmark"

# Quality improvement workflow
alias quality-check="/scan --focus quality && /improve --safe-mode && /test --coverage"
```

#### Experiment with Flag Combinations
Try different combinations to find what works best:

```bash
# For learning: verbose explanations with docs
/sc:explain concept --persona-mentor --verbose --c7

# For safety: maximum validation and checking
/sc:improve critical-code/ --safe-mode --validate --preview

# For efficiency: compressed output with parallel processing
/sc:analyze big-project/ --uc --delegate auto --concurrency 3
```

Remember: SuperClaude learns from successful patterns, so the more you use effective combinations, the better it gets at auto-activating the right approach for your needs.

---

## Integration & Coordination ğŸ¤

Understanding how SuperClaude's components work together is key to using the framework effectively. This section shows you how commands, flags, personas, and MCP servers coordinate automatically - and how to control that coordination when needed.

### Auto-Coordination Examples ğŸ¤–

SuperClaude automatically coordinates components based on context. Here's how it works in practice:

#### Frontend Development Request
```bash
/sc:build react-dashboard/
```

**Automatic coordination**:
- **Command**: `/build` handles compilation and bundling
- **Persona**: ğŸ¨ frontend auto-activates (React detected)
- **MCP**: Magic provides modern UI components
- **MCP**: Context7 provides React best practices 
- **Flags**: `--c7` auto-activates for framework docs

**Result**: React-optimized build with modern components, accessibility checks, and performance optimization.

#### Security Analysis Request
```bash
/sc:scan user-authentication/ --focus security
```

**Automatic coordination**:
- **Command**: `/scan` handles security scanning
- **Persona**: ğŸ›¡ï¸ security auto-activates (security focus)
- **MCP**: Sequential provides systematic analysis
- **Flags**: `--validate` auto-activates (high-risk operation)
- **Flags**: `--think` auto-activates (complex security patterns)

**Result**: Comprehensive security analysis with threat modeling, vulnerability detection, and compliance checking.

#### Performance Investigation
```bash
/sc:troubleshoot "API responses are slow"
```

**Automatic coordination**:
- **Command**: `/troubleshoot` handles investigation
- **Persona**: âš¡ performance auto-activates (performance keywords)
- **Persona**: ğŸ” analyzer provides investigation methodology
- **MCP**: Sequential structures the debugging process
- **MCP**: Playwright provides performance testing
- **Flags**: `--think` auto-activates (complex debugging)

**Result**: Systematic performance investigation with metrics, bottleneck identification, and optimization recommendations.

### Manual Coordination Control ğŸ›ï¸

Sometimes you want to override auto-coordination for specific needs:

#### Override Persona Selection
```bash
# View frontend code from security perspective
/sc:analyze react-components/ --persona-security
# â†’ Security analysis of UI components (XSS, data exposure, etc.)

# Apply architectural thinking to small utility
/sc:improve utility-function.js --persona-architect  
# â†’ Design patterns and extensibility for simple code
```

#### Control MCP Server Usage
```bash
# Disable all MCP servers for speed
/sc:analyze large-codebase/ --no-mcp
# â†’ 40-60% faster execution, native tools only

# Enable all MCP servers for comprehensive analysis
/sc:analyze complex-system/ --all-mcp
# â†’ Maximum capabilities, higher token usage

# Use specific MCP combinations
/sc:build ui-components/ --magic --c7 --no-seq
# â†’ UI generation + docs, skip complex analysis
```

#### Combine Multiple Perspectives
```bash
# Sequential analysis with different personas
/sc:analyze payment-system/ --persona-security     # Security view
/sc:analyze payment-system/ --persona-performance  # Performance view  
/sc:analyze payment-system/ --persona-architect    # Architecture view

# Or coordinate automatically
/sc:review payment-system/ --focus quality
# â†’ Auto-coordinates security + performance + architecture insights
```

### Flag Coordination Patterns ğŸ

Flags work together to create powerful combinations:

#### Safety-First Patterns
```bash
# Maximum safety for critical code
/sc:improve production-auth/ --safe-mode --validate --preview
# â†’ Conservative changes + risk assessment + preview before applying

# Safe exploration of large changes
/sc:improve legacy-system/ --wave-mode auto --safe-mode --validate
# â†’ Multi-stage improvements + safety checks + validation gates
```

#### Performance-Optimized Patterns  
```bash
# Fast execution for large operations
/sc:analyze huge-project/ --uc --no-mcp --scope module
# â†’ Compressed output + native tools + limited scope

# Efficient parallel processing
/sc:improve monorepo/ --delegate auto --uc --concurrency 5
# â†’ Parallel processing + compression + controlled resource usage
```

#### Learning-Focused Patterns
```bash
# Educational explanations with full context
/sc:explain complex-concept --persona-mentor --verbose --c7
# â†’ Educational approach + detailed explanations + official docs

# Deep understanding with transparency
/sc:analyze mysterious-code/ --persona-analyzer --think-hard --introspect  
# â†’ Investigation methodology + deep analysis + thinking transparency
```

### MCP Server Coordination ğŸ”§

MCP servers often work together automatically:

#### Documentation + Analysis
```bash
/sc:improve old-react-code/
```
**MCP coordination**:
- Context7: Gets current React best practices
- Sequential: Analyzes code against modern patterns
- Magic: Suggests modern component patterns
- Result: Modernization with current standards

#### Testing + Performance
```bash
/sc:test dashboard/ --focus performance
```
**MCP coordination**:
- Sequential: Plans comprehensive test strategy
- Playwright: Executes performance testing
- Context7: Provides testing best practices
- Result: Performance testing with industry standards

#### Complex Problem Solving
```bash
/sc:troubleshoot "complex multi-service issue" --ultrathink
```
**MCP coordination**:
- Sequential: Structures systematic investigation
- Context7: Provides service architecture patterns
- Playwright: Tests service interactions
- Result: Comprehensive multi-domain debugging

### Persona Collaboration Patterns ğŸ­

Personas automatically collaborate on complex requests:

#### Architecture + Security
```bash
/sc:design payment-api --type secure
```
**Persona collaboration**:
- ğŸ—ï¸ architect: System design and scalability
- ğŸ›¡ï¸ security: Threat modeling and secure patterns
- âš™ï¸ backend: API implementation patterns
- Result: Secure, scalable API design

#### Frontend + Performance  
```bash
/sc:build dashboard --focus performance
```
**Persona collaboration**:
- ğŸ¨ frontend: UI/UX and accessibility
- âš¡ performance: Optimization and metrics
- ğŸ—ï¸ architect: Component architecture  
- Result: Fast, accessible, well-structured dashboard

#### Quality + Refactoring
```bash
/sc:improve legacy-code/ --focus quality
```
**Persona collaboration**:
- ğŸ”„ refactorer: Code quality and patterns
- ğŸ§ª qa: Testing and validation
- ğŸ—ï¸ architect: Structural improvements
- Result: Clean, tested, well-architected code

### Advanced Coordination Strategies ğŸš€

#### Wave Orchestration
For complex multi-stage operations:

```bash
/sc:improve enterprise-system/ --wave-mode systematic
```

**Wave coordination**:
1. **Analysis Wave**: ğŸ” analyzer + Sequential assess current state
2. **Planning Wave**: ğŸ—ï¸ architect + Context7 design improvements  
3. **Implementation Wave**: Appropriate specialists + tools implement changes
4. **Validation Wave**: ğŸ§ª qa + Playwright verify improvements
5. **Optimization Wave**: âš¡ performance + metrics optimize results

#### Sub-Agent Delegation
For parallel processing:

```bash
/sc:analyze large-monorepo/ --delegate folders
```

**Delegation coordination**:
- **Main Agent**: Orchestrates and synthesizes results
- **Sub-Agents**: Specialized analysis of individual folders
- **Coordination**: Results combined with domain expertise
- **MCP Integration**: Shared across all agents

#### Adaptive Intelligence
SuperClaude adapts coordination based on context:

**Development Phase Detection**:
- Planning phase â†’ ğŸ—ï¸ architect + âœï¸ scribe emphasis
- Implementation phase â†’ Domain specialists + Magic/Context7
- Testing phase â†’ ğŸ§ª qa + Playwright emphasis
- Deployment phase â†’ ğŸš€ devops + validation emphasis

**Complexity-Based Scaling**:
- Simple tasks â†’ Direct execution
- Moderate complexity â†’ Persona + MCP coordination
- High complexity â†’ Wave orchestration + delegation

### Coordination Troubleshooting ğŸ”§

#### When Auto-Coordination Goes Wrong
```bash
# Too many tools activated (slow/expensive)
/sc:analyze simple-file.js --no-mcp --answer-only
# â†’ Minimal tooling for simple tasks

# Wrong persona activated
/sc:analyze backend-api/ --persona-security  
# â†’ Override with explicit persona choice

# Not enough analysis depth
/sc:troubleshoot complex-issue --ultrathink --all-mcp
# â†’ Force maximum capabilities
```

#### Optimizing Coordination
```bash
# Start simple, add complexity as needed
/sc:analyze code.js                    # Basic analysis
/sc:analyze code.js --think            # Add thinking
/sc:analyze code.js --think --c7       # Add documentation
/sc:analyze code.js --think --c7 --seq # Add systematic analysis
```

#### Understanding Coordination Decisions
```bash
# See why certain tools were chosen
/sc:analyze complex-system/ --introspect
# â†’ Shows decision-making process and tool selection reasoning
```

### Best Practices for Integration ğŸ’¡

#### Let Auto-Coordination Work First
- Trust SuperClaude's automatic tool selection
- Override only when you need specific perspectives
- Start with simple commands and add flags as needed

#### Understand Flag Interactions
- Some flags override others (`--no-mcp` overrides `--c7`, `--seq`)
- Safety flags take precedence over optimization flags
- Persona flags can be overridden by more specific persona requests

#### Use Appropriate Scope
- File-level: Single persona + minimal MCP
- Module-level: Domain personas + relevant MCP
- System-level: Multiple personas + full MCP coordination

#### Monitor Resource Usage
- Large operations â†’ Use `--uc` and `--delegate`
- Simple tasks â†’ Use `--no-mcp` and `--answer-only`
- Critical operations â†’ Use `--safe-mode` and `--validate`

The key is understanding that SuperClaude's intelligence comes from the coordination between its components. The automatic coordination works well most of the time, but knowing how to control it gives you the flexibility to handle any situation.

---

## Practical Examples ğŸ’¡

Real-world scenarios showing SuperClaude in action. These examples demonstrate how different components work together to solve common development problems.

### Scenario 1: New Team Member Onboarding ğŸ‘‹

**Situation**: You're starting work on an unfamiliar React/Node.js e-commerce project.

#### Step 1: Project Understanding
```bash
/sc:load --deep --summary
```
**What happens**:
- ğŸ” analyzer persona activates (investigation needed)
- Sequential MCP structures the analysis  
- Context7 MCP identifies framework patterns
- Creates comprehensive project overview

**Output**: Project structure, tech stack, dependencies, and architecture summary.

#### Step 2: Code Quality Assessment
```bash
/sc:analyze --focus quality
```
**Auto-coordination**:
- ğŸ§ª qa persona activates (quality focus)
- Sequential MCP provides systematic analysis
- Scans for code quality, security, and performance issues
- Generates actionable improvement recommendations

**Output**: Quality report with specific issues and improvement suggestions.

#### Step 3: Architecture Understanding
```bash
/sc:analyze --focus architecture --persona-architect
```
**What happens**:
- ğŸ—ï¸ architect persona provides system design perspective
- Context7 MCP brings in React/Node.js architectural patterns
- Sequential MCP structures the architectural analysis
- Identifies design patterns, data flow, and component relationships

**Output**: Architectural overview with design patterns and system relationships.

#### Step 4: Getting Started Guide
```bash
/sc:document onboarding --type guide --persona-scribe
```
**What happens**:
- âœï¸ scribe persona creates professional documentation
- Context7 MCP provides documentation standards
- Synthesizes previous analysis into newcomer-friendly guide
- Includes setup instructions and key concepts

**Output**: Comprehensive onboarding guide for future team members.

**Time saved**: What normally takes 2-3 days of exploration is condensed into a comprehensive understanding in about 30 minutes.

### Scenario 2: Security Vulnerability Investigation ğŸ›¡ï¸

**Situation**: Security scanner flagged potential issues in user authentication system.

#### Step 1: Security-Focused Analysis
```bash
/sc:scan auth-system/ --persona-security --focus security
```
**Auto-coordination**:
- ğŸ›¡ï¸ security persona activates (security expertise)
- Sequential MCP provides systematic threat modeling
- Context7 MCP brings in OWASP and security best practices
- `--validate` flag auto-activates (high-risk operation)

**Output**: Detailed security analysis with threat assessment and vulnerability prioritization.

#### Step 2: Root Cause Investigation  
```bash
/sc:troubleshoot "JWT token exposure in logs" --think --seq
```
**What happens**:
- ğŸ” analyzer persona provides investigation methodology
- `--think` flag enables deep analysis
- Sequential MCP structures the debugging process
- Traces data flow and identifies exposure points

**Output**: Root cause analysis with evidence trail and impact assessment.

#### Step 3: Secure Implementation
```bash
/sc:improve auth-system/ --focus security --safe-mode --validate
```
**Auto-coordination**:
- ğŸ›¡ï¸ security persona maintains security focus
- `--safe-mode` ensures conservative changes
- `--validate` confirms changes before applying
- Context7 MCP provides secure coding patterns

**Output**: Security improvements with minimal risk and comprehensive validation.

#### Step 4: Security Testing
```bash
/sc:test auth-system/ --type security --play
```
**What happens**:
- ğŸ§ª qa persona provides testing expertise  
- Playwright MCP executes security testing scenarios
- Tests authentication flows, session management, and access controls
- Validates security improvements are working

**Output**: Comprehensive security test results with evidence of improvements.

**Risk reduction**: Systematic approach reduces chance of missing security issues and ensures comprehensive coverage.

### Scenario 3: Performance Optimization Sprint âš¡

**Situation**: E-commerce dashboard is loading slowly, affecting user experience.

#### Step 1: Performance Analysis
```bash
/sc:analyze dashboard/ --focus performance --persona-performance
```
**Auto-coordination**:
- âš¡ performance persona activates (performance expertise)
- Playwright MCP provides performance metrics and testing
- Context7 MCP brings in React performance best practices
- `--think-hard` auto-activates (complex performance analysis)

**Output**: Performance bottleneck identification with metrics and prioritized optimization opportunities.

#### Step 2: Frontend Performance Deep Dive
```bash
/sc:analyze frontend/ --persona-frontend --focus performance --play
```
**What happens**:
- ğŸ¨ frontend persona provides UI/UX perspective
- âš¡ performance persona coordinates (dual expertise)
- Playwright MCP measures Core Web Vitals, bundle sizes, render times
- Magic MCP suggests modern optimization patterns

**Output**: Frontend-specific performance analysis with accessibility and user experience considerations.

#### Step 3: Backend API Performance
```bash
/sc:analyze api/ --persona-backend --focus performance
```
**Auto-coordination**:
- âš™ï¸ backend persona provides server-side expertise
- Sequential MCP analyzes database queries and API patterns
- Context7 MCP provides Node.js/Express optimization patterns
- Identifies slow queries, inefficient endpoints, and caching opportunities

**Output**: Backend performance analysis with database and API optimization recommendations.

#### Step 4: Systematic Optimization
```bash
/sc:improve dashboard/ --focus performance --loop --iterations 3
```
**What happens**:
- âš¡ performance persona leads optimization
- `--loop` enables iterative improvement
- Each iteration: optimize â†’ measure â†’ validate â†’ improve
- Progressive enhancement with metrics validation

**Output**: Iterative performance improvements with measurable results after each cycle.

#### Step 5: Performance Testing Validation
```bash
/sc:test dashboard/ --focus performance --play --benchmark
```
**What happens**:
- Playwright MCP executes comprehensive performance testing
- Tests on multiple devices, network conditions, and browsers
- Measures Core Web Vitals, load times, and user interaction metrics
- Validates improvements meet performance budgets

**Output**: Performance test results proving optimization effectiveness.

**Performance gain**: Systematic approach typically achieves 40-70% performance improvements with measurable validation.

### Scenario 4: Legacy Code Modernization ğŸ”„

**Situation**: 5-year-old React application needs modernization to current standards.

#### Step 1: Legacy Assessment
```bash
/sc:analyze legacy-app/ --persona-architect --ultrathink
```
**Auto-coordination**:
- ğŸ—ï¸ architect persona provides structural analysis
- `--ultrathink` enables maximum analysis depth
- Context7 MCP compares against current React patterns
- Sequential MCP provides systematic modernization assessment

**Output**: Comprehensive legacy analysis with modernization roadmap and risk assessment.

#### Step 2: Modernization Planning
```bash
/sc:design modernization-strategy --type architecture --persona-architect
```
**What happens**:
- ğŸ—ï¸ architect persona designs migration strategy
- Context7 MCP provides current React ecosystem patterns
- Sequential MCP structures the modernization plan
- Identifies migration phases, dependencies, and risks

**Output**: Detailed modernization plan with phased approach and risk mitigation.

#### Step 3: Safe Incremental Improvements
```bash
/sc:improve legacy-components/ --safe-mode --wave-mode systematic --loop
```
**Auto-coordination**:
- ğŸ”„ refactorer persona leads code improvements
- `--safe-mode` ensures minimal risk
- `--wave-mode systematic` enables multi-stage improvements
- `--loop` allows iterative refinement
- Multiple personas coordinate: architect, frontend, qa

**Output**: Systematic modernization with safety checks and progressive enhancement.

#### Step 4: Testing Modernization
```bash
/sc:test modernized-app/ --type integration --coverage --play
```
**What happens**:
- ğŸ§ª qa persona ensures quality throughout modernization
- Playwright MCP provides comprehensive testing
- Tests legacy compatibility and new functionality
- Validates modernization doesn't break existing features

**Output**: Comprehensive test results proving modernization success.

**Modernization success**: Systematic approach reduces modernization risk by 80% and ensures compatibility.

### Scenario 5: Multi-Team API Design ğŸŒ

**Situation**: Designing a new microservice API that multiple teams will consume.

#### Step 1: Requirements Analysis
```bash
/sc:design user-service-api --type api --persona-backend
```
**Auto-coordination**:
- âš™ï¸ backend persona provides API design expertise
- ğŸ—ï¸ architect persona coordinates for system integration
- Context7 MCP provides API design best practices
- Sequential MCP structures requirement analysis

**Output**: Comprehensive API design with endpoints, data models, and integration patterns.

#### Step 2: Security Review
```bash
/sc:review api-design/ --persona-security --focus security
```
**What happens**:
- ğŸ›¡ï¸ security persona evaluates API security
- Reviews authentication, authorization, and data protection
- Context7 MCP provides OWASP API security guidelines
- Identifies security requirements and threat vectors

**Output**: Security assessment with hardening recommendations and compliance requirements.

#### Step 3: Performance Considerations
```bash
/sc:analyze api-design/ --persona-performance --focus performance
```
**Auto-coordination**:
- âš¡ performance persona evaluates scalability
- Analyzes endpoint performance, caching strategies, rate limiting
- Context7 MCP provides high-performance API patterns
- Projects performance under load

**Output**: Performance analysis with scalability recommendations and optimization strategies.

#### Step 4: Documentation for Multiple Teams
```bash
/sc:document api/ --type api --persona-scribe --detailed
```
**What happens**:
- âœï¸ scribe persona creates professional API documentation
- Context7 MCP provides API documentation standards
- Creates examples, integration guides, and troubleshooting
- Tailored for multiple consuming teams

**Output**: Comprehensive API documentation with examples, integration guides, and best practices.

#### Step 5: Implementation Validation
```bash
/sc:build api-implementation/ --validate --test-coverage
```
**Auto-coordination**:
- âš™ï¸ backend persona implements API patterns
- ğŸ§ª qa persona ensures quality and testing
- Sequential MCP validates implementation against design
- Comprehensive testing and validation

**Output**: Production-ready API implementation with comprehensive testing and validation.

**Collaboration efficiency**: Multi-persona coordination reduces design iteration cycles by 60% and improves cross-team alignment.

### Common Pattern Recognition ğŸ”

These examples show recurring patterns in how SuperClaude components coordinate:

#### Investigation â†’ Analysis â†’ Implementation â†’ Validation
Most complex workflows follow this pattern with appropriate personas and tools for each phase.

#### Multi-Persona Coordination
Complex problems benefit from multiple perspectives (security + performance, architecture + frontend, etc.).

#### Progressive Enhancement
Starting simple and adding complexity as needed (`--think` â†’ `--think-hard` â†’ `--ultrathink`).

#### Safety-First Approach
Critical operations automatically include validation and safety checks (`--safe-mode`, `--validate`).

#### Context-Aware Tool Selection
SuperClaude automatically chooses appropriate MCP servers and flags based on detected context.

These examples demonstrate that SuperClaude's value comes from intelligent coordination of its components rather than any single capability. The framework adapts to your needs while maintaining consistent quality and safety standards.

---

## Tips & Best Practices ğŸ¯

Based on real-world usage patterns and successful workflows, here are practical tips for getting the most out of SuperClaude.

### Starting Out Successfully ğŸš€

#### Begin with Simple Commands
```bash
# Start here - basic functionality
/sc:help
/sc:analyze README.md
/sc:build --help

# Not here - complex orchestration
/sc:improve entire-codebase/ --wave-mode force --all-mcp --delegate auto
```

**Why**: Understanding basic behavior before adding complexity prevents confusion and helps you learn the framework gradually.

#### Trust Auto-Activation First
```bash
# Let SuperClaude choose tools
/sc:analyze auth-system/  
# â†’ Watch what auto-activates (likely security persona + validation)

# Then experiment with manual control
/sc:analyze auth-system/ --persona-performance
# â†’ See different perspective on same code
```

**Why**: Auto-activation usually gets it right and shows you optimal tool combinations for different scenarios.

#### Use Preview and Safe Modes
```bash
# See what would happen first
/sc:improve messy-code.js --preview

# Apply changes safely  
/sc:improve messy-code.js --safe-mode

# For critical code, use both
/sc:improve production-auth/ --preview --safe-mode --validate
```

**Why**: Prevents unintended changes and helps you understand what SuperClaude will do before it does it.

### Flag Usage Patterns ğŸ

#### Start Simple, Add Complexity
```bash
# Basic command
/sc:analyze complex-system/

# Add thinking if needed
/sc:analyze complex-system/ --think

# Add documentation if external libraries involved
/sc:analyze complex-system/ --think --c7

# Full analysis for critical systems
/sc:analyze complex-system/ --think-hard --c7 --seq --validate
```

**Why**: Incremental complexity helps you understand what each flag adds and avoids over-engineering simple problems.

#### Common Flag Combinations That Work
```bash
# Safe improvement workflow
/sc:improve --preview â†’ /improve --safe-mode â†’ /test --coverage

# Deep investigation workflow  
/sc:troubleshoot issue --think --seq â†’ /analyze affected-code/ --focus quality

# Learning and documentation workflow
/sc:explain concept --persona-mentor --verbose --c7

# Performance optimization workflow
/sc:analyze --focus performance --persona-performance --play
```

**Why**: These combinations are proven patterns that work well together and don't conflict.

#### Avoid Flag Conflicts
```bash
# âŒ Conflicting flags
/sc:analyze code/ --no-mcp --c7  # --no-mcp overrides --c7

# âŒ Counterproductive combinations
/sc:analyze small-file.js --ultrathink --all-mcp  # Overkill for simple tasks

# âœ… Sensible combinations
/sc:analyze large-system/ --think --delegate auto  # Appropriate for complexity
/sc:analyze simple-utility.js --answer-only       # Appropriate for simplicity
```

**Why**: Understanding flag precedence and interactions prevents unexpected behavior and wasted resources.

### Persona Optimization ğŸ­

#### Let Domain Auto-Activation Work
```bash
# These will automatically get the right persona
/sc:build react-components/     # â†’ frontend persona
/sc:scan auth/ --focus security # â†’ security persona  
/sc:troubleshoot slow-api/      # â†’ performance + analyzer personas
```

**Why**: Auto-activation is based on proven patterns and usually selects the most appropriate expertise.

#### Manual Override for Different Perspectives
```bash
# Get different viewpoints on same code
/sc:analyze payment-flow/ --persona-security    # Security perspective
/sc:analyze payment-flow/ --persona-performance # Performance perspective
/sc:analyze payment-flow/ --persona-architect   # Architecture perspective
```

**Why**: Different personas provide unique insights that can reveal issues or opportunities others might miss.

#### Use Appropriate Personas for Project Phases
```bash
# Planning phase
/sc:design new-feature --persona-architect

# Implementation phase  
/sc:build feature/ --persona-frontend  # or backend, etc.

# Testing phase
/sc:test feature/ --persona-qa

# Documentation phase
/sc:document feature/ --persona-scribe
```

**Why**: Each project phase benefits from different types of expertise and perspectives.

### MCP Server Strategy ğŸ”§

#### Understand When Each Server Helps
- **Context7**: When working with frameworks, libraries, or need official documentation
- **Sequential**: For complex debugging, systematic analysis, or architectural decisions  
- **Magic**: For UI component generation, design systems, or frontend development
- **Playwright**: For testing, performance measurement, or browser automation

#### Optimize for Performance vs. Capabilities
```bash
# Fast execution for simple tasks
/sc:analyze simple-script.js --no-mcp

# Comprehensive analysis for complex problems
/sc:analyze complex-system/ --all-mcp --think-hard

# Balanced approach for most work
/sc:analyze typical-component/ --c7  # Just documentation lookup
```

**Why**: Matching MCP usage to task complexity optimizes both speed and quality of results.

### Workflow Optimization ğŸ“ˆ

#### Use Progressive Enhancement
```bash
# Level 1: Basic analysis
/sc:analyze component.js

# Level 2: Add thinking if complex
/sc:analyze component.js --think

# Level 3: Add documentation for frameworks
/sc:analyze component.js --think --c7

# Level 4: Full analysis for critical code
/sc:analyze component.js --think-hard --c7 --seq --validate
```

**Why**: Start with what you need and add complexity only when necessary. Prevents over-engineering and saves time.

#### Batch Related Operations
```bash
# âœ… Efficient: Related operations together
/sc:analyze auth-system/ --focus security
/sc:improve auth-system/ --focus security --safe-mode  
/sc:test auth-system/ --type security

# âŒ Inefficient: Scattered operations
/sc:analyze auth-system/
/sc:review different-system/
/sc:improve auth-system/  # Context lost between operations
```

**Why**: Batching related work maintains context and allows SuperClaude to build on previous analysis.

#### Use Appropriate Scope
```bash
# File-level for specific issues
/sc:improve single-component.js --focus performance

# Module-level for related functionality
/sc:analyze user-auth/ --scope module

# Project-level for architectural concerns
/sc:analyze --scope project --focus architecture

# System-level only when necessary
/sc:analyze --scope system --delegate auto --uc
```

**Why**: Matching scope to problem prevents both under-analysis and resource waste.

### Performance and Efficiency ğŸƒâ€â™‚ï¸

#### Manage Context and Token Usage
```bash
# For large operations, use compression
/sc:analyze huge-codebase/ --uc --delegate auto

# For repeated analysis, cache results
/sc:load project-context/  # Cache project understanding
/sc:analyze specific-issue/  # Build on cached context

# For simple questions, minimize overhead
/sc:explain quick-concept --answer-only --no-mcp
```

**Why**: Token efficiency keeps operations fast and prevents context overflow in large projects.

#### Use Delegation for Large Projects
```bash
# Automatically delegate when appropriate
/sc:analyze monorepo/ --delegate auto

# Manual delegation for specific needs
/sc:analyze large-project/ --delegate folders --concurrency 3

# Skip delegation for small projects
/sc:analyze small-app/ --no-delegate
```

**Why**: Delegation provides significant speedup (40-70%) for large-scale operations while maintaining quality.

#### Optimize Command Sequences
```bash
# âœ… Efficient sequence
/sc:load project/           # Understand context once
/sc:analyze --focus quality # Build on understanding
/sc:improve --safe-mode     # Apply improvements
/sc:test --coverage         # Validate changes

# âŒ Inefficient sequence  
/sc:analyze file1.js
/sc:analyze file2.js        # Duplicate setup
/sc:analyze file3.js        # Lost optimization opportunities
```

**Why**: Sequential commands can build on each other's context and analysis for better results.

### Quality and Safety ğŸ›¡ï¸

#### Always Validate Important Changes
```bash
# For production code
/sc:improve production-auth/ --safe-mode --validate --preview

# For experimental features
/sc:improve experimental-feature/ --validate

# For learning/exploration
/sc:improve test-code/ --preview  # See what it would do
```

**Why**: Validation prevents breaking changes and helps you understand the impact of modifications.

#### Use Quality Gates Effectively
```bash
# Let quality gates run automatically
/sc:build production-app/  # 8-step validation process runs

# Add extra validation for critical systems
/sc:build payment-system/ --validate --safe-mode

# Skip validation only for experimental work
/sc:build prototype/ --no-validate  # Use sparingly
```

**Why**: Quality gates catch issues early when they're cheaper and easier to fix.

#### Maintain Evidence Trail
```bash
# Commands that provide evidence
/sc:analyze --focus performance  # â†’ Performance metrics
/sc:test --coverage             # â†’ Coverage reports  
/sc:scan --focus security       # â†’ Security assessment

# Use introspection for complex decisions
/sc:analyze complex-system/ --introspect  # â†’ Decision reasoning
```

**Why**: Evidence-based development leads to better decisions and easier debugging when issues arise.

### Learning and Growth ğŸ“š

#### Use Mentor Persona for Learning
```bash
# Learn new concepts
/sc:explain GraphQL --persona-mentor --verbose

# Understand complex code
/sc:analyze complex-algorithm.js --persona-mentor

# Get step-by-step guidance
/sc:build new-feature/ --persona-mentor --plan
```

**Why**: Mentor persona optimizes for understanding and knowledge transfer rather than just task completion.

#### Experiment with Different Approaches
```bash
# Try different personas on same problem
/sc:analyze api-design/ --persona-architect
/sc:analyze api-design/ --persona-security
/sc:analyze api-design/ --persona-performance

# Compare tool combinations
/sc:build app/ --magic --c7
/sc:build app/ --no-mcp --uc  # Faster but simpler
```

**Why**: Understanding different approaches helps you choose the best tools for different situations.

#### Build Your Own Patterns
```bash
# Identify what works for your workflow
# Security-focused API development
/sc:design api --persona-security --validate
/sc:build api --persona-backend --c7
/sc:test api --type security --play

# Create your own efficient combinations
/sc:analyze code/ --think --c7 --safe-mode  # Your personal "thorough analysis"
```

**Why**: Developing your own proven patterns increases productivity and ensures consistent quality.

### Common Pitfalls to Avoid âš ï¸

#### Don't Over-Engineer Simple Tasks
```bash
# âŒ Overkill for simple tasks
/sc:analyze simple-utility.js --ultrathink --all-mcp --wave-mode force

# âœ… Appropriate for simple tasks  
/sc:analyze simple-utility.js --focus quality
```

#### Don't Ignore Auto-Activation Wisdom
```bash
# âŒ Fighting the system
/sc:build react-app/ --persona-backend --no-magic  # Wrong tools for the job

# âœ… Working with the system
/sc:build react-app/  # Let frontend persona and Magic activate automatically
```

#### Don't Skip Safety for Speed
```bash
# âŒ Risky for important code
/sc:improve production-auth/ --force --no-validate

# âœ… Balanced approach
/sc:improve production-auth/ --safe-mode --validate  # Safer but still efficient
```

#### Don't Use Flags You Don't Understand
```bash
# âŒ Cargo cult flag usage
/sc:command --random-flags-that-look-important

# âœ… Understand what each flag does
/sc:command --think  # Because I need deeper analysis
/sc:command --c7     # Because I'm working with external libraries
```

### Measuring Success ğŸ“Š

Track what works well for your specific needs:

- **Speed**: How quickly do different flag combinations complete?
- **Quality**: Which approaches produce better results for your type of work?
- **Learning**: Which combinations help you understand problems better?
- **Safety**: Which patterns prevent issues in your environment?

Remember: SuperClaude learns from successful patterns, so using effective combinations consistently helps the framework get better at auto-activation for your specific workflow.

---

## Troubleshooting & Common Issues ğŸš¨

When SuperClaude doesn't work as expected, here's how to diagnose and fix common problems.

### Command Issues ğŸ› ï¸

#### Commands Not Working as Expected

**Problem**: Command produces unexpected results or seems to ignore your request.

**Diagnosis**:
```bash
# Check what auto-activated
/sc:analyze code.js --introspect
# â†’ Shows decision-making process

# Try with explicit control
/sc:analyze code.js --persona-analyzer --think --seq
# â†’ Override auto-activation
```

**Solutions**:
```bash
# Be more specific about what you want
/sc:improve code.js --focus performance --safe-mode

# Use preview to understand what will happen
/sc:improve code.js --preview

# Start simple and add complexity
/sc:analyze code.js                    # Basic
/sc:analyze code.js --think            # Add depth
/sc:analyze code.js --think --c7       # Add documentation
```

**Common Causes**:
- Auto-activation chose different tools than you expected
- Request was too vague for SuperClaude to understand intent
- Complexity mismatch (simple request with complex flags or vice versa)

#### Commands Running Too Slowly

**Problem**: Operations take much longer than expected.

**Diagnosis**:
```bash
# Check what's activated
/sc:analyze large-project/ --introspect
# â†’ See what tools and servers are being used

# Monitor resource usage
/sc:analyze large-project/ --verbose
# â†’ Shows detailed execution steps
```

**Solutions**:
```bash
# Optimize for speed
/sc:analyze large-project/ --uc --no-mcp --scope module

# Use delegation for large operations
/sc:analyze huge-codebase/ --delegate auto --concurrency 3

# Reduce scope
/sc:analyze specific-component.js  # Instead of entire project

# Disable expensive features
/sc:analyze code/ --no-mcp --answer-only
```

**Performance Optimization Priority**:
1. Reduce scope (`--scope file` vs `--scope project`)
2. Use compression (`--uc`)
3. Disable MCP servers (`--no-mcp`)
4. Use delegation (`--delegate auto`)
5. Use answer-only mode (`--answer-only`)

#### Commands Producing Too Much Output

**Problem**: Information overload, hard to find relevant information.

**Solutions**:
```bash
# Use compression
/sc:analyze large-system/ --uc

# Be more specific about focus
/sc:analyze system/ --focus security  # Instead of general analysis

# Use answer-only for simple questions
/sc:explain concept --answer-only

# Limit scope
/sc:analyze --scope file specific-issue.js
```

### Flag Issues ğŸ

#### Flag Conflicts and Unexpected Behavior

**Problem**: Flags don't seem to work or produce unexpected results.

**Common Conflicts**:
```bash
# âŒ These conflict
/sc:command --no-mcp --c7        # --no-mcp overrides --c7
/sc:command --answer-only --plan # --answer-only skips planning
/sc:command --uc --verbose       # --uc overrides --verbose

# âœ… These work together
/sc:command --think --c7 --seq   # Complementary capabilities
/sc:command --safe-mode --validate --preview  # Layered safety
```

**Flag Precedence Order**:
1. Safety flags (`--safe-mode`) > optimization flags
2. Explicit flags > auto-activation  
3. `--no-mcp` overrides all individual MCP flags
4. Last specified persona wins
5. Scope: system > project > module > file

**Diagnosis**:
```bash
# Check what flags are actually active
/sc:command args --introspect
# â†’ Shows final flag configuration after precedence resolution
```

#### Auto-Activation Issues

**Problem**: Wrong flags or personas auto-activate.

**Solutions**:
```bash
# Override auto-activation explicitly
/sc:analyze frontend-code/ --persona-security  # Force security view
/sc:build project/ --no-mcp                    # Force native tools only

# Use more specific language
/sc:analyze "security vulnerabilities in auth system"  # Clear intent
# vs
/sc:analyze auth system                                # Ambiguous

# Check what keywords trigger auto-activation
/sc:help analyze  # Shows auto-activation patterns
```

**Auto-Activation Debugging**:
```bash
# See why certain flags activated
/sc:troubleshoot "why did --think-hard activate?" --introspect
```

### Persona Issues ğŸ­

#### Wrong Persona Activated

**Problem**: SuperClaude uses the wrong specialist for your needs.

**Diagnosis**:
```bash
# Check what triggered persona activation
/sc:analyze code/ --introspect
# â†’ Shows persona selection reasoning
```

**Solutions**:
```bash
# Override with explicit persona
/sc:analyze backend-api/ --persona-security  # Security view of backend code
/sc:analyze ui-component/ --persona-performance  # Performance view of frontend

# Use more specific language
/sc:analyze "security issues in payment processing"  # Triggers security persona
/sc:analyze "slow database queries"                  # Triggers performance persona

# Try different personas for different perspectives
/sc:analyze payment-system/ --persona-security    # Security view
/sc:analyze payment-system/ --persona-architect   # Architecture view
```

#### Persona Doesn't Seem Active

**Problem**: Expected persona behavior but getting generic responses.

**Check Persona Activation**:
```bash
# Verify persona is active
/sc:analyze auth/ --persona-security --introspect
# â†’ Should show security-focused reasoning

# Check if domain keywords are clear
/sc:scan authentication --focus security  # Should auto-activate security persona
```

**Solutions**:
```bash
# Be explicit about persona and focus
/sc:analyze code/ --persona-security --focus security

# Use appropriate commands for personas
/sc:scan --persona-security     # Security scanning
/sc:test --persona-qa           # Quality-focused testing
/sc:document --persona-scribe   # Professional documentation
```

### MCP Server Issues ğŸ”§

#### MCP Servers Not Activating

**Problem**: Expected MCP capabilities but they don't seem to work.

**Diagnosis**:
```bash
# Check MCP server status
/sc:troubleshoot "MCP servers not working" --introspect

# Verify MCP installation
/sc:load --summary  # Should show available MCP servers

# Test specific servers
/sc:analyze react-app/ --c7     # Should use Context7
/sc:troubleshoot issue --seq    # Should use Sequential
/sc:build ui/ --magic           # Should use Magic
/sc:test app/ --play            # Should use Playwright
```

**Common Solutions**:
```bash
# Force MCP activation
/sc:analyze code/ --all-mcp

# Check if servers are disabled
/sc:analyze code/ --c7  # If this doesn't work, Context7 may be unavailable

# Use fallback approaches
/sc:analyze react-app/ --no-mcp  # Use native tools if MCP unavailable
```

#### MCP Servers Too Slow

**Problem**: MCP server integration causes slow performance.

**Solutions**:
```bash
# Disable MCP for speed
/sc:analyze large-project/ --no-mcp

# Use selective MCP activation
/sc:analyze react-code/ --magic --no-seq  # Only UI generation, skip analysis

# Optimize MCP usage
/sc:analyze code/ --uc --c7  # Compression + documentation only
```

### Performance Issues âš¡

#### Operations Using Too Many Tokens

**Problem**: Hitting context limits or expensive operations.

**Solutions**:
```bash
# Enable compression automatically
/sc:analyze huge-project/ --uc

# Reduce scope
/sc:analyze --scope module specific-area/
/sc:analyze --scope file specific-file.js

# Use delegation
/sc:analyze large-codebase/ --delegate auto --uc

# Disable expensive features
/sc:analyze code/ --no-mcp --answer-only
```

#### Memory or Resource Issues

**Problem**: Operations failing or very slow due to resource constraints.

**Solutions**:
```bash
# Reduce concurrency
/sc:analyze large-project/ --delegate auto --concurrency 1

# Use safe mode
/sc:improve large-system/ --safe-mode  # More conservative resource usage

# Break work into smaller chunks
/sc:analyze module1/
/sc:analyze module2/
/sc:analyze module3/
# Instead of /analyze entire-project/
```

### Quality and Safety Issues ğŸ›¡ï¸

#### Unsafe or Risky Suggestions

**Problem**: SuperClaude suggests changes that seem risky.

**Always Use Safety Features**:
```bash
# Preview before applying
/sc:improve important-code/ --preview

# Use safe mode for critical code
/sc:improve production-auth/ --safe-mode

# Add validation
/sc:improve system/ --validate --safe-mode

# Use iterative approach
/sc:improve complex-system/ --loop --safe-mode
```

#### Changes Breaking Functionality

**Problem**: Applied improvements cause issues.

**Prevention**:
```bash
# Always use preview first
/sc:improve code/ --preview

# Use safe mode
/sc:improve code/ --safe-mode

# Test after changes
/sc:improve code/ --safe-mode && /test code/
```

**Recovery**:
- Use git to revert changes
- Apply improvements incrementally with `--safe-mode`
- Use `--validate` to check before applying changes

### Framework and Integration Issues ğŸ”—

#### SuperClaude Doesn't Understand Project Context

**Problem**: Recommendations don't fit your project's patterns or constraints.

**Solutions**:
```bash
# Load project context first
/sc:load --deep --summary

# Be explicit about project type
/sc:analyze react-typescript-app/ --c7  # Include tech stack in description

# Use appropriate personas
/sc:analyze node-api/ --persona-backend
/sc:analyze react-ui/ --persona-frontend
```

#### Inconsistent Results

**Problem**: Same command produces different results at different times.

**Diagnosis**:
```bash
# Check what's auto-activating differently
/sc:command args --introspect

# Use explicit flags for consistency
/sc:analyze code/ --persona-analyzer --think --c7  # Explicit configuration
```

**Solutions**:
```bash
# Be more explicit about requirements
/sc:improve code/ --focus performance --persona-performance --safe-mode

# Use consistent flag patterns
/sc:analyze --think --c7     # Your standard thorough analysis
/sc:improve --safe-mode      # Your standard safe improvement
```

### Getting Help ğŸ†˜

#### When You're Stuck

**Self-Diagnosis Steps**:
1. Use `--introspect` to understand what SuperClaude is thinking
2. Try simpler versions of your command
3. Check auto-activation with explicit flags
4. Use `--help` on commands to see options

**Escalation Path**:
```bash
# Get framework help
/sc:troubleshoot "SuperClaude framework issues" --introspect

# Check documentation
/sc:help                    # Command overview
/sc:analyze --help          # Specific command help

# Test basic functionality
/sc:analyze README.md       # Simple test
/sc:build --help           # Check if commands work
```

#### Reporting Issues

When reporting problems, include:
- **Exact command used**: `/analyze code/ --think --c7`
- **Expected behavior**: "Should provide security analysis"
- **Actual behavior**: "Only provided basic code review"
- **Context**: "Working on Node.js authentication system"
- **SuperClaude version**: Check with `/help`

**Useful Debug Information**:
```bash
# Get diagnostic information
/sc:troubleshoot "describe your issue" --introspect --verbose
# â†’ Provides detailed context for bug reports
```

### Quick Reference for Common Problems ğŸ“‹

| Problem | Quick Fix | Command |
|---------|-----------|---------|
| Too slow | Reduce scope + compression | `--scope file --uc` |
| Wrong persona | Override explicitly | `--persona-security` |
| Too much output | Use compression | `--uc` |
| Risky changes | Use safety features | `--safe-mode --preview` |
| MCP not working | Force activation or disable | `--all-mcp` or `--no-mcp` |
| Inconsistent results | Use explicit flags | `--persona-x --think --c7` |
| Context issues | Load project context | `/load --deep` |
| Token limits | Enable compression + delegation | `--uc --delegate auto` |

Remember: When in doubt, start simple and add complexity gradually. Use `--introspect` to understand what SuperClaude is thinking, and don't hesitate to override auto-activation when you need specific behavior.

---

## What's Next ğŸ”®

SuperClaude v3.0 is fresh out of beta, and we're honest about what that means: it works pretty well for what it does, but there are rough edges and room for improvement. Here's what you can expect as the framework evolves.

### Current Limitations (Let's Be Honest) âš ï¸

#### Known Issues We're Working On

**Performance Optimization**
- Some operations are slower than we'd like, especially with all MCP servers active
- Token usage could be more efficient for large-scale operations  
- Memory usage spikes on very large codebases (>1000 files)

**MCP Server Integration**
- Server connections occasionally timeout or become unresponsive
- Error handling between MCP servers could be smoother
- Some advanced MCP features are experimental and may not work reliably

**Quality Gates**
- The 8-step validation process sometimes misses edge cases
- Quality metrics could be more granular and actionable
- Integration testing validation needs improvement

**Auto-Activation Intelligence**
- Persona selection occasionally misses context clues
- Flag auto-activation can be overly aggressive for simple tasks
- Pattern recognition works well for common scenarios but struggles with edge cases

#### What We Removed (And Why)

**Hooks System (Coming Back in v4)**
- The v2 hooks system became too complex and buggy
- Caused performance issues and unpredictable behavior
- Being redesigned from scratch with better architecture
- Will return in v4 with improved reliability and simpler configuration

**Some Advanced Commands**
- Consolidated 20+ commands down to 16 essential ones
- Removed experimental commands that weren't stable enough
- Focus on making core commands excellent rather than having many mediocre ones

### Short-Term Improvements (v3.x) ğŸ”§

Our immediate focus is making v3 stable and polished:

#### Performance Optimization (v3.1)
- **MCP Connection Pooling**: Reuse connections to reduce startup overhead
- **Intelligent Caching**: Cache MCP results and analysis outcomes
- **Token Optimization**: Better compression algorithms and smarter batching
- **Resource Management**: Better memory usage for large projects

**Expected Impact**: 30-50% performance improvement for common operations.

#### MCP Server Reliability (v3.2)  
- **Connection Resilience**: Better handling of MCP server timeouts and failures
- **Graceful Degradation**: Fallback strategies when servers are unavailable
- **Health Monitoring**: Real-time monitoring of MCP server status
- **Error Recovery**: Automatic retry and recovery mechanisms

**Expected Impact**: 80% reduction in MCP-related failures and timeouts.

#### Quality Gate Enhancement (v3.3)
- **Granular Metrics**: More specific and actionable quality measurements
- **Custom Validation**: User-configurable quality checks
- **Evidence Tracking**: Better documentation of validation outcomes
- **Integration Testing**: Improved validation of system-wide changes

**Expected Impact**: Higher confidence in automated improvements and better quality metrics.

### Medium-Term Evolution (v4.0) ğŸš€

The next major version will focus on intelligence and user experience:

#### Redesigned Hooks System
- **Event-Driven Architecture**: Clean separation between framework and hooks
- **Performance Optimized**: No impact on core operations when hooks aren't used
- **Simple Configuration**: Easy setup and debugging
- **Extensibility**: Community hooks and custom integrations

#### Enhanced AI Coordination
- **Smarter Auto-Activation**: Better context understanding and tool selection
- **Learning Patterns**: Framework learns from your successful workflows
- **Predictive Assistance**: Suggests next steps based on current context
- **Personalization**: Adapts to your coding style and preferences

#### Advanced Orchestration
- **Dynamic Resource Allocation**: Intelligent scaling based on operation complexity
- **Parallel Processing**: True parallelization for independent operations
- **Context Preservation**: Better memory of previous work within sessions
- **Workflow Templates**: Reusable patterns for common development scenarios

#### Extended MCP Ecosystem
- **More Servers**: Additional specialized capabilities (database, cloud, monitoring)
- **Community Servers**: Framework for community-contributed MCP servers
- **Server Marketplace**: Easy discovery and installation of new capabilities
- **Local Development**: Run MCP servers locally for better performance

### Long-Term Vision (v5.0+) ğŸŒŸ

Looking further ahead, we're exploring more ambitious improvements:

#### Intelligence and Automation
- **Contextual Understanding**: Deep comprehension of project goals and constraints
- **Proactive Assistance**: Suggestions based on code analysis and project patterns
- **Automated Workflows**: End-to-end automation for common development tasks
- **Code Evolution Tracking**: Understanding how your codebase changes over time

#### Team and Enterprise Features
- **Multi-Developer Coordination**: Team-aware analysis and recommendations
- **Project Memory**: Persistent understanding of project context across sessions
- **Policy Enforcement**: Automated enforcement of team coding standards
- **Analytics Dashboard**: Insights into development patterns and productivity

#### Platform Integration
- **IDE Deep Integration**: Native integration with popular development environments
- **CI/CD Pipeline Integration**: Automated quality checks and improvements in build processes
- **Cloud Development**: Integration with cloud development platforms
- **API Ecosystem**: Rich APIs for custom integrations and tooling

### How You Can Influence Development ğŸ“

#### Feedback and Usage Patterns
We actively monitor:
- **Command usage patterns**: Which commands are most/least useful
- **Flag combinations**: What combinations work well in practice
- **Error patterns**: Common failure modes and user confusion points
- **Performance bottlenecks**: Where users experience slowdowns

#### Community Involvement
- **GitHub Issues**: Bug reports and feature requests help prioritize development
- **Usage Examples**: Real-world usage examples inform our testing and optimization
- **Documentation Feedback**: Gaps in documentation highlight areas for improvement
- **Integration Requests**: Requests for specific tool/framework integrations guide MCP development

#### Beta Testing Program
- **Early Access**: Test new features before public release
- **Feedback Loop**: Direct input on experimental features
- **Performance Testing**: Help validate optimizations across different environments
- **Use Case Validation**: Ensure new features work for real development scenarios

### Staying Updated ğŸ“¡

#### How to Keep Current
```bash
# Check for updates regularly
/sc:help  # Shows current version and update availability

# Monitor development progress
# - GitHub releases: Feature announcements and changelogs
# - Documentation updates: New patterns and best practices
# - Community discussions: Tips and advanced usage patterns
```

#### Migration and Compatibility
- **Backwards Compatibility**: v3.x updates maintain command compatibility
- **Configuration Migration**: Automatic migration of settings between versions
- **Deprecation Warnings**: Advance notice of changing features
- **Migration Guides**: Step-by-step guides for major version upgrades

### Realistic Expectations ğŸ“Š

#### What to Expect from Updates
- **v3.x updates**: Bug fixes, performance improvements, stability enhancements
- **Major versions**: New features, architectural improvements, expanded capabilities
- **Community contributions**: Additional MCP servers, workflow patterns, integrations

#### What Not to Expect
- **Perfect AI**: SuperClaude will continue to have limitations and edge cases
- **One-Size-Fits-All**: Different projects and teams will need different approaches
- **Zero Learning Curve**: New features will require learning and experimentation
- **Magical Solutions**: Complex problems still require human expertise and judgment

### Contributing to SuperClaude ğŸ¤

#### Ways to Help
- **Bug Reports**: Detailed reports help improve stability and reliability
- **Feature Requests**: Real-world needs drive development priorities
- **Documentation**: Examples, guides, and clarifications help the community
- **Community Support**: Helping other users builds a stronger ecosystem

#### What We Value Most
- **Honest Feedback**: Both positive experiences and frustrations help improve the framework
- **Real-World Usage**: How SuperClaude works (or doesn't work) in actual development workflows
- **Specific Examples**: Concrete scenarios are more valuable than abstract feature requests
- **Patience**: Remember that v3.0 is fresh out of beta - improvement takes time

### The Bottom Line ğŸ¯

SuperClaude v3.0 is a solid foundation with room to grow. We're committed to:
- **Honest Communication**: No overpromising, clear about limitations and timelines
- **User-Driven Development**: Prioritizing features that solve real problems
- **Quality Over Features**: Making existing capabilities excellent before adding new ones
- **Community Focus**: Building a framework that serves the development community

We believe SuperClaude can become significantly more helpful for software development workflows, but it will take time, feedback, and iteration to get there. We appreciate your patience, feedback, and continued use as we improve the framework together.

**Want to stay involved?** Watch the GitHub repository, try new features when they're released, and let us know what works (and what doesn't) in your development workflows. Your real-world usage and feedback are what will make SuperClaude truly valuable for the development community.

---

## Conclusion ğŸ‰

You've now got a comprehensive understanding of SuperClaude v3.0 - its components, capabilities, and how to use them effectively. Let's wrap up with the key takeaways that will help you get the most out of the framework.

### Key Takeaways ğŸ¯

#### SuperClaude's Core Value
SuperClaude transforms Claude Code from a general-purpose AI assistant into a specialized development partner through:
- **15 specialized commands** that understand development workflows
- **11 expert personas** that bring domain-specific knowledge
- **Intelligent orchestration** that coordinates tools automatically
- **Quality-first approach** that maintains safety and reliability

#### The Power is in the Coordination
SuperClaude's power comes not from any single feature, but from how components work together:
- Commands usually activate appropriate personas and MCP servers
- Personas coordinate with each other for multi-domain problems
- The orchestrator optimizes tool selection and resource usage
- Quality gates ensure consistent, reliable outcomes

#### Start Simple, Scale Intelligently
The best approach to SuperClaude is progressive:
1. **Begin with basic commands** to understand core functionality
2. **Trust auto-activation** to learn optimal tool combinations
3. **Add manual control** when you need specific perspectives
4. **Experiment with advanced features** as your confidence grows

### What Makes SuperClaude Different ğŸŒŸ

#### Honest About Limitations
- We acknowledge v3.0 is fresh out of beta with rough edges
- We clearly document what works well vs. what's still experimental
- We prioritize reliability over flashy features
- We provide realistic timelines and expectations

#### Evidence-Based Development
- All recommendations backed by verifiable data
- Quality gates ensure changes don't break existing functionality
- Performance optimizations based on real usage patterns
- Continuous improvement driven by user feedback

#### Respectful of Your Workflow
- Enhances existing tools rather than replacing them
- Maintains compatibility with standard development practices
- Provides manual override for all automatic decisions
- Scales from simple tasks to complex enterprise scenarios

### Practical Next Steps ğŸ›£ï¸

#### For New Users
1. **Start with installation**: Follow the [Installation Guide](installation-guide.md)
2. **Try basic commands**: `/help`, `/analyze README.md`, `/build --help`
3. **Explore domain guides**: [Commands](commands-guide.md), [Flags](flags-guide.md), [Personas](personas-guide.md)
4. **Build confidence gradually**: Simple tasks â†’ complex workflows â†’ advanced features

#### For Experienced Users
1. **Optimize your workflows**: Identify flag combinations that work well for your needs
2. **Experiment with coordination**: Try different persona combinations on complex problems
3. **Contribute feedback**: Share what works (and what doesn't) in your environment
4. **Explore advanced features**: Wave orchestration, sub-agent delegation, introspection mode

### When to Use SuperClaude ğŸ¤”

#### SuperClaude Excels At
- **Development workflows**: Building, testing, deploying, documenting
- **Code analysis**: Quality assessment, security scanning, performance optimization
- **Learning and understanding**: Explaining complex systems, onboarding to new projects
- **Quality improvement**: Systematic refactoring, technical debt reduction
- **Multi-domain problems**: Issues requiring multiple types of expertise

#### When to Use Standard Claude Code
- **Simple questions**: Quick explanations that don't need specialized tools
- **Creative writing**: Non-technical content creation
- **General research**: Topics outside software development
- **Brainstorming**: Open-ended ideation without specific implementation needs

### The SuperClaude Philosophy ğŸ’­

#### Human-AI Collaboration
SuperClaude is designed to augment human expertise, not replace it:
- **You provide context and goals** - SuperClaude provides execution and expertise
- **You make decisions** - SuperClaude provides evidence and recommendations  
- **You understand your constraints** - SuperClaude respects and works within them
- **You own the outcomes** - SuperClaude helps you achieve better results

#### Continuous Improvement
The framework gets better through:
- **Usage patterns**: Learning what combinations work well in practice
- **User feedback**: Real-world experiences drive development priorities
- **Evidence-based optimization**: Data-driven improvements to tools and workflows
- **Community contributions**: Shared knowledge and best practices

### Looking Forward ğŸ”®

#### Short-Term (Next 6 Months)
- Performance optimizations making operations 30-50% faster
- Improved MCP server reliability reducing failures by 80%
- Enhanced quality gates providing more actionable feedback
- Better documentation based on user questions and feedback

#### Medium-Term (6-18 Months)  
- Redesigned hooks system with better architecture and performance
- Smarter auto-activation based on learning from usage patterns
- Extended MCP ecosystem with community-contributed servers
- Advanced orchestration with true parallel processing

#### Long-Term Vision
- Deep contextual understanding of projects and team workflows
- Proactive assistance based on code analysis and project patterns
- Team-aware features for collaborative development
- Rich integration ecosystem with IDEs, CI/CD, and cloud platforms

### Final Thoughts ğŸ‰

SuperClaude v3.0 represents a solid foundation for enhanced software development workflows. While it's not perfect and still has room for improvement, it demonstrates how AI can be thoughtfully integrated into development practices without disrupting existing workflows or replacing human expertise.

The framework succeeds when it makes you more productive, helps you learn new things, or catches issues you might have missed. It's designed to be a helpful colleague rather than a replacement for understanding your craft.

#### Thank You ğŸ™

Thanks for taking the time to understand SuperClaude thoroughly. Your thoughtful usage, honest feedback, and patience with rough edges are what will make this framework truly valuable for the development community.

Whether you use SuperClaude occasionally for specific tasks or integrate it deeply into your daily workflow, we hope it makes your development experience a bit better. And when it doesn't work as expected, please let us know - that feedback is invaluable for making improvements.

**Happy coding!** ğŸš€ We're excited to see what you build with SuperClaude as your development partner.

---

*Last updated: July 2024*  
*SuperClaude v3.0 User Guide*

*For questions, feedback, or contributions, visit our GitHub repository or join the community discussions. We're always happy to hear from users and learn about your experiences with the framework.*



================================================
FILE: profiles/__init__.py
================================================
[Empty file]


================================================
FILE: profiles/developer.json
================================================
{
  "name": "Developer Installation", 
  "description": "Full installation with all components including MCP servers",
  "components": [
    "core",
    "commands",
    "mcp"
  ],
  "features": {
    "auto_update": false,
    "backup_enabled": true,
    "validation_level": "comprehensive"
  },
  "target_users": ["developers", "power_users"],
  "estimated_time_minutes": 5,
  "disk_space_mb": 100
}


================================================
FILE: profiles/minimal.json
================================================
{
  "name": "Minimal Installation",
  "description": "Core framework files only",
  "components": [
    "core"
  ],
  "features": {
    "auto_update": false,
    "backup_enabled": true,
    "validation_level": "basic"
  },
  "target_users": ["testing", "basic"],
  "estimated_time_minutes": 1,
  "disk_space_mb": 20
}


================================================
FILE: profiles/quick.json
================================================
{
  "name": "Quick Installation",
  "description": "Recommended installation with core framework and essential components",
  "components": [
    "core",
    "commands"
  ],
  "features": {
    "auto_update": false,
    "backup_enabled": true,
    "validation_level": "standard"
  },
  "target_users": ["general", "developers"],
  "estimated_time_minutes": 2,
  "disk_space_mb": 50
}


================================================
FILE: setup/__init__.py
================================================
"""
SuperClaude Installation Suite
Pure Python installation system for SuperClaude framework
"""

__version__ = "3.0.0"
__author__ = "SuperClaude Team"

from pathlib import Path

# Core paths
SETUP_DIR = Path(__file__).parent
PROJECT_ROOT = SETUP_DIR.parent
CONFIG_DIR = PROJECT_ROOT / "config"
PROFILES_DIR = PROJECT_ROOT / "profiles"

# Installation target
DEFAULT_INSTALL_DIR = Path.home() / ".claude"


================================================
FILE: setup/base/__init__.py
================================================
"""Base classes for SuperClaude installation system"""

from .component import Component
from .installer import Installer

__all__ = ['Component', 'Installer']


================================================
FILE: setup/base/component.py
================================================
"""
Abstract base class for installable components
"""

from abc import ABC, abstractmethod
from typing import List, Dict, Tuple, Optional, Any
from pathlib import Path
import json


class Component(ABC):
    """Base class for all installable components"""
    
    def __init__(self, install_dir: Optional[Path] = None):
        """
        Initialize component with installation directory
        
        Args:
            install_dir: Target installation directory (defaults to ~/.claude)
        """
        from .. import DEFAULT_INSTALL_DIR
        self.install_dir = install_dir or DEFAULT_INSTALL_DIR
        self._metadata = None
        self._dependencies = None
        self._files_to_install = None
        self._settings_modifications = None
    
    @abstractmethod
    def get_metadata(self) -> Dict[str, str]:
        """
        Return component metadata
        
        Returns:
            Dict containing:
                - name: Component name
                - version: Component version
                - description: Component description
                - category: Component category (core, command, integration, etc.)
        """
        pass
    
    @abstractmethod
    def validate_prerequisites(self) -> Tuple[bool, List[str]]:
        """
        Check prerequisites for this component
        
        Returns:
            Tuple of (success: bool, error_messages: List[str])
        """
        pass
    
    @abstractmethod
    def get_files_to_install(self) -> List[Tuple[Path, Path]]:
        """
        Return list of files to install
        
        Returns:
            List of tuples (source_path, target_path)
        """
        pass
    
    @abstractmethod
    def get_settings_modifications(self) -> Dict[str, Any]:
        """
        Return settings.json modifications to apply
        
        Returns:
            Dict of settings to merge into settings.json
        """
        pass
    
    @abstractmethod
    def install(self, config: Dict[str, Any]) -> bool:
        """
        Perform component-specific installation logic
        
        Args:
            config: Installation configuration
            
        Returns:
            True if successful, False otherwise
        """
        pass
    
    @abstractmethod
    def uninstall(self) -> bool:
        """
        Remove component
        
        Returns:
            True if successful, False otherwise
        """
        pass
    
    @abstractmethod
    def get_dependencies(self) -> List[str]:
        """
        Return list of component dependencies
        
        Returns:
            List of component names this component depends on
        """
        pass
    
    def update(self, config: Dict[str, Any]) -> bool:
        """
        Update component (default: uninstall then install)
        
        Args:
            config: Installation configuration
            
        Returns:
            True if successful, False otherwise
        """
        # Default implementation: uninstall and reinstall
        if self.uninstall():
            return self.install(config)
        return False
    
    def get_installed_version(self) -> Optional[str]:
        """
        Get currently installed version of component
        
        Returns:
            Version string if installed, None otherwise
        """
        settings_file = self.install_dir / "settings.json"
        if settings_file.exists():
            try:
                with open(settings_file, 'r') as f:
                    settings = json.load(f)
                component_name = self.get_metadata()['name']
                return settings.get('components', {}).get(component_name, {}).get('version')
            except Exception:
                pass
        return None
    
    def is_installed(self) -> bool:
        """
        Check if component is installed
        
        Returns:
            True if installed, False otherwise
        """
        return self.get_installed_version() is not None
    
    def validate_installation(self) -> Tuple[bool, List[str]]:
        """
        Validate that component is correctly installed
        
        Returns:
            Tuple of (success: bool, error_messages: List[str])
        """
        errors = []
        
        # Check if all files exist
        for _, target in self.get_files_to_install():
            if not target.exists():
                errors.append(f"Missing file: {target}")
        
        # Check version in settings
        if not self.get_installed_version():
            errors.append("Component not registered in settings.json")
        
        return len(errors) == 0, errors
    
    def get_size_estimate(self) -> int:
        """
        Estimate installed size in bytes
        
        Returns:
            Estimated size in bytes
        """
        total_size = 0
        for source, _ in self.get_files_to_install():
            if source.exists():
                if source.is_file():
                    total_size += source.stat().st_size
                elif source.is_dir():
                    total_size += sum(f.stat().st_size for f in source.rglob('*') if f.is_file())
        return total_size
    
    def __str__(self) -> str:
        """String representation of component"""
        metadata = self.get_metadata()
        return f"{metadata['name']} v{metadata['version']}"
    
    def __repr__(self) -> str:
        """Developer representation of component"""
        return f"<{self.__class__.__name__}({self.get_metadata()['name']})>"


================================================
FILE: setup/base/installer.py
================================================
"""
Base installer logic for SuperClaude installation system
"""

from typing import List, Dict, Optional, Set, Tuple, Any
from pathlib import Path
import json
import shutil
import tempfile
from datetime import datetime
from .component import Component


class Installer:
    """Main installer orchestrator"""
    
    def __init__(self, install_dir: Optional[Path] = None, dry_run: bool = False):
        """
        Initialize installer
        
        Args:
            install_dir: Target installation directory
            dry_run: If True, only simulate installation
        """
        from .. import DEFAULT_INSTALL_DIR
        self.install_dir = install_dir or DEFAULT_INSTALL_DIR
        self.dry_run = dry_run
        self.components: Dict[str, Component] = {}
        self.installed_components: Set[str] = set()
        self.failed_components: Set[str] = set()
        self.skipped_components: Set[str] = set()
        self.backup_path: Optional[Path] = None
        
    def register_component(self, component: Component) -> None:
        """
        Register a component for installation
        
        Args:
            component: Component instance to register
        """
        metadata = component.get_metadata()
        self.components[metadata['name']] = component
        
    def register_components(self, components: List[Component]) -> None:
        """
        Register multiple components
        
        Args:
            components: List of component instances
        """
        for component in components:
            self.register_component(component)
    
    def resolve_dependencies(self, component_names: List[str]) -> List[str]:
        """
        Resolve component dependencies in correct installation order
        
        Args:
            component_names: List of component names to install
            
        Returns:
            Ordered list of component names including dependencies
            
        Raises:
            ValueError: If circular dependencies detected or unknown component
        """
        resolved = []
        resolving = set()
        
        def resolve(name: str):
            if name in resolved:
                return
                
            if name in resolving:
                raise ValueError(f"Circular dependency detected involving {name}")
                
            if name not in self.components:
                raise ValueError(f"Unknown component: {name}")
                
            resolving.add(name)
            
            # Resolve dependencies first
            for dep in self.components[name].get_dependencies():
                resolve(dep)
                
            resolving.remove(name)
            resolved.append(name)
        
        # Resolve each requested component
        for name in component_names:
            resolve(name)
            
        return resolved
    
    def validate_system_requirements(self) -> Tuple[bool, List[str]]:
        """
        Validate system requirements for all registered components
        
        Returns:
            Tuple of (success: bool, error_messages: List[str])
        """
        errors = []
        
        # Check disk space (500MB minimum)
        try:
            stat = shutil.disk_usage(self.install_dir.parent)
            free_mb = stat.free / (1024 * 1024)
            if free_mb < 500:
                errors.append(f"Insufficient disk space: {free_mb:.1f}MB free (500MB required)")
        except Exception as e:
            errors.append(f"Could not check disk space: {e}")
        
        # Check write permissions
        test_file = self.install_dir / ".write_test"
        try:
            self.install_dir.mkdir(parents=True, exist_ok=True)
            test_file.touch()
            test_file.unlink()
        except Exception as e:
            errors.append(f"No write permission to {self.install_dir}: {e}")
        
        return len(errors) == 0, errors
    
    def create_backup(self) -> Optional[Path]:
        """
        Create backup of existing installation
        
        Returns:
            Path to backup archive or None if no existing installation
        """
        if not self.install_dir.exists():
            return None
            
        if self.dry_run:
            return self.install_dir / "backup_dryrun.tar.gz"
            
        # Create backup directory
        backup_dir = self.install_dir / "backups"
        backup_dir.mkdir(exist_ok=True)
        
        # Create timestamped backup
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_name = f"superclaude_backup_{timestamp}"
        backup_path = backup_dir / f"{backup_name}.tar.gz"
        
        # Create temporary directory for backup
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_backup = Path(temp_dir) / backup_name
            
            # Ensure temp backup directory exists
            temp_backup.mkdir(parents=True, exist_ok=True)
            
            # Copy all files except backups directory
            for item in self.install_dir.iterdir():
                if item.name != "backups":
                    try:
                        if item.is_file():
                            shutil.copy2(item, temp_backup / item.name)
                        elif item.is_dir():
                            shutil.copytree(item, temp_backup / item.name)
                    except Exception as e:
                        # Log warning but continue backup process
                        print(f"Warning: Could not backup {item.name}: {e}")
            
            # Create archive only if there are files to backup
            if any(temp_backup.iterdir()):
                shutil.make_archive(
                    backup_path.with_suffix(''),
                    'gztar',
                    temp_dir,
                    backup_name
                )
            else:
                # Create empty backup file to indicate backup was attempted
                backup_path.touch()
                print(f"Warning: No files to backup, created empty backup marker: {backup_path.name}")
        
        self.backup_path = backup_path
        return backup_path
    
    def install_component(self, component_name: str, config: Dict[str, Any]) -> bool:
        """
        Install a single component
        
        Args:
            component_name: Name of component to install
            config: Installation configuration
            
        Returns:
            True if successful, False otherwise
        """
        if component_name not in self.components:
            raise ValueError(f"Unknown component: {component_name}")
            
        component = self.components[component_name]
        
        # Skip if already installed
        if component_name in self.installed_components:
            return True
            
        # Check prerequisites
        success, errors = component.validate_prerequisites()
        if not success:
            print(f"Prerequisites failed for {component_name}:")
            for error in errors:
                print(f"  - {error}")
            self.failed_components.add(component_name)
            return False
        
        # Perform installation
        try:
            if self.dry_run:
                print(f"[DRY RUN] Would install {component_name}")
                success = True
            else:
                success = component.install(config)
                
            if success:
                self.installed_components.add(component_name)
                # Component handles its own metadata registration
            else:
                self.failed_components.add(component_name)
                
            return success
            
        except Exception as e:
            print(f"Error installing {component_name}: {e}")
            self.failed_components.add(component_name)
            return False
    
    def install_components(self, component_names: List[str], config: Optional[Dict[str, Any]] = None) -> bool:
        """
        Install multiple components in dependency order
        
        Args:
            component_names: List of component names to install
            config: Installation configuration
            
        Returns:
            True if all successful, False if any failed
        """
        config = config or {}
        
        # Resolve dependencies
        try:
            ordered_names = self.resolve_dependencies(component_names)
        except ValueError as e:
            print(f"Dependency resolution error: {e}")
            return False
        
        # Validate system requirements
        success, errors = self.validate_system_requirements()
        if not success:
            print("System requirements not met:")
            for error in errors:
                print(f"  - {error}")
            return False
        
        # Create backup if updating
        if self.install_dir.exists() and not self.dry_run:
            print("Creating backup of existing installation...")
            self.create_backup()
        
        # Install each component
        all_success = True
        for name in ordered_names:
            print(f"\nInstalling {name}...")
            if not self.install_component(name, config):
                all_success = False
                # Continue installing other components even if one fails
        
        # Post-installation validation
        if all_success and not self.dry_run:
            self._run_post_install_validation()
        
        return all_success
    
    def uninstall_component(self, component_name: str) -> bool:
        """
        Uninstall a single component
        
        Args:
            component_name: Name of component to uninstall
            
        Returns:
            True if successful, False otherwise
        """
        if component_name not in self.components:
            raise ValueError(f"Unknown component: {component_name}")
            
        component = self.components[component_name]
        
        try:
            if self.dry_run:
                print(f"[DRY RUN] Would uninstall {component_name}")
                return True
            else:
                success = component.uninstall()
                # Component handles its own metadata removal
                return success
        except Exception as e:
            print(f"Error uninstalling {component_name}: {e}")
            return False
    
    def _update_settings_registry(self, component: Component) -> None:
        """Update settings.json with component registration"""
        if self.dry_run:
            return
            
        settings_file = self.install_dir / "settings.json"
        settings = {}
        
        if settings_file.exists():
            with open(settings_file, 'r') as f:
                settings = json.load(f)
        
        # Update components registry
        if 'components' not in settings:
            settings['components'] = {}
            
        metadata = component.get_metadata()
        settings['components'][metadata['name']] = {
            'version': metadata['version'],
            'installed_at': datetime.now().isoformat(),
            'category': metadata.get('category', 'unknown')
        }
        
        # Update framework.components array for operation compatibility
        if 'framework' not in settings:
            settings['framework'] = {}
        if 'components' not in settings['framework']:
            settings['framework']['components'] = []
        
        # Add component to framework.components if not already present
        component_name = metadata['name']
        if component_name not in settings['framework']['components']:
            settings['framework']['components'].append(component_name)
        
        # Save settings
        settings_file.parent.mkdir(parents=True, exist_ok=True)
        with open(settings_file, 'w') as f:
            json.dump(settings, f, indent=2)
    
    def _remove_from_settings_registry(self, component_name: str) -> None:
        """Remove component from settings.json registry"""
        if self.dry_run:
            return
            
        settings_file = self.install_dir / "settings.json"
        if not settings_file.exists():
            return
            
        with open(settings_file, 'r') as f:
            settings = json.load(f)
        
        # Remove from components registry
        if 'components' in settings and component_name in settings['components']:
            del settings['components'][component_name]
        
        # Remove from framework.components array for operation compatibility
        if 'framework' in settings and 'components' in settings['framework']:
            if component_name in settings['framework']['components']:
                settings['framework']['components'].remove(component_name)
            
        with open(settings_file, 'w') as f:
            json.dump(settings, f, indent=2)
    
    def _run_post_install_validation(self) -> None:
        """Run post-installation validation for all installed components"""
        print("\nRunning post-installation validation...")
        
        all_valid = True
        for name in self.installed_components:
            component = self.components[name]
            success, errors = component.validate_installation()
            
            if success:
                print(f"  âœ“ {name}: Valid")
            else:
                print(f"  âœ— {name}: Invalid")
                for error in errors:
                    print(f"    - {error}")
                all_valid = False
        
        if all_valid:
            print("\nAll components validated successfully!")
        else:
            print("\nSome components failed validation. Check errors above.")
    
    def get_installation_summary(self) -> Dict[str, Any]:
        """
        Get summary of installation results
        
        Returns:
            Dict with installation statistics and results
        """
        return {
            'installed': list(self.installed_components),
            'failed': list(self.failed_components),
            'skipped': list(self.skipped_components),
            'backup_path': str(self.backup_path) if self.backup_path else None,
            'install_dir': str(self.install_dir),
            'dry_run': self.dry_run
        }


================================================
FILE: setup/components/__init__.py
================================================
"""Component implementations for SuperClaude installation system"""

from .core import CoreComponent
from .commands import CommandsComponent
from .mcp import MCPComponent
from .hooks import HooksComponent

__all__ = [
    'CoreComponent',
    'CommandsComponent', 
    'MCPComponent',
    'HooksComponent'
]


================================================
FILE: setup/components/commands.py
================================================
"""
Commands component for SuperClaude slash command definitions
"""

from typing import Dict, List, Tuple, Any
from pathlib import Path

from ..base.component import Component
from ..core.file_manager import FileManager
from ..core.settings_manager import SettingsManager
from ..utils.security import SecurityValidator
from ..utils.logger import get_logger


class CommandsComponent(Component):
    """SuperClaude slash commands component"""
    
    def __init__(self, install_dir: Path = None):
        """Initialize commands component"""
        super().__init__(install_dir)
        self.logger = get_logger()
        self.file_manager = FileManager()
        self.settings_manager = SettingsManager(self.install_dir)
        
        # Dynamically discover command files to install
        self.command_files = self._discover_command_files()
    
    def get_metadata(self) -> Dict[str, str]:
        """Get component metadata"""
        return {
            "name": "commands",
            "version": "3.0.0",
            "description": "SuperClaude slash command definitions",
            "category": "commands"
        }
    
    def validate_prerequisites(self) -> Tuple[bool, List[str]]:
        """Check prerequisites"""
        errors = []
        
        # Check if we have read access to source files
        source_dir = self._get_source_dir()
        if not source_dir.exists():
            errors.append(f"Source directory not found: {source_dir}")
            return False, errors
        
        # Check if all required command files exist
        missing_files = []
        for filename in self.command_files:
            source_file = source_dir / filename
            if not source_file.exists():
                missing_files.append(filename)
        
        if missing_files:
            errors.append(f"Missing command files: {missing_files}")
        
        # Check write permissions to install directory
        commands_dir = self.install_dir / "commands" / "sc"
        has_perms, missing = SecurityValidator.check_permissions(
            self.install_dir, {'write'}
        )
        if not has_perms:
            errors.append(f"No write permissions to {self.install_dir}: {missing}")
        
        # Validate installation target
        is_safe, validation_errors = SecurityValidator.validate_installation_target(commands_dir)
        if not is_safe:
            errors.extend(validation_errors)
        
        return len(errors) == 0, errors
    
    def get_files_to_install(self) -> List[Tuple[Path, Path]]:
        """Get files to install"""
        source_dir = self._get_source_dir()
        files = []
        
        for filename in self.command_files:
            source = source_dir / filename
            target = self.install_dir / "commands" / "sc" / filename
            files.append((source, target))
        
        return files
    
    def get_metadata_modifications(self) -> Dict[str, Any]:
        """Get metadata modifications for commands component"""
        return {
            "components": {
                "commands": {
                    "version": "3.0.0",
                    "installed": True,
                    "files_count": len(self.command_files)
                }
            }
        }
    
    def get_settings_modifications(self) -> Dict[str, Any]:
        """Get settings.json modifications (now only Claude Code compatible settings)"""
        # Return empty dict as we don't modify Claude Code settings
        return {}
    
    def install(self, config: Dict[str, Any]) -> bool:
        """Install commands component"""
        try:
            self.logger.info("Installing SuperClaude command definitions...")
            
            # Check for and migrate existing commands from old location
            self._migrate_existing_commands()
            
            # Validate installation
            success, errors = self.validate_prerequisites()
            if not success:
                for error in errors:
                    self.logger.error(error)
                return False
            
            # Get files to install
            files_to_install = self.get_files_to_install()
            
            # Validate all files for security
            source_dir = self._get_source_dir()
            commands_dir = self.install_dir / "commands" / "sc"
            is_safe, security_errors = SecurityValidator.validate_component_files(
                files_to_install, source_dir, commands_dir
            )
            if not is_safe:
                for error in security_errors:
                    self.logger.error(f"Security validation failed: {error}")
                return False
            
            # Ensure commands directory exists
            if not self.file_manager.ensure_directory(commands_dir):
                self.logger.error(f"Could not create commands directory: {commands_dir}")
                return False
            
            # Copy command files
            success_count = 0
            for source, target in files_to_install:
                self.logger.debug(f"Copying {source.name} to {target}")
                
                if self.file_manager.copy_file(source, target):
                    success_count += 1
                    self.logger.debug(f"Successfully copied {source.name}")
                else:
                    self.logger.error(f"Failed to copy {source.name}")
            
            if success_count != len(files_to_install):
                self.logger.error(f"Only {success_count}/{len(files_to_install)} command files copied successfully")
                return False
            
            # Update metadata
            try:
                # Add component registration to metadata
                self.settings_manager.add_component_registration("commands", {
                    "version": "3.0.0",
                    "category": "commands",
                    "files_count": len(self.command_files)
                })
                self.logger.info("Updated metadata with commands component registration")
            except Exception as e:
                self.logger.error(f"Failed to update metadata: {e}")
                return False
            
            self.logger.success(f"Commands component installed successfully ({success_count} command files)")
            return True
            
        except Exception as e:
            self.logger.exception(f"Unexpected error during commands installation: {e}")
            return False
    
    def uninstall(self) -> bool:
        """Uninstall commands component"""
        try:
            self.logger.info("Uninstalling SuperClaude commands component...")
            
            # Remove command files from sc subdirectory
            commands_dir = self.install_dir / "commands" / "sc"
            removed_count = 0
            
            for filename in self.command_files:
                file_path = commands_dir / filename
                if self.file_manager.remove_file(file_path):
                    removed_count += 1
                    self.logger.debug(f"Removed {filename}")
                else:
                    self.logger.warning(f"Could not remove {filename}")
            
            # Also check and remove any old commands in root commands directory
            old_commands_dir = self.install_dir / "commands"
            old_removed_count = 0
            
            for filename in self.command_files:
                old_file_path = old_commands_dir / filename
                if old_file_path.exists() and old_file_path.is_file():
                    if self.file_manager.remove_file(old_file_path):
                        old_removed_count += 1
                        self.logger.debug(f"Removed old {filename}")
                    else:
                        self.logger.warning(f"Could not remove old {filename}")
            
            if old_removed_count > 0:
                self.logger.info(f"Also removed {old_removed_count} commands from old location")
            
            removed_count += old_removed_count
            
            # Remove sc subdirectory if empty
            try:
                if commands_dir.exists():
                    remaining_files = list(commands_dir.iterdir())
                    if not remaining_files:
                        commands_dir.rmdir()
                        self.logger.debug("Removed empty sc commands directory")
                        
                        # Also remove parent commands directory if empty
                        parent_commands_dir = self.install_dir / "commands"
                        if parent_commands_dir.exists():
                            remaining_files = list(parent_commands_dir.iterdir())
                            if not remaining_files:
                                parent_commands_dir.rmdir()
                                self.logger.debug("Removed empty parent commands directory")
            except Exception as e:
                self.logger.warning(f"Could not remove commands directory: {e}")
            
            # Update metadata to remove commands component
            try:
                if self.settings_manager.is_component_installed("commands"):
                    self.settings_manager.remove_component_registration("commands")
                    self.logger.info("Removed commands component from metadata")
            except Exception as e:
                self.logger.warning(f"Could not update metadata: {e}")
            
            self.logger.success(f"Commands component uninstalled ({removed_count} files removed)")
            return True
            
        except Exception as e:
            self.logger.exception(f"Unexpected error during commands uninstallation: {e}")
            return False
    
    def get_dependencies(self) -> List[str]:
        """Get dependencies"""
        return ["core"]
    
    def update(self, config: Dict[str, Any]) -> bool:
        """Update commands component"""
        try:
            self.logger.info("Updating SuperClaude commands component...")
            
            # Check current version
            current_version = self.settings_manager.get_component_version("commands")
            target_version = self.get_metadata()["version"]
            
            if current_version == target_version:
                self.logger.info(f"Commands component already at version {target_version}")
                return True
            
            self.logger.info(f"Updating commands component from {current_version} to {target_version}")
            
            # Create backup of existing command files
            commands_dir = self.install_dir / "commands" / "sc"
            backup_files = []
            
            if commands_dir.exists():
                for filename in self.command_files:
                    file_path = commands_dir / filename
                    if file_path.exists():
                        backup_path = self.file_manager.backup_file(file_path)
                        if backup_path:
                            backup_files.append(backup_path)
                            self.logger.debug(f"Backed up {filename}")
            
            # Perform installation (overwrites existing files)
            success = self.install(config)
            
            if success:
                # Remove backup files on successful update
                for backup_path in backup_files:
                    try:
                        backup_path.unlink()
                    except Exception:
                        pass  # Ignore cleanup errors
                
                self.logger.success(f"Commands component updated to version {target_version}")
            else:
                # Restore from backup on failure
                self.logger.warning("Update failed, restoring from backup...")
                for backup_path in backup_files:
                    try:
                        original_path = backup_path.with_suffix('')
                        backup_path.rename(original_path)
                        self.logger.debug(f"Restored {original_path.name}")
                    except Exception as e:
                        self.logger.error(f"Could not restore {backup_path}: {e}")
            
            return success
            
        except Exception as e:
            self.logger.exception(f"Unexpected error during commands update: {e}")
            return False
    
    def validate_installation(self) -> Tuple[bool, List[str]]:
        """Validate commands component installation"""
        errors = []
        
        # Check if sc commands directory exists
        commands_dir = self.install_dir / "commands" / "sc"
        if not commands_dir.exists():
            errors.append("SC commands directory not found")
            return False, errors
        
        # Check if all command files exist
        for filename in self.command_files:
            file_path = commands_dir / filename
            if not file_path.exists():
                errors.append(f"Missing command file: {filename}")
            elif not file_path.is_file():
                errors.append(f"Command file is not a regular file: {filename}")
        
        # Check metadata registration
        if not self.settings_manager.is_component_installed("commands"):
            errors.append("Commands component not registered in metadata")
        else:
            # Check version matches
            installed_version = self.settings_manager.get_component_version("commands")
            expected_version = self.get_metadata()["version"]
            if installed_version != expected_version:
                errors.append(f"Version mismatch: installed {installed_version}, expected {expected_version}")
        
        return len(errors) == 0, errors
    
    def _discover_command_files(self) -> List[str]:
        """
        Dynamically discover command .md files in the Commands directory
        
        Returns:
            List of command filenames (e.g., ['analyze.md', 'build.md', ...])
        """
        return self._discover_files_in_directory(
            self._get_source_dir(),
            extension='.md',
            exclude_patterns=['README.md', 'CHANGELOG.md', 'LICENSE.md']
        )
    
    def _discover_files_in_directory(self, directory: Path, extension: str = '.md', 
                                   exclude_patterns: List[str] = None) -> List[str]:
        """
        Shared utility for discovering files in a directory
        
        Args:
            directory: Directory to scan
            extension: File extension to look for (default: '.md')
            exclude_patterns: List of filename patterns to exclude
            
        Returns:
            List of filenames found in the directory
        """
        if exclude_patterns is None:
            exclude_patterns = []
        
        try:
            if not directory.exists():
                self.logger.warning(f"Source directory not found: {directory}")
                return []
            
            if not directory.is_dir():
                self.logger.warning(f"Source path is not a directory: {directory}")
                return []
            
            # Discover files with the specified extension
            files = []
            for file_path in directory.iterdir():
                if (file_path.is_file() and 
                    file_path.suffix.lower() == extension.lower() and
                    file_path.name not in exclude_patterns):
                    files.append(file_path.name)
            
            # Sort for consistent ordering
            files.sort()
            
            self.logger.debug(f"Discovered {len(files)} {extension} files in {directory}")
            if files:
                self.logger.debug(f"Files found: {files}")
            
            return files
            
        except PermissionError:
            self.logger.error(f"Permission denied accessing directory: {directory}")
            return []
        except Exception as e:
            self.logger.error(f"Error discovering files in {directory}: {e}")
            return []

    def _get_source_dir(self) -> Path:
        """Get source directory for command files"""
        # Assume we're in SuperClaude/setup/components/commands.py
        # and command files are in SuperClaude/SuperClaude/Commands/
        project_root = Path(__file__).parent.parent.parent
        return project_root / "SuperClaude" / "Commands"
    
    def get_size_estimate(self) -> int:
        """Get estimated installation size"""
        total_size = 0
        source_dir = self._get_source_dir()
        
        for filename in self.command_files:
            file_path = source_dir / filename
            if file_path.exists():
                total_size += file_path.stat().st_size
        
        # Add overhead for directory and settings
        total_size += 5120  # ~5KB overhead
        
        return total_size
    
    def get_installation_summary(self) -> Dict[str, Any]:
        """Get installation summary"""
        return {
            "component": self.get_metadata()["name"],
            "version": self.get_metadata()["version"],
            "files_installed": len(self.command_files),
            "command_files": self.command_files,
            "estimated_size": self.get_size_estimate(),
            "install_directory": str(self.install_dir / "commands" / "sc"),
            "dependencies": self.get_dependencies()
        }
    
    def _migrate_existing_commands(self) -> None:
        """Migrate existing commands from old location to new sc subdirectory"""
        try:
            old_commands_dir = self.install_dir / "commands"
            new_commands_dir = self.install_dir / "commands" / "sc"
            
            # Check if old commands exist in root commands directory
            migrated_count = 0
            commands_to_migrate = []
            
            if old_commands_dir.exists():
                for filename in self.command_files:
                    old_file_path = old_commands_dir / filename
                    if old_file_path.exists() and old_file_path.is_file():
                        commands_to_migrate.append(filename)
            
            if commands_to_migrate:
                self.logger.info(f"Found {len(commands_to_migrate)} existing commands to migrate to sc/ subdirectory")
                
                # Ensure new directory exists
                if not self.file_manager.ensure_directory(new_commands_dir):
                    self.logger.error(f"Could not create sc commands directory: {new_commands_dir}")
                    return
                
                # Move files from old to new location
                for filename in commands_to_migrate:
                    old_file_path = old_commands_dir / filename
                    new_file_path = new_commands_dir / filename
                    
                    try:
                        # Copy file to new location
                        if self.file_manager.copy_file(old_file_path, new_file_path):
                            # Remove old file
                            if self.file_manager.remove_file(old_file_path):
                                migrated_count += 1
                                self.logger.debug(f"Migrated {filename} to sc/ subdirectory")
                            else:
                                self.logger.warning(f"Could not remove old {filename}")
                        else:
                            self.logger.warning(f"Could not copy {filename} to sc/ subdirectory")
                    except Exception as e:
                        self.logger.warning(f"Error migrating {filename}: {e}")
                
                if migrated_count > 0:
                    self.logger.success(f"Successfully migrated {migrated_count} commands to /sc: namespace")
                    self.logger.info("Commands are now available as /sc:analyze, /sc:build, etc.")
                    
                    # Try to remove old commands directory if empty
                    try:
                        if old_commands_dir.exists():
                            remaining_files = [f for f in old_commands_dir.iterdir() if f.is_file()]
                            if not remaining_files:
                                # Only remove if no user files remain
                                old_commands_dir.rmdir()
                                self.logger.debug("Removed empty old commands directory")
                    except Exception as e:
                        self.logger.debug(f"Could not remove old commands directory: {e}")
                        
        except Exception as e:
            self.logger.warning(f"Error during command migration: {e}")



================================================
FILE: setup/components/core.py
================================================
"""
Core component for SuperClaude framework files installation
"""

from typing import Dict, List, Tuple, Any
from pathlib import Path
import json
import shutil

from ..base.component import Component
from ..core.file_manager import FileManager
from ..core.settings_manager import SettingsManager
from ..utils.security import SecurityValidator
from ..utils.logger import get_logger


class CoreComponent(Component):
    """Core SuperClaude framework files component"""
    
    def __init__(self, install_dir: Path = None):
        """Initialize core component"""
        super().__init__(install_dir)
        self.logger = get_logger()
        self.file_manager = FileManager()
        self.settings_manager = SettingsManager(self.install_dir)
        
        # Dynamically discover framework files to install
        self.framework_files = self._discover_framework_files()
    
    def get_metadata(self) -> Dict[str, str]:
        """Get component metadata"""
        return {
            "name": "core",
            "version": "3.0.0",
            "description": "SuperClaude framework documentation and core files",
            "category": "core"
        }
    
    def validate_prerequisites(self) -> Tuple[bool, List[str]]:
        """Check prerequisites for core component"""
        errors = []
        
        # Check if we have read access to source files
        source_dir = self._get_source_dir()
        if not source_dir.exists():
            errors.append(f"Source directory not found: {source_dir}")
            return False, errors
        
        # Check if all required framework files exist
        missing_files = []
        for filename in self.framework_files:
            source_file = source_dir / filename
            if not source_file.exists():
                missing_files.append(filename)
        
        if missing_files:
            errors.append(f"Missing framework files: {missing_files}")
        
        # Check write permissions to install directory
        has_perms, missing = SecurityValidator.check_permissions(
            self.install_dir, {'write'}
        )
        if not has_perms:
            errors.append(f"No write permissions to {self.install_dir}: {missing}")
        
        # Validate installation target
        is_safe, validation_errors = SecurityValidator.validate_installation_target(self.install_dir)
        if not is_safe:
            errors.extend(validation_errors)
        
        return len(errors) == 0, errors
    
    def get_files_to_install(self) -> List[Tuple[Path, Path]]:
        """Get list of files to install"""
        source_dir = self._get_source_dir()
        files = []
        
        for filename in self.framework_files:
            source = source_dir / filename
            target = self.install_dir / filename
            files.append((source, target))
        
        return files
    
    def get_metadata_modifications(self) -> Dict[str, Any]:
        """Get metadata modifications for SuperClaude"""
        return {
            "framework": {
                "version": "3.0.0",
                "name": "SuperClaude",
                "description": "AI-enhanced development framework for Claude Code",
                "installation_type": "global",
                "components": ["core"]
            },
            "superclaude": {
                "enabled": True,
                "version": "3.0.0",
                "profile": "default",
                "auto_update": False
            }
        }
    
    def get_settings_modifications(self) -> Dict[str, Any]:
        """Get settings.json modifications (now only Claude Code compatible settings)"""
        # Return empty dict as we don't modify Claude Code settings
        return {}
    
    def install(self, config: Dict[str, Any]) -> bool:
        """Install core component"""
        try:
            self.logger.info("Installing SuperClaude core framework files...")
            
            # Validate installation
            success, errors = self.validate_prerequisites()
            if not success:
                for error in errors:
                    self.logger.error(error)
                return False
            
            # Get files to install
            files_to_install = self.get_files_to_install()
            
            # Validate all files for security
            source_dir = self._get_source_dir()
            is_safe, security_errors = SecurityValidator.validate_component_files(
                files_to_install, source_dir, self.install_dir
            )
            if not is_safe:
                for error in security_errors:
                    self.logger.error(f"Security validation failed: {error}")
                return False
            
            # Ensure install directory exists
            if not self.file_manager.ensure_directory(self.install_dir):
                self.logger.error(f"Could not create install directory: {self.install_dir}")
                return False
            
            # Copy framework files
            success_count = 0
            for source, target in files_to_install:
                self.logger.debug(f"Copying {source.name} to {target}")
                
                if self.file_manager.copy_file(source, target):
                    success_count += 1
                    self.logger.debug(f"Successfully copied {source.name}")
                else:
                    self.logger.error(f"Failed to copy {source.name}")
            
            if success_count != len(files_to_install):
                self.logger.error(f"Only {success_count}/{len(files_to_install)} files copied successfully")
                return False
            
            # Create or update metadata
            try:
                metadata_mods = self.get_metadata_modifications()
                # Update metadata directly
                existing_metadata = self.settings_manager.load_metadata()
                merged_metadata = self.settings_manager._deep_merge(existing_metadata, metadata_mods)
                self.settings_manager.save_metadata(merged_metadata)
                self.logger.info("Updated metadata with framework configuration")
                
                # Add component registration to metadata
                self.settings_manager.add_component_registration("core", {
                    "version": "3.0.0",
                    "category": "core",
                    "files_count": len(self.framework_files)
                })
                self.logger.info("Updated metadata with core component registration")
                
                # Migrate any existing SuperClaude data from settings.json
                if self.settings_manager.migrate_superclaude_data():
                    self.logger.info("Migrated existing SuperClaude data from settings.json")
            except Exception as e:
                self.logger.error(f"Failed to update metadata: {e}")
                return False
            
            # Create additional directories for other components
            additional_dirs = ["commands", "hooks", "backups", "logs"]
            for dirname in additional_dirs:
                dir_path = self.install_dir / dirname
                if not self.file_manager.ensure_directory(dir_path):
                    self.logger.warning(f"Could not create directory: {dir_path}")
            
            self.logger.success(f"Core component installed successfully ({success_count} files)")
            return True
            
        except Exception as e:
            self.logger.exception(f"Unexpected error during core installation: {e}")
            return False
    
    def uninstall(self) -> bool:
        """Uninstall core component"""
       