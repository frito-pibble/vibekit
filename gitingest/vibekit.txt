Directory structure:
└── superagent-ai-vibekit/
    ├── README.md
    ├── LICENSE
    ├── LLM.md
    ├── package.json
    ├── tsconfig.json
    ├── tsup.config.ts
    ├── vitest.config.ts
    ├── .npmignore
    ├── assets/
    │   └── dockerfiles/
    │       ├── Dockerfile.claude
    │       ├── Dockerfile.codex
    │       ├── Dockerfile.gemini
    │       ├── Dockerfile.opencode
    │       └── Dockerfile.shopify
    ├── images/
    │   ├── Dockerfile.claude
    │   ├── Dockerfile.codex
    │   ├── Dockerfile.gemini
    │   ├── Dockerfile.opencode
    │   └── Dockerfile.shopify
    ├── src/
    │   ├── index.ts
    │   ├── types.ts
    │   ├── agents/
    │   │   ├── base.ts
    │   │   ├── claude.ts
    │   │   ├── codex.ts
    │   │   ├── gemini.ts
    │   │   ├── opencode.ts
    │   │   └── utils.ts
    │   ├── cli/
    │   │   ├── index.ts
    │   │   ├── commands/
    │   │   │   ├── init.ts
    │   │   │   └── providers/
    │   │   │       ├── daytona.ts
    │   │   │       └── e2b.ts
    │   │   └── utils/
    │   │       ├── auth.ts
    │   │       ├── exec.ts
    │   │       ├── install.ts
    │   │       └── logger.ts
    │   ├── constants/
    │   │   └── enums.ts
    │   ├── core/
    │   │   └── vibekit.ts
    │   └── services/
    │       ├── sandbox.ts
    │       └── telemetry.ts
    ├── templates/
    │   ├── codex-clone/
    │   │   ├── README.md
    │   │   ├── components.json
    │   │   ├── eslint.config.mjs
    │   │   ├── next.config.ts
    │   │   ├── package.json
    │   │   ├── postcss.config.mjs
    │   │   ├── tsconfig.json
    │   │   ├── .env.example
    │   │   ├── app/
    │   │   │   ├── client-page.tsx
    │   │   │   ├── container.tsx
    │   │   │   ├── globals.css
    │   │   │   ├── layout.tsx
    │   │   │   ├── page.tsx
    │   │   │   ├── streaming.css
    │   │   │   ├── _components/
    │   │   │   │   ├── task-form.tsx
    │   │   │   │   └── task-list.tsx
    │   │   │   ├── actions/
    │   │   │   │   ├── inngest.ts
    │   │   │   │   └── vibekit.ts
    │   │   │   ├── api/
    │   │   │   │   ├── auth/
    │   │   │   │   │   └── github/
    │   │   │   │   │       ├── branches/
    │   │   │   │   │       │   └── route.ts
    │   │   │   │   │       ├── callback/
    │   │   │   │   │       │   └── route.ts
    │   │   │   │   │       ├── repositories/
    │   │   │   │   │       │   └── route.ts
    │   │   │   │   │       └── url/
    │   │   │   │   │           └── route.ts
    │   │   │   │   └── inngest/
    │   │   │   │       └── route.ts
    │   │   │   ├── auth/
    │   │   │   │   └── success/
    │   │   │   │       └── page.tsx
    │   │   │   ├── environments/
    │   │   │   │   ├── client-page.tsx
    │   │   │   │   ├── page.tsx
    │   │   │   │   └── _components/
    │   │   │   │       ├── create-environment-dialog.tsx
    │   │   │   │       └── environments-list.tsx
    │   │   │   └── task/
    │   │   │       └── [id]/
    │   │   │           ├── client-page.tsx
    │   │   │           ├── page.tsx
    │   │   │           └── _components/
    │   │   │               ├── message-input.tsx
    │   │   │               └── navbar.tsx
    │   │   ├── components/
    │   │   │   ├── markdown.tsx
    │   │   │   ├── navbar.tsx
    │   │   │   ├── streaming-indicator.tsx
    │   │   │   └── ui/
    │   │   │       ├── button.tsx
    │   │   │       ├── dialog.tsx
    │   │   │       ├── scroll-area.tsx
    │   │   │       ├── select.tsx
    │   │   │       ├── separator.tsx
    │   │   │       ├── skeleton.tsx
    │   │   │       ├── table.tsx
    │   │   │       ├── tabs.tsx
    │   │   │       ├── text-shimmer.tsx
    │   │   │       ├── theme-toggle.tsx
    │   │   │       └── tooltip.tsx
    │   │   ├── hooks/
    │   │   │   └── use-github-auth.ts
    │   │   ├── lib/
    │   │   │   ├── github.ts
    │   │   │   ├── inngest.ts
    │   │   │   └── utils.ts
    │   │   └── stores/
    │   │       ├── environments.ts
    │   │       └── tasks.ts
    │   └── v0-clone/
    │       ├── README.md
    │       ├── components.json
    │       ├── config.ts
    │       ├── eslint.config.mjs
    │       ├── middleware.ts
    │       ├── next.config.ts
    │       ├── package.json
    │       ├── postcss.config.mjs
    │       ├── tsconfig.json
    │       ├── .env.example
    │       ├── app/
    │       │   ├── client-page.tsx
    │       │   ├── globals.css
    │       │   ├── layout.tsx
    │       │   ├── page.tsx
    │       │   ├── actions/
    │       │   │   ├── github.ts
    │       │   │   ├── inngest.ts
    │       │   │   ├── session.ts
    │       │   │   └── vibekit.ts
    │       │   ├── api/
    │       │   │   ├── auth/
    │       │   │   │   └── [...nextauth]/
    │       │   │   │       └── route.ts
    │       │   │   ├── check-url/
    │       │   │   │   └── route.ts
    │       │   │   └── inngest/
    │       │   │       └── route.ts
    │       │   ├── session/
    │       │   │   └── [id]/
    │       │   │       ├── client-page.tsx
    │       │   │       └── page.tsx
    │       │   └── sessions/
    │       │       ├── client-page.tsx
    │       │       └── page.tsx
    │       ├── components/
    │       │   ├── booting-machine.tsx
    │       │   ├── file-diff.tsx
    │       │   ├── login-dialog.tsx
    │       │   ├── markdown.tsx
    │       │   ├── navbar.tsx
    │       │   ├── templates-section.tsx
    │       │   ├── chat/
    │       │   │   ├── chat-form.tsx
    │       │   │   ├── index.tsx
    │       │   │   └── message.tsx
    │       │   ├── preview/
    │       │   │   ├── code.tsx
    │       │   │   ├── index.tsx
    │       │   │   └── toolbar.tsx
    │       │   └── ui/
    │       │       ├── avatar.tsx
    │       │       ├── button.tsx
    │       │       ├── dialog.tsx
    │       │       ├── dropdown-menu.tsx
    │       │       ├── form.tsx
    │       │       ├── input.tsx
    │       │       ├── label.tsx
    │       │       ├── scroll-area.tsx
    │       │       ├── select.tsx
    │       │       ├── separator.tsx
    │       │       ├── skeleton.tsx
    │       │       ├── table.tsx
    │       │       ├── tabs.tsx
    │       │       ├── text-shimmer.tsx
    │       │       └── theme-toggle.tsx
    │       ├── convex/
    │       │   ├── messages.ts
    │       │   ├── schema.ts
    │       │   ├── sessions.ts
    │       │   └── _generated/
    │       │       ├── api.d.ts
    │       │       ├── api.js
    │       │       ├── dataModel.d.ts
    │       │       ├── server.d.ts
    │       │       └── server.js
    │       ├── lib/
    │       │   ├── auth.ts
    │       │   ├── hooks.ts
    │       │   ├── inngest.ts
    │       │   └── utils.ts
    │       ├── providers/
    │       │   ├── auth-provider.tsx
    │       │   ├── convex-provider.tsx
    │       │   └── theme-provider.tsx
    │       └── public/
    │           └── convex.webp
    ├── test/
    │   ├── claude.test.ts
    │   ├── codex.test.ts
    │   ├── gemini.test.ts
    │   ├── opencode.test.ts
    │   ├── setup.ts
    │   └── telemetry.test.ts
    └── .github/
        ├── PULL_REQUEST_TEMPLATE.md
        ├── ISSUE_TEMPLATE/
        │   ├── bug_report.md
        │   └── feature_request.md
        └── workflows/
            └── ci.yml


Files Content:

(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: README.md
================================================
<div align="center">

<img width="500px" src="./assets/vibekit-hero.png" />

### Run coding agents in a secure sandbox

A simple SDK for safely running Codex, Claude, Gemini CLI, and SST Opencode in your app or workflow.

---

[Website](https://vibekit.sh) • [Docs](https://docs.vibekit.sh) • [Discord](https://discord.com/invite/mhmJUTjW4b)

---
</div>

## 🧠 What is VibeKit?

VibeKit is an SDK for running powerful coding agents like **Claude Code**, **OpenAI Codex**, **Gemini CLI**, and **SST Opencode** in secure, customizable sandboxes. You can generate and execute real code safely, stream output to your UI, and run everything in the cloud — with full isolation and flexibility. Local execution coming soon.

One SDK. Any coding agent. Any sandbox.

## 🚀 Quick Start

```bash
npx @vibe-kit/sdk init
# or after global install
vibekit init
```

## ⚡️ Features

🧠 Drop-in SDK for Claude Code, OpenAI Codex, Gemini CLI, and SST Opencode 
🔒 Secure sandboxing for safe code execution  
🌐 Cloud-based execution (local support coming soon)  
🔁 GitHub automation: branches, commits, PRs  
💬 Prompt history and context continuity  
📡 Streamed output for real-time UIs  
🔍 OpenTelemetry support for tracing and metrics  
🧰 Compatible with any sandbox runtime
⚡ Execute arbitrary commands in sandbox environments

## 📦 Supported Sandbox Runtimes

Currently supports E2B with Daytona, Modal, Fly.io, and other providers coming soon.

## 🧪 Use Cases

Build internal debugging tools, ship AI-powered features, scaffold new ideas, automate repetitive coding tasks, and test LLM output safely in production or prototyping environments.

## 🤝 Contributing

Contributions welcome! Open an issue, start a discussion, or submit a pull request.

## 📄 License

MIT — see [LICENSE](./LICENSE) for details.

© 2025 Superagent Technologies Inc.



================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) 2024 Superagent Technologies Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: LLM.md
================================================
# VibeKit SDK API Documentation

## Overview
VibeKit is a TypeScript SDK for running AI coding agents (Claude, Codex, Gemini, OpenCode) in secure sandboxes with GitHub integration.

**Package**: `@vibe-kit/sdk`  
**Version**: 0.0.46  
**Main Entry**: `dist/index.js`

## Installation
```bash
npm install @vibe-kit/sdk
```

## Quick Start
```typescript
import { VibeKit } from '@vibe-kit/sdk';

const vibekit = new VibeKit({
  agent: {
    type: 'codex',
    model: { provider: 'openai', apiKey: 'your-key' }
  },
  environment: {
    e2b: { apiKey: 'your-e2b-key' }
  }
});

const result = await vibekit.generateCode({
  prompt: 'Add error handling to login function',
  mode: 'code'
});
```

## Core Classes

### VibeKit
**Import**: `import { VibeKit } from '@vibe-kit/sdk'`

Main SDK class for AI-powered code generation and sandbox management.

#### Constructor
```typescript
new VibeKit(config: VibeKitConfig)
```

#### Methods
- `generateCode(options): Promise<AgentResponse>` - Generate code with AI
  - `options.prompt: string` - Code generation prompt
  - `options.mode: 'ask' | 'code'` - Ask questions or generate code
  - `options.branch?: string` - Git branch to work on
  - `options.history?: Conversation[]` - Chat history
  - `options.callbacks?: VibeKitStreamCallbacks` - Streaming callbacks
  - `options.background?: boolean` - Run in background

- `runTests(options): Promise<AgentResponse>` - Run tests in sandbox
- `createPullRequest(labelOptions?, branchPrefix?): Promise<PullRequestResponse>` - Create GitHub PR
- `executeCommand(command, options?): Promise<BaseAgentResponse>` - Execute shell command
- `kill(): Promise<void>` - Terminate sandbox
- `pause(): Promise<void>` - Pause sandbox
- `resume(): Promise<void>` - Resume sandbox
- `getSession(): Promise<string | null>` - Get session ID
- `setSession(sessionId): Promise<void>` - Set session ID
- `getHost(port): Promise<string>` - Get sandbox host URL

## Agent Classes

### CodexAgent
**Import**: `import { CodexAgent } from '@vibe-kit/sdk'`

OpenAI Codex agent for code generation.

```typescript
new CodexAgent(config: CodexConfig)
```

**Config**:
- `providerApiKey: string` - OpenAI API key
- `sandboxConfig: SandboxConfig` - Sandbox configuration
- `provider?: ModelProvider` - Model provider
- `model?: string` - Specific model name
- `githubToken?: string` - GitHub token
- `repoUrl?: string` - Repository URL

### ClaudeAgent
**Import**: `import { ClaudeAgent } from '@vibe-kit/sdk'`

Anthropic Claude agent for code generation.

```typescript
new ClaudeAgent(config: ClaudeConfig)
```

**Config**: Similar to CodexAgent but requires `provider: 'anthropic'`

### GeminiAgent
**Import**: `import { GeminiAgent } from '@vibe-kit/sdk'`

Google Gemini agent for code generation.

```typescript
new GeminiAgent(config: GeminiConfig)
```

**Config**: Similar to CodexAgent but supports `provider: 'gemini' | 'google'`

### OpenCodeAgent
**Import**: `import { OpenCodeAgent } from '@vibe-kit/sdk'`

SST OpenCode agent for code generation.

```typescript
new OpenCodeAgent(config: OpenCodeConfig)
```

**Config**: Similar to CodexAgent with flexible provider support

### BaseAgent
**Import**: `import { BaseAgent } from '@vibe-kit/sdk'`

Abstract base class for all agents. Common methods:
- `generateCode(prompt, mode?, branch?, history?, callbacks?, background?): Promise<AgentResponse>`
- `executeCommand(command, options?): Promise<AgentResponse>`
- `createPullRequest(labelOptions?, branchPrefix?): Promise<PullRequestResult>`
- `killSandbox(): Promise<void>`
- `pauseSandbox(): Promise<void>`
- `resumeSandbox(): Promise<void>`
- `setGithubToken(token): void`
- `setGithubRepository(repoUrl): void`

## Configuration Types

### VibeKitConfig
```typescript
interface VibeKitConfig {
  agent: {
    type: AgentType;
    model: AgentModel;
  };
  environment: EnvironmentConfig;
  secrets?: SecretsConfig;
  github?: GithubConfig;
  telemetry?: TelemetryConfig;
  sessionId?: string;
  workingDirectory?: string;
}
```

### AgentType
```typescript
type AgentType = 'codex' | 'claude' | 'opencode' | 'gemini'
```

### AgentModel
```typescript
interface AgentModel {
  name?: string;
  provider?: ModelProvider;
  apiKey: string;
}
```

### ModelProvider
```typescript
type ModelProvider = 'openai' | 'anthropic' | 'azure' | 'gemini' | 'google' | ...
```

### SandboxConfig
```typescript
interface SandboxConfig {
  type: 'e2b' | 'daytona' | 'northflank';
  apiKey: string;
  templateId?: string;
  image?: string;
  serverUrl?: string;
  projectId?: string;
  workingDirectory?: string;
}
```

### EnvironmentConfig
```typescript
interface EnvironmentConfig {
  e2b?: E2BConfig;
  daytona?: DaytonaConfig;
  northflank?: NorthflankConfig;
}
```

## Response Types

### AgentResponse
```typescript
interface AgentResponse {
  exitCode: number;
  stdout: string;
  stderr: string;
  sandboxId: string;
  patch?: string;
  patchApplyScript?: string;
  branchName?: string;
  commitSha?: string;
}
```

### PullRequestResponse
```typescript
interface PullRequestResponse {
  html_url: string;
  number: number;
  branchName: string;
  commitSha?: string;
}
```

## Streaming Callbacks

### VibeKitStreamCallbacks
```typescript
interface VibeKitStreamCallbacks {
  onUpdate?: (message: string) => void;
  onError?: (error: string) => void;
}
```

## Services

### TelemetryService
**Import**: `import { TelemetryService } from '@vibe-kit/sdk'`

OpenTelemetry-based service for tracking agent operations.

```typescript
new TelemetryService(config: TelemetryConfig, sessionId?: string)
```

**Methods**:
- `trackStart(agentType, mode, prompt, metadata?): Promise<void>`
- `trackStream(agentType, mode, prompt, streamData, sandboxId?, repoUrl?, metadata?): Promise<void>`
- `trackEnd(agentType, mode, prompt, sandboxId?, repoUrl?, metadata?): Promise<void>`
- `trackError(agentType, mode, prompt, error, metadata?): Promise<void>`
- `shutdown(): Promise<void>`

### Sandbox Providers
**Import**: `import { createSandboxProvider } from '@vibe-kit/sdk'`

```typescript
const provider = createSandboxProvider('e2b' | 'daytona' | 'northflank');
const sandbox = await provider.create(config, envs?, agentType?);
```

## Utility Functions

### generatePRMetadata
**Import**: `import { generatePRMetadata } from '@vibe-kit/sdk'`

```typescript
const metadata = await generatePRMetadata(patch, modelConfig, prompt);
// Returns: { title, body, branchName, commitMessage }
```

### generateCommitMessage
**Import**: `import { generateCommitMessage } from '@vibe-kit/sdk'`

```typescript
const { commitMessage } = await generateCommitMessage(patch, modelConfig, prompt);
```

## Usage Examples

### Basic Code Generation
```typescript
import { VibeKit } from '@vibe-kit/sdk';

const vibekit = new VibeKit({
  agent: {
    type: 'claude',
    model: {
      provider: 'anthropic',
      apiKey: process.env.ANTHROPIC_API_KEY
    }
  },
  environment: {
    e2b: { apiKey: process.env.E2B_API_KEY }
  },
  github: {
    token: process.env.GITHUB_TOKEN,
    repoUrl: 'owner/repo'
  }
});

const result = await vibekit.generateCode({
  prompt: 'Add input validation to the user registration form',
  mode: 'code',
  branch: 'feature/validation',
  callbacks: {
    onUpdate: (msg) => console.log('Progress:', msg),
    onError: (err) => console.error('Error:', err)
  }
});

if (result.exitCode === 0) {
  const pr = await vibekit.createPullRequest({
    name: 'enhancement',
    color: '0075ca',
    description: 'New feature or request'
  });
  console.log('PR created:', pr.html_url);
}
```

### Direct Agent Usage
```typescript
import { CodexAgent } from '@vibe-kit/sdk';

const agent = new CodexAgent({
  providerApiKey: process.env.OPENAI_API_KEY,
  sandboxConfig: {
    type: 'e2b',
    apiKey: process.env.E2B_API_KEY
  },
  githubToken: process.env.GITHUB_TOKEN,
  repoUrl: 'owner/repo'
});

const response = await agent.generateCode(
  'Refactor the authentication middleware',
  'code',
  'refactor/auth',
  [], // conversation history
  { onUpdate: console.log }
);
```

### Streaming with History
```typescript
const history = [
  { role: 'user', content: 'What does this function do?' },
  { role: 'assistant', content: 'This function handles user authentication...' }
];

const result = await vibekit.generateCode({
  prompt: 'Now add rate limiting to it',
  mode: 'code',
  history,
  callbacks: {
    onUpdate: (chunk) => {
      // Stream to UI
      updateUI(chunk);
    }
  }
});
```

### Sandbox Management
```typescript
// Execute custom commands
const cmdResult = await vibekit.executeCommand('npm test', {
  timeoutMs: 30000,
  callbacks: { onUpdate: console.log }
});

// Get sandbox host for port forwarding
const host = await vibekit.getHost(3000);
console.log('App running at:', host);

// Pause/resume for cost optimization
await vibekit.pause();
// ... later
await vibekit.resume();

// Clean up
await vibekit.kill();
```

## Supported Sandbox Runtimes

- **E2B**: Cloud-based code execution environment
- **Daytona**: Development environment platform
- **Northflank**: Container-based sandbox platform

## Error Handling

All methods return promises that may reject. Always wrap in try-catch:

```typescript
try {
  const result = await vibekit.generateCode({ prompt: '...', mode: 'code' });
  if (result.exitCode !== 0) {
    console.error('Command failed:', result.stderr);
  }
} catch (error) {
  console.error('SDK error:', error.message);
}
```

## Environment Variables

Common environment variables:
- `OPENAI_API_KEY` - OpenAI API key
- `ANTHROPIC_API_KEY` - Anthropic API key
- `GOOGLE_API_KEY` - Google API key
- `E2B_API_KEY` - E2B sandbox API key
- `DAYTONA_API_KEY` - Daytona API key
- `NORTHFLANK_API_KEY` - Northflank API key
- `GITHUB_TOKEN` - GitHub personal access token

## TypeScript Support

Fully typed with TypeScript definitions included. Import types:

```typescript
import type {
  VibeKitConfig,
  AgentResponse,
  AgentType,
  ModelProvider,
  SandboxConfig,
  StreamCallbacks
} from '@vibe-kit/sdk';
```



================================================
FILE: package.json
================================================
{
    "name": "@vibe-kit/sdk",
    "type": "module",
    "engines": {
        "node": ">=18.0.0"
    },
    "main": "dist/index.js",
    "types": "dist/index.d.ts",
    "version": "0.0.47",
    "bin": {
        "vibekit": "./dist/cli/index.js"
    },
    "exports": {
        ".": {
            "import": "./dist/index.js",
            "require": "./dist/index.cjs"
        },
        "./cli": "./dist/cli/index.js"
    },
    "scripts": {
        "build": "tsup",
        "dev": "tsup src/index.ts --watch",
        "type-check": "tsc --noEmit",
        "test": "vitest",
        "cli": "tsx src/cli/index.ts"
    },
    "devDependencies": {
        "@types/node": "^22.15.18",
        "@vitest/coverage-v8": "^3.1.3",
        "tsup": "^8.4.0",
        "typescript": "^5.8.3",
        "vitest": "^3.1.3"
    },
    "dependencies": {
        "@ai-sdk/anthropic": "^1.2.12",
        "@ai-sdk/openai": "^1.3.22",
        "@ai-sdk/openai-compatible": "^0.2.14",
        "@daytonaio/sdk": "^0.22.1",
        "@e2b/code-interpreter": "1.2.0-beta.4",
        "@northflank/js-client": "^0.8.2",
        "@opentelemetry/api": "^1.9.0",
        "@opentelemetry/auto-instrumentations-node": "^0.59.0",
        "@opentelemetry/exporter-metrics-otlp-http": "^0.201.1",
        "@opentelemetry/exporter-otlp-http": "^0.26.0",
        "@opentelemetry/exporter-trace-otlp-http": "^0.201.1",
        "@opentelemetry/instrumentation": "^0.201.1",
        "@opentelemetry/resources": "^2.0.1",
        "@opentelemetry/sdk-metrics": "^2.0.1",
        "@opentelemetry/sdk-node": "^0.201.1",
        "@opentelemetry/semantic-conventions": "^1.34.0",
        "@types/uuid": "^10.0.0",
        "ai": "^4.3.16",
        "cfonts": "^3.3.0",
        "chalk": "^5.4.1",
        "commander": "^14.0.0",
        "enquirer": "^2.4.1",
        "execa": "^9.6.0",
        "open": "^10.1.2",
        "ora": "^8.2.0",
        "uuid": "^11.1.0"
    }
}



================================================
FILE: tsconfig.json
================================================
{
    "compilerOptions": {
      "target": "ES2022",
      "module": "ESNext",
      "moduleResolution": "Bundler",
      "declaration": true,
      "outDir": "dist",
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true
    },
    "include": ["src", "test/codex.test.ts"]
  }
  


================================================
FILE: tsup.config.ts
================================================
import { defineConfig } from 'tsup';

export default defineConfig([
  // Main library build
  {
    entry: ['src/index.ts'],
    format: ['esm', 'cjs'],
    dts: true,
    clean: true,
    sourcemap: true,
  },
  // CLI build
  {
    entry: ['src/cli/index.ts'],
    format: 'esm',
    outDir: 'dist/cli',
    platform: 'node',
    target: 'node18',
    bundle: true,
    dts: false,
    clean: false,
    sourcemap: true,
    banner: {
      js: 'import { createRequire } from "module"; const require = createRequire(import.meta.url);',
    },
    esbuildOptions(options) {
      options.external = ['@e2b/cli', 'daytona'];
      options.banner = {
        js: 'import { createRequire } from \'module\'; const require = createRequire(import.meta.url);',
      };
    },
  },
]);



================================================
FILE: vitest.config.ts
================================================
import { defineConfig } from "vitest/config";

export default defineConfig({
  test: {
    setupFiles: ["./test/setup.ts"],
  },
});



================================================
FILE: .npmignore
================================================
src/
test/
coverage/
.github/
*.ts
!dist/**/*.ts
tsconfig.json
test-*.ts


================================================
FILE: assets/dockerfiles/Dockerfile.claude
================================================
# Use Ubuntu 22.04 as the base image
FROM ubuntu:22.04

# Install curl and git, update package list
RUN apt-get update && apt-get install -y curl git ripgrep

# Install Node.js 24.x
RUN curl -sL https://deb.nodesource.com/setup_24.x | bash - && apt-get install -y nodejs

# Confirm installations
RUN node -v && npm -v && git --version

# Install Claude Code globalliy
RUN npm install -g @anthropic-ai/claude-code@latest


================================================
FILE: assets/dockerfiles/Dockerfile.codex
================================================
# Use Ubuntu 22.04 as the base image
FROM ubuntu:22.04

# Install curl and git, update package list
RUN apt-get update && apt-get install -y curl git

# Install Node.js 24.x
RUN curl -sL https://deb.nodesource.com/setup_24.x | bash - && apt-get install -y nodejs

# Confirm installations
RUN node -v && npm -v && git --version

# Install OpenAI Codex globally
RUN npm install -g @openai/codex@latest


================================================
FILE: assets/dockerfiles/Dockerfile.gemini
================================================
# Use Ubuntu 22.04 as the base image
FROM ubuntu:22.04

# Install curl and git, update package list
RUN apt-get update && apt-get install -y curl git

# Install Node.js 24.x
RUN curl -sL https://deb.nodesource.com/setup_24.x | bash - && apt-get install -y nodejs

# Confirm installations
RUN node -v && npm -v && git --version

# Install OpenAI Codex globally
RUN npm install -g @google/gemini-cli


================================================
FILE: assets/dockerfiles/Dockerfile.opencode
================================================
# Use Ubuntu 22.04 as the base image
FROM ubuntu:22.04

# Install curl and git, update package list
RUN apt-get update && apt-get install -y curl git

# Install Node.js 24.x
RUN curl -sL https://deb.nodesource.com/setup_24.x | bash - && apt-get install -y nodejs

# Confirm installations
RUN node -v && npm -v && git --version

# Install OpenAI Codex globally
RUN npm install -g opencode-ai@latest


================================================
FILE: assets/dockerfiles/Dockerfile.shopify
================================================
# Use Ubuntu 22.04 as the base image
FROM ubuntu:22.04

# Install system dependencies and Node.js
RUN apt-get update && apt-get install -y \
    curl \
    git \
    ripgrep \
    ca-certificates \
    gnupg \
    && curl -fsSL https://deb.nodesource.com/setup_20.x | bash - \
    && apt-get install -y nodejs \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# Install Node.js packages globally
RUN npm install -g \
    @anthropic-ai/claude-code@latest \
    @shopify/cli@latest \
    && npm cache clean --force

# Verify installations
RUN node -v && npm -v && git --version


================================================
FILE: images/Dockerfile.claude
================================================
# Use Ubuntu 22.04 as the base image
FROM ubuntu:22.04

# Install curl and git, update package list
RUN apt-get update && apt-get install -y curl git ripgrep

# Install Node.js 24.x
RUN curl -sL https://deb.nodesource.com/setup_24.x | bash - && apt-get install -y nodejs

# Confirm installations
RUN node -v && npm -v && git --version

# Install Claude Code globalliy
RUN npm install -g @anthropic-ai/claude-code@latest


================================================
FILE: images/Dockerfile.codex
================================================
# Use Ubuntu 22.04 as the base image
FROM ubuntu:22.04

# Install curl and git, update package list
RUN apt-get update && apt-get install -y curl git

# Install Node.js 24.x
RUN curl -sL https://deb.nodesource.com/setup_24.x | bash - && apt-get install -y nodejs

# Confirm installations
RUN node -v && npm -v && git --version

# Install OpenAI Codex globally
RUN npm install -g @openai/codex@latest


================================================
FILE: images/Dockerfile.gemini
================================================
# Use Ubuntu 22.04 as the base image
FROM ubuntu:22.04

# Install curl and git, update package list
RUN apt-get update && apt-get install -y curl git

# Install Node.js 24.x
RUN curl -sL https://deb.nodesource.com/setup_24.x | bash - && apt-get install -y nodejs

# Confirm installations
RUN node -v && npm -v && git --version

# Install OpenAI Codex globally
RUN npm install -g @google/gemini-cli


================================================
FILE: images/Dockerfile.opencode
================================================
# Use Ubuntu 22.04 as the base image
FROM ubuntu:22.04

# Install curl and git, update package list
RUN apt-get update && apt-get install -y curl git

# Install Node.js 24.x
RUN curl -sL https://deb.nodesource.com/setup_24.x | bash - && apt-get install -y nodejs

# Confirm installations
RUN node -v && npm -v && git --version

# Install OpenAI Codex globally
RUN npm install -g opencode-ai@latest


================================================
FILE: images/Dockerfile.shopify
================================================
# Use Ubuntu 22.04 as the base image
FROM ubuntu:22.04

# Install system dependencies and Node.js
RUN apt-get update && apt-get install -y \
    curl \
    git \
    ripgrep \
    ca-certificates \
    gnupg \
    && curl -fsSL https://deb.nodesource.com/setup_20.x | bash - \
    && apt-get install -y nodejs \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# Install Node.js packages globally
RUN npm install -g \
    @anthropic-ai/claude-code@latest \
    @shopify/cli@latest \
    && npm cache clean --force

# Verify installations
RUN node -v && npm -v && git --version


================================================
FILE: src/index.ts
================================================
// Main exports
export { VibeKit } from "./core/vibekit";

// Type exports
export type {
  AgentResponse,
  VibeKitStreamCallbacks,
  PullRequestResponse,
} from "./core/vibekit";

export type {
  VibeKitConfig,
  AgentType,
  AgentMode,
  AgentModel,
  ModelProvider,
  E2BConfig,
  DaytonaConfig,
  NorthflankConfig,
  EnvironmentConfig,
  GithubConfig,
  TelemetryConfig,
  LabelOptions,
} from "./types";

// Agent function exports
export { CodexAgent } from "./agents/codex";
export { ClaudeAgent } from "./agents/claude";
export { OpenCodeAgent } from "./agents/opencode";
export { GeminiAgent } from "./agents/gemini";
export { BaseAgent } from "./agents/base";

// Agent config type exports
export type { CodexConfig, CodexResponse, CodexStreamCallbacks } from "./types";
export type {
  ClaudeConfig,
  ClaudeResponse,
  ClaudeStreamCallbacks,
} from "./types";
export type {
  OpenCodeConfig,
  OpenCodeResponse,
  OpenCodeStreamCallbacks,
} from "./types";
export type {
  StreamCallbacks,
  BaseAgentConfig,
  PullRequestResult,
} from "./agents/base";
export type {
  GeminiConfig,
  GeminiResponse,
  GeminiStreamCallbacks,
} from "./types";

// Telemetry exports
export { TelemetryService } from "./services/telemetry";
export type { TelemetryData } from "./services/telemetry";



================================================
FILE: src/types.ts
================================================
// AGENTS
export type AgentType = "codex" | "claude" | "opencode" | "gemini";

export type AgentMode = "ask" | "code";

export type ModelProvider =
  | "openai"
  | "anthropic"
  | "openrouter"
  | "azure"
  | "gemini"
  | "google"
  | "ollama"
  | "mistral"
  | "deepseek"
  | "xai"
  | "groq"
  | "arceeai";

export type AgentModel = {
  name?: string;
  provider?: ModelProvider;
  apiKey: string;
};

export type E2BConfig = {
  apiKey: string;
  templateId?: string;
};

export type DaytonaConfig = {
  apiKey: string;
  image?: string;
  serverUrl?: string;
};

export type NorthflankConfig = {
  apiKey: string;
  image?: string;
  projectId?: string;
  billingPlan?: string;
  persistentVolumeStorage?: number;
};

export type EnvironmentConfig = {
  e2b?: E2BConfig;
  daytona?: DaytonaConfig;
  northflank?: NorthflankConfig;
};

export type GithubConfig = {
  token: string;
  repository: string;
};

// SECRETS
export type SecretsConfig = {
  /** Environment variables to be passed to the sandbox */
  [key: string]: string;
};

// TELEMETRY
export type TelemetryConfig = {
  /** Enable or disable telemetry */
  isEnabled: boolean;
  /** OTLP HTTP endpoint for traces (e.g., "https://api.honeycomb.io/v1/traces") */
  endpoint?: string;
  /** Service name for resource attributes (defaults to "vibekit") */
  serviceName?: string;
  /** Service version for resource attributes (defaults to "1.0.0") */
  serviceVersion?: string;
  /** Additional headers for OTLP HTTP requests */
  headers?: Record<string, string>;
  /** Request timeout in milliseconds (defaults to 5000) */
  timeout?: number;
  /** Sampling ratio from 0.0 to 1.0 (defaults to 1.0 for 100% sampling) */
  samplingRatio?: number;
  /** Additional resource attributes to include in telemetry data */
  resourceAttributes?: Record<string, string>;
};

export type VibeKitConfig = {
  agent: {
    type: AgentType;
    model: AgentModel;
  };
  environment: EnvironmentConfig;
  secrets?: SecretsConfig;
  github?: GithubConfig;
  telemetry?: TelemetryConfig;
  sessionId?: string;
  /** Working directory inside the sandbox (defaults to "/var/vibe0") */
  workingDirectory?: string;
};

// CONVERSATION HISTORY
export type Conversation = {
  role: "user" | "assistant";
  content: string;
};

// PULL REQUEST LABELS
export interface LabelOptions {
  name: string;
  color: string;
  description: string;
}

// STREAMING CALLBACKS
export interface CodexStreamCallbacks {
  onUpdate?: (message: string) => void;
  onError?: (error: string) => void;
}

export interface ClaudeStreamCallbacks {
  onUpdate?: (message: string) => void;
  onError?: (error: string) => void;
}

export interface OpenCodeStreamCallbacks {
  onUpdate?: (message: string) => void;
  onError?: (error: string) => void;
}

export interface GeminiStreamCallbacks {
  onUpdate?: (message: string) => void;
  onError?: (error: string) => void;
}

// CODEX CONFIG
export interface CodexConfig {
  providerApiKey?: string;
  provider?: ModelProvider;
  githubToken?: string;
  repoUrl?: string; // org/repo, e.g. "octocat/hello-world"
  e2bApiKey: string;
  e2bTemplateId?: string;
  sandboxConfig?: SandboxConfig; // New unified sandbox config
  secrets?: SecretsConfig;
  model?: string;
  sandboxId?: string;
  telemetry?: TelemetryConfig;
  workingDirectory?: string;
}

export interface CodexResponse {
  exitCode: number;
  stdout: string;
  stderr: string;
  sandboxId: string;
  patch?: string;
  patchApplyScript?: string;
  branchName?: string;
  commitSha?: string;
}

// CLAUDE CONFIG
export interface ClaudeConfig {
  providerApiKey: string;
  provider?: ModelProvider;
  githubToken?: string;
  repoUrl?: string; // org/repo, e.g. "octocat/hello-world"
  e2bApiKey: string;
  e2bTemplateId?: string;
  sandboxConfig?: SandboxConfig; // New unified sandbox config
  secrets?: SecretsConfig;
  model?: string;
  sandboxId?: string;
  telemetry?: TelemetryConfig;
  workingDirectory?: string;
}

export interface ClaudeResponse {
  exitCode: number;
  stdout: string;
  stderr: string;
  sandboxId: string;
  patch?: string;
  patchApplyScript?: string;
  branchName?: string;
  commitSha?: string;
}

// OPENCODE CONFIG
export interface OpenCodeConfig {
  providerApiKey?: string;
  provider?: ModelProvider;
  githubToken?: string;
  repoUrl?: string; // org/repo, e.g. "octocat/hello-world"
  e2bApiKey: string;
  e2bTemplateId?: string;
  sandboxConfig?: SandboxConfig; // New unified sandbox config
  secrets?: SecretsConfig;
  model?: string;
  sandboxId?: string;
  telemetry?: TelemetryConfig;
  workingDirectory?: string;
}

export interface OpenCodeResponse {
  exitCode: number;
  stdout: string;
  stderr: string;
  sandboxId: string;
  patch?: string;
  patchApplyScript?: string;
  branchName?: string;
  commitSha?: string;
}

// GEMINI CONFIG
export interface GeminiConfig {
  providerApiKey?: string;
  provider?: ModelProvider;
  githubToken?: string;
  repoUrl?: string; // org/repo, e.g. "octocat/hello-world"
  e2bApiKey: string;
  e2bTemplateId?: string;
  sandboxConfig?: SandboxConfig; // New unified sandbox config
  secrets?: SecretsConfig;
  model?: string;
  sandboxId?: string;
  telemetry?: TelemetryConfig;
  workingDirectory?: string;
}

export interface GeminiResponse {
  exitCode: number;
  stdout: string;
  stderr: string;
  sandboxId: string;
  patch?: string;
  patchApplyScript?: string;
  branchName?: string;
  commitSha?: string;
}

// SANDBOX ABSTRACTION
export interface SandboxExecutionResult {
  exitCode: number;
  stdout: string;
  stderr: string;
}

export interface SandboxCommandOptions {
  timeoutMs?: number;
  background?: boolean;
  onStdout?: (data: string) => void;
  onStderr?: (data: string) => void;
}

export interface SandboxCommands {
  run(
    command: string,
    options?: SandboxCommandOptions
  ): Promise<SandboxExecutionResult>;
}

export interface SandboxInstance {
  sandboxId: string;
  commands: SandboxCommands;
  kill(): Promise<void>;
  pause(): Promise<void>;
  getHost(port: number): Promise<string>;
}

export interface SandboxConfig {
  type: "e2b" | "daytona" | "northflank";
  apiKey: string;
  templateId?: string; // for E2B
  image?: string; // for Daytona
  serverUrl?: string; // for Daytona
  projectId?: string; // for Northflank
  billingPlan?: string; // for Northflank
  persistentVolume?: string; // for Northflank
  persistentVolumeStorage?: number; // for Northflank
  workingDirectory?: string; // for Nortflank
}

export interface SandboxProvider {
  create(
    config: SandboxConfig,
    envs?: Record<string, string>,
    agentType?: "codex" | "claude" | "opencode" | "gemini"
  ): Promise<SandboxInstance>;
  resume(sandboxId: string, config: SandboxConfig): Promise<SandboxInstance>;
}



================================================
FILE: src/agents/base.ts
================================================
import {
  generateCommitMessage,
  generatePRMetadata,
  ModelConfig,
} from "./utils";
import {
  Conversation,
  SandboxInstance,
  SandboxConfig,
  LabelOptions,
} from "../types";
import { createSandboxProvider } from "../services/sandbox";

// StreamingBuffer class to handle chunked JSON data
class StreamingBuffer {
  private buffer = "";
  private onComplete: (data: string) => void;

  constructor(onComplete: (data: string) => void) {
    this.onComplete = onComplete;
  }

  append(chunk: string): void {
    // Filter out null bytes that can corrupt JSON parsing
    const cleanChunk = chunk.replace(/\0/g, '');
    this.buffer += cleanChunk;
    this.processBuffer();
  }

  private processBuffer(): void {
    let bracketCount = 0;
    let inString = false;
    let escaped = false;
    let start = 0;

    for (let i = 0; i < this.buffer.length; i++) {
      const char = this.buffer[i];

      if (escaped) {
        escaped = false;
        continue;
      }

      if (char === "\\") {
        escaped = true;
        continue;
      }

      if (char === '"') {
        inString = !inString;
        continue;
      }

      if (inString) {
        continue;
      }

      if (char === "{") {
        bracketCount++;
      } else if (char === "}") {
        bracketCount--;

        if (bracketCount === 0) {
          // Found complete JSON object
          const jsonStr = this.buffer.slice(start, i + 1);
          try {
            // Validate JSON before calling callback
            JSON.parse(jsonStr);
            this.onComplete(jsonStr);
          } catch (e) {
            // Invalid JSON, continue buffering
          }

          // Move to next potential JSON object
          start = i + 1;

          // If there's a newline after this JSON, skip it
          if (start < this.buffer.length && this.buffer[start] === "\n") {
            start++;
          }
        }
      }
    }

    // Keep only the remaining unparsed part
    this.buffer = this.buffer.slice(start);
  }

  // Handle any remaining non-JSON output (like raw text)
  flush(): void {
    if (this.buffer.trim()) {
      // If it's not JSON, pass it through as-is
      this.onComplete(this.buffer);
      this.buffer = "";
    }
  }
}

export interface BaseAgentConfig {
  githubToken?: string;
  repoUrl?: string;
  sandboxConfig: SandboxConfig; // Now required - no more fallback
  secrets?: Record<string, string>;
  sandboxId?: string;
  telemetry?: any;
  workingDirectory?: string;
}

export interface StreamCallbacks {
  onUpdate?: (message: string) => void;
  onError?: (error: string) => void;
}

export interface AgentResponse {
  sandboxId: string;
  exitCode: number;
  stdout: string;
  stderr: string;
}

export interface PullRequestResult {
  id: number;
  number: number;
  state: string;
  title: string;
  body: string | null;
  html_url: string;
  head: {
    ref: string;
    sha: string;
    repo: any;
  };
  base: {
    ref: string;
    sha: string;
    repo: any;
  };
  user: {
    login: string;
    id: number;
    avatar_url: string;
    html_url: string;
  };
  created_at: string;
  updated_at: string;
  merged: boolean;
  mergeable: boolean | null;
  merge_commit_sha: string | null;
  branchName: string;
  commitSha?: string;
}

export interface AgentCommandConfig {
  command: string;
  errorPrefix: string;
  labelName: string;
  labelColor: string;
  labelDescription: string;
}

export abstract class BaseAgent {
  protected config: BaseAgentConfig;
  protected sandboxInstance?: SandboxInstance;
  protected lastPrompt?: string;
  protected currentBranch?: string;
  protected readonly WORKING_DIR: string;

  constructor(config: BaseAgentConfig) {
    this.config = config;
    this.WORKING_DIR = config.workingDirectory || "/vibe0";
  }

  protected abstract getCommandConfig(
    prompt: string,
    mode?: "ask" | "code"
  ): AgentCommandConfig;
  protected abstract getDefaultTemplate(): string;

  private async getSandbox(): Promise<SandboxInstance> {
    if (this.sandboxInstance) return this.sandboxInstance;

    const provider = createSandboxProvider(this.config.sandboxConfig.type);

    if (this.config.sandboxId) {
      this.sandboxInstance = await provider.resume(
        this.config.sandboxId,
        this.config.sandboxConfig
      );
    } else {
      // Merge agent-specific environment variables with user-defined secrets
      const envVars = {
        ...this.getEnvironmentVariables(),
        ...(this.config.secrets || {}),
      };

      this.sandboxInstance = await provider.create(
        this.config.sandboxConfig,
        envVars,
        this.getAgentType()
      );
    }
    return this.sandboxInstance;
  }

  protected abstract getEnvironmentVariables(): Record<string, string>;

  private getMkdirCommand(path: string): string {
    return this.config.sandboxConfig.type === "e2b"
      ? `sudo mkdir -p ${path} && sudo chown $USER:$USER ${path}`
      : `mkdir -p ${path}`;
  }

  public async killSandbox() {
    if (this.sandboxInstance) {
      await this.sandboxInstance.kill();
      this.sandboxInstance = undefined;
    }
  }

  public async pauseSandbox() {
    if (this.sandboxInstance) {
      await this.sandboxInstance.pause();
    }
  }

  public async resumeSandbox() {
    if (this.sandboxInstance) {
      const provider = createSandboxProvider(this.config.sandboxConfig.type);
      this.sandboxInstance = await provider.resume(
        this.sandboxInstance.sandboxId,
        this.config.sandboxConfig
      );
    }
  }

  public async getSession() {
    if (this.sandboxInstance) {
      return this.sandboxInstance.sandboxId;
    }
    return this.config.sandboxId || null;
  }

  public async setSession(sessionId: string) {
    this.config.sandboxId = sessionId;
  }

  public setGithubToken(token: string): void {
    this.config.githubToken = token;
  }

  public setGithubRepository(repoUrl: string): void {
    this.config.repoUrl = repoUrl;
  }

  public async getHost(port: number): Promise<string> {
    const sbx = await this.getSandbox();
    return await sbx.getHost(port);
  }

  public getCurrentBranch(): string | undefined {
    return this.currentBranch;
  }

  public async executeCommand(
    command: string,
    options: {
      timeoutMs?: number;
      background?: boolean;
      callbacks?: StreamCallbacks;
    } = {}
  ): Promise<AgentResponse> {
    const { timeoutMs = 3600000, background = false, callbacks } = options;

    try {
      const sbx = await this.getSandbox();

      if (!this.config.sandboxId && sbx.sandboxId) {
        callbacks?.onUpdate?.(
          `{"type": "start", "sandbox_id": "${sbx.sandboxId}"}`
        );
      }

      console.log("RUN IT");

      // Ensure working directory exists first
      await sbx.commands.run(this.getMkdirCommand(this.WORKING_DIR), {
        timeoutMs: 30000,
        background: false,
        onStdout: (data) => console.log(data),
      });

      // For executeCommand, always use working directory directly
      const executeCommand = `cd ${this.WORKING_DIR} && ${command}`;

      // Set up streaming buffers for stdout and stderr if callbacks are provided
      let stdoutBuffer: StreamingBuffer | undefined;
      let stderrBuffer: StreamingBuffer | undefined;

      if (callbacks?.onUpdate) {
        stdoutBuffer = new StreamingBuffer(callbacks.onUpdate);
        stderrBuffer = new StreamingBuffer(callbacks.onUpdate);
      }

      const result = await sbx.commands.run(executeCommand, {
        timeoutMs,
        background,
        onStdout: (data) => stdoutBuffer?.append(data),
        onStderr: (data) => stderrBuffer?.append(data),
      });

      // Flush any remaining buffered content
      stdoutBuffer?.flush();
      stderrBuffer?.flush();

      callbacks?.onUpdate?.(
        `{"type": "end", "sandbox_id": "${
          sbx.sandboxId
        }", "output": "${JSON.stringify(result)}"}`
      );

      return {
        sandboxId: sbx.sandboxId,
        ...result,
      };
    } catch (error) {
      console.error("Error executing command:", error);
      const errorMessage = `Failed to execute command: ${
        error instanceof Error ? error.message : String(error)
      }`;
      callbacks?.onError?.(errorMessage);
      throw new Error(errorMessage);
    }
  }

  public async generateCode(
    prompt: string,
    mode?: "ask" | "code",
    branch?: string,
    _history?: Conversation[],
    callbacks?: StreamCallbacks,
    background?: boolean
  ): Promise<AgentResponse> {
    const commandConfig = this.getCommandConfig(prompt, mode);

    try {
      const sbx = await this.getSandbox();

      if (!this.config.sandboxId && sbx.sandboxId) {
        callbacks?.onUpdate?.(
          `{"type": "start", "sandbox_id": "${sbx.sandboxId}"}`
        );

        // Create working directory
        await sbx.commands.run(this.getMkdirCommand(this.WORKING_DIR), {
          timeoutMs: 30000,
          background: background || false,
        });

        // Only clone repository if GitHub config is provided
        if (this.config.githubToken && this.config.repoUrl) {
          callbacks?.onUpdate?.(
            `{"type": "git", "output": "Cloning repository: ${this.config.repoUrl}"}`
          );
          // Clone directly into the working directory, not into a subdirectory
          await sbx.commands.run(
            `cd ${this.WORKING_DIR} && git clone https://x-access-token:${this.config.githubToken}@github.com/${this.config.repoUrl}.git .`,
            { timeoutMs: 3600000, background: background || false }
          );
        }

        await sbx.commands.run(
          `cd ${this.WORKING_DIR} && git config user.name "github-actions[bot]" && git config user.email "github-actions[bot]@users.noreply.github.com"`,
          { timeoutMs: 60000, background: background || false }
        );
      } else if (this.config.sandboxId) {
        callbacks?.onUpdate?.(
          `{"type": "start", "sandbox_id": "${this.config.sandboxId}"}`
        );
      }

      // Switch to specified branch if provided and repository is available
      if (branch && this.config.repoUrl) {
        // Store the branch for later use
        this.currentBranch = branch;

        callbacks?.onUpdate?.(
          `{"type": "git", "output": "Switching to branch: ${branch}"}`
        );
        try {
          // Try to checkout existing branch first
          await sbx.commands.run(
            `cd ${this.WORKING_DIR} && git checkout ${branch}`,
            {
              timeoutMs: 60000,
              background: background || false,
            }
          );
          // Pull latest changes from the remote branch
          callbacks?.onUpdate?.(
            `{"type": "git", "output": "Pulling latest changes from ${branch}"}`
          );
          await sbx.commands.run(
            `cd ${this.WORKING_DIR} && git pull origin ${branch}`,
            {
              timeoutMs: 60000,
              background: background || false,
            }
          );
        } catch (error) {
          // If branch doesn't exist, create it
          callbacks?.onUpdate?.(
            `{"type": "git", "output": "Branch ${branch} not found, creating new branch"}`
          );
          await sbx.commands.run(
            `cd ${this.WORKING_DIR} && git checkout -b ${branch}`,
            {
              timeoutMs: 60000,
              background: background || false,
            }
          );
        }
      }

      // Always use working directory for all commands (repo is cloned directly into working directory)
      const executeCommand = `cd ${this.WORKING_DIR} && ${commandConfig.command}`;

      // Set up streaming buffers for stdout and stderr if callbacks are provided
      let stdoutBuffer: StreamingBuffer | undefined;
      let stderrBuffer: StreamingBuffer | undefined;

      if (callbacks?.onUpdate) {
        stdoutBuffer = new StreamingBuffer(callbacks.onUpdate);
        stderrBuffer = new StreamingBuffer(callbacks.onUpdate);
      }

      const result = await sbx.commands.run(executeCommand, {
        timeoutMs: 3600000,
        background: background || false,
        onStdout: (data) => stdoutBuffer?.append(data),
        onStderr: (data) => stderrBuffer?.append(data),
      });

      // Flush any remaining buffered content
      stdoutBuffer?.flush();
      stderrBuffer?.flush();

      callbacks?.onUpdate?.(
        `{"type": "end", "sandbox_id": "${
          sbx.sandboxId
        }", "output": "${JSON.stringify(result)}"}`
      );

      this.lastPrompt = prompt;

      return {
        sandboxId: sbx.sandboxId,
        ...result,
      };
    } catch (error) {
      console.error(`Error calling ${commandConfig.errorPrefix}:`, error);
      const errorMessage = `Failed to generate code: ${
        error instanceof Error ? error.message : String(error)
      }`;
      callbacks?.onError?.(errorMessage);
      throw new Error(errorMessage);
    }
  }

  public async pushToBranch(branch?: string): Promise<void> {
    const targetBranch = branch || this.currentBranch;

    if (!targetBranch) {
      throw new Error(
        "No branch specified. Either pass a branch name or call generateCode with a branch first."
      );
    }

    const sbx = await this.getSandbox();

    // Check git status for changes
    const gitStatus = await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git status --porcelain`,
      { timeoutMs: 3600000 }
    );

    // Check for untracked files
    const untrackedFiles = await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git ls-files --others --exclude-standard`,
      { timeoutMs: 3600000 }
    );

    // Check if there are any changes to commit
    if (!gitStatus?.stdout && !untrackedFiles?.stdout) {
      throw new Error("No changes found to commit and push");
    }

    // Switch to the specified branch (create if it doesn't exist)
    try {
      await sbx.commands.run(
        `cd ${this.WORKING_DIR} && git checkout ${targetBranch}`,
        {
          timeoutMs: 60000,
        }
      );
    } catch (error) {
      // If branch doesn't exist, create it
      await sbx.commands.run(
        `cd ${this.WORKING_DIR} && git checkout -b ${targetBranch}`,
        {
          timeoutMs: 60000,
        }
      );
    }

    const diffHead = await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git --no-pager diff --no-color HEAD`,
      {
        timeoutMs: 3600000,
      }
    );

    const patch = await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git --no-pager diff --no-color --diff-filter=ACMR`,
      { timeoutMs: 3600000 }
    );

    let patchContent = patch?.stdout || diffHead?.stdout || "";

    // Add all changes and commit
    const { commitMessage } = await generateCommitMessage(
      patchContent,
      this.getModelConfig(),
      this.lastPrompt || ""
    );

    await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git add -A && git commit -m "${commitMessage}"`,
      { timeoutMs: 3600000 }
    );

    // Push the branch to GitHub
    await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git push origin ${targetBranch}`,
      {
        timeoutMs: 3600000,
      }
    );
  }

  public async createPullRequest(
    labelOptions?: LabelOptions,
    branchPrefix?: string
  ): Promise<PullRequestResult> {
    const { githubToken, repoUrl } = this.config;

    if (!githubToken || !repoUrl) {
      throw new Error(
        "GitHub configuration is required for creating pull requests. Please provide githubToken and repoUrl in your configuration."
      );
    }

    const commandConfig = this.getCommandConfig("", "code");
    const sbx = await this.getSandbox();
    // Get the current branch (base branch) BEFORE creating a new branch
    const baseBranch = await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git rev-parse --abbrev-ref HEAD`,
      { timeoutMs: 3600000 }
    );

    // Debug: Check git status first
    await sbx.commands.run(`cd ${this.WORKING_DIR} && git status --porcelain`, {
      timeoutMs: 3600000,
    });

    // Debug: Check for untracked files
    const untrackedFiles = await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git ls-files --others --exclude-standard`,
      { timeoutMs: 3600000 }
    );

    const diffHead = await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git --no-pager diff --no-color HEAD`,
      {
        timeoutMs: 3600000,
      }
    );

    const patch = await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git --no-pager diff --no-color --diff-filter=ACMR`,
      { timeoutMs: 3600000 }
    );

    if (
      !patch ||
      (!patch.stdout && !diffHead?.stdout && !untrackedFiles?.stdout)
    ) {
      throw new Error(
        `No changes found - check if the agent actually modified any files`
      );
    }

    // Use the diff that has content, preferring the original patch format
    let patchContent = patch?.stdout || diffHead?.stdout || "";

    // If no diff but there are untracked files, we need to add them first
    if (!patchContent && untrackedFiles?.stdout) {
      await sbx.commands.run(`cd ${this.WORKING_DIR} && git add .`, {
        timeoutMs: 3600000,
      });

      const patchAfterAdd = await sbx.commands.run(
        `cd ${this.WORKING_DIR} && git --no-pager diff --no-color --cached`,
        { timeoutMs: 3600000 }
      );
      patchContent = patchAfterAdd?.stdout || "";
    }

    if (!patchContent) {
      throw new Error("No patch content found after checking all diff methods");
    }

    const { title, body, branchName, commitMessage } = await generatePRMetadata(
      patchContent,
      this.getModelConfig(),
      this.lastPrompt || ""
    );

    const _branchName = branchPrefix
      ? `${branchPrefix}/${branchName}`
      : branchName;

    // Escape any quotes in the commit message to prevent shell parsing issues
    const escapedCommitMessage = commitMessage.replace(/"/g, '\\"');

    const checkout = await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git checkout -b ${_branchName} && git add -A && git commit -m "${escapedCommitMessage}"`,
      {
        timeoutMs: 3600000,
      }
    );

    // Push the branch to GitHub
    await sbx.commands.run(
      `cd ${this.WORKING_DIR} && git push origin ${_branchName}`,
      {
        timeoutMs: 3600000,
      }
    );

    // Extract commit SHA from checkout output
    const commitMatch = checkout?.stdout.match(/\[[\w-]+ ([a-f0-9]+)\]/);
    const commitSha = commitMatch ? commitMatch[1] : undefined;

    // Create Pull Request using GitHub API
    const [owner, repo] = repoUrl?.split("/") || [];
    const prResponse = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/pulls`,
      {
        method: "POST",
        headers: {
          Authorization: `token ${githubToken}`,
          Accept: "application/vnd.github.v3+json",
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          title,
          body,
          head: _branchName,
          base: baseBranch?.stdout.trim() || "main",
        }),
      }
    );

    if (!prResponse.ok) {
      const errorText = await prResponse.text();
      throw new Error(`Failed to create PR: ${prResponse.status} ${errorText}`);
    }

    const prData = await prResponse.json();

    // Handle label creation and assignment
    const labelConfig = labelOptions || {
      name: commandConfig.labelName,
      color: commandConfig.labelColor,
      description: commandConfig.labelDescription,
    };
    await this.handlePRLabeling(owner, repo, prData.number, labelConfig);

    return {
      id: prData.id,
      number: prData.number,
      state: prData.state,
      title: prData.title,
      body: prData.body,
      html_url: prData.html_url,
      head: prData.head,
      base: prData.base,
      user: prData.user,
      created_at: prData.created_at,
      updated_at: prData.updated_at,
      merged: prData.merged,
      mergeable: prData.mergeable,
      merge_commit_sha: prData.merge_commit_sha,
      branchName: _branchName,
      commitSha,
    };
  }

  public async runTests(
    branch?: string,
    history?: Conversation[],
    callbacks?: StreamCallbacks,
    background?: boolean
  ): Promise<AgentResponse> {
    return await this.generateCode(
      "Install dependencies and run tests",
      "code",
      branch,
      history,
      callbacks,
      background
    );
  }

  protected abstract getApiKey(): string;
  protected abstract getAgentType(): "codex" | "claude" | "opencode" | "gemini";
  protected abstract getModelConfig(): ModelConfig;

  private async handlePRLabeling(
    owner: string,
    repo: string,
    prNumber: number,
    labelConfig: LabelOptions
  ) {
    const { githubToken } = this.config;
    const {
      name: labelName,
      color: labelColor,
      description: labelDescription,
    } = labelConfig;

    // Check if label exists first
    const labelCheckResponse = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/labels/${labelName}`,
      {
        headers: {
          Authorization: `token ${githubToken}`,
          Accept: "application/vnd.github.v3+json",
        },
      }
    );

    // Only create label if it doesn't exist (404 status)
    if (!labelCheckResponse.ok && labelCheckResponse.status === 404) {
      const labelResponse = await fetch(
        `https://api.github.com/repos/${owner}/${repo}/labels`,
        {
          method: "POST",
          headers: {
            Authorization: `token ${githubToken}`,
            Accept: "application/vnd.github.v3+json",
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            name: labelName,
            color: labelColor,
            description: labelDescription,
          }),
        }
      );

      if (!labelResponse.ok) {
        const errorText = await labelResponse.text();
        console.error(
          `Failed to create label '${labelName}': ${labelResponse.status} ${errorText}`
        );
      }
    } else if (!labelCheckResponse.ok) {
      // Handle other errors (not 404)
      const errorText = await labelCheckResponse.text();
      console.error(
        `Failed to check if label '${labelName}' exists: ${labelCheckResponse.status} ${errorText}`
      );
    }

    // Add label to PR
    const addLabelResponse = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/issues/${prNumber}/labels`,
      {
        method: "POST",
        headers: {
          Authorization: `token ${githubToken}`,
          Accept: "application/vnd.github.v3+json",
          "Content-Type": "application/json",
        },
        body: JSON.stringify([labelName]),
      }
    );

    if (!addLabelResponse.ok) {
      const errorText = await addLabelResponse.text();
      console.error(
        `Failed to add label '${labelName}' to PR #${prNumber}: ${addLabelResponse.status} ${errorText}`
      );
    }
  }
}



================================================
FILE: src/agents/claude.ts
================================================
import { BaseAgent, BaseAgentConfig, AgentCommandConfig } from "./base";
import { ModelConfig } from "./utils";
import {
  AgentType,
  ClaudeConfig,
  ClaudeResponse,
  ClaudeStreamCallbacks,
  Conversation,
  ModelProvider,
} from "../types";

export class ClaudeAgent extends BaseAgent {
  private anthropicApiKey: string;
  private model?: string;

  private escapePrompt(prompt: string): string {
    // Escape backticks and other special characters
    return prompt.replace(/[`"$\\]/g, "\\$&");
  }

  constructor(config: ClaudeConfig) {
    if (!config.sandboxConfig) {
      throw new Error("sandboxConfig is required");
    }

    const baseConfig: BaseAgentConfig = {
      githubToken: config.githubToken,
      repoUrl: config.repoUrl,
      sandboxConfig: config.sandboxConfig,
      secrets: config.secrets,
      sandboxId: config.sandboxId,
      telemetry: config.telemetry,
      workingDirectory: config.workingDirectory,
    };

    super(baseConfig);

    // Validate that provider is anthropic if specified (Claude only supports anthropic)
    if (config.provider && config.provider !== "anthropic") {
      throw new Error("Claude agent only supports 'anthropic' provider");
    }

    this.anthropicApiKey = config.providerApiKey;
    this.model = config.model;
  }

  protected getCommandConfig(
    prompt: string,
    mode?: "ask" | "code"
  ): AgentCommandConfig {
    let instruction: string;
    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }

    const escapedPrompt = this.escapePrompt(prompt);

    return {
      command: `echo "${escapedPrompt}" | claude -p --append-system-prompt "${instruction}"${
        mode === "ask" ? ' --disallowedTools "Edit" "Replace" "Write"' : ""
      } --output-format stream-json --verbose --model ${
        this.model || "claude-sonnet-4-20250514"
      }`,
      errorPrefix: "Claude",
      labelName: "claude",
      labelColor: "FF6B35",
      labelDescription: "Generated by Claude AI agent",
    };
  }

  protected getDefaultTemplate(): string {
    return "vibekit-claude";
  }

  protected getEnvironmentVariables(): Record<string, string> {
    return {
      ANTHROPIC_API_KEY: this.anthropicApiKey,
    };
  }

  protected getApiKey(): string {
    return this.anthropicApiKey;
  }

  protected getAgentType(): AgentType {
    return "claude";
  }

  protected getModelConfig(): ModelConfig {
    return {
      provider: "anthropic",
      apiKey: this.anthropicApiKey,
      model: this.model,
    };
  }

  // Override generateCode to support history in the instruction
  public async generateCode(
    prompt: string,
    mode?: "ask" | "code",
    branch?: string,
    history?: Conversation[],
    callbacks?: ClaudeStreamCallbacks,
    background?: boolean
  ): Promise<ClaudeResponse> {
    let instruction: string;
    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }

    if (history && history.length > 0) {
      instruction += `\n\nConversation history: ${history
        .map((h) => `${h.role}\n ${h.content}`)
        .join("\n\n")}`;
    }

    const escapedPrompt = this.escapePrompt(prompt);

    // Override the command config with history-aware instruction
    const originalGetCommandConfig = this.getCommandConfig.bind(this);
    this.getCommandConfig = (p: string, m?: "ask" | "code") => ({
      ...originalGetCommandConfig(p, m),
      command: `echo "${escapedPrompt}" | claude -p --append-system-prompt "${instruction}"${
        mode === "ask" ? ' --disallowedTools "Edit" "Replace" "Write"' : ""
      } --output-format stream-json --verbose --allowedTools "Edit,Write,MultiEdit,Read,Bash" --model ${
        this.model || "claude-sonnet-4-20250514"
      }`,
    });

    const result = await super.generateCode(
      prompt,
      mode,
      branch,
      history,
      callbacks,
      background
    );

    // Restore original method
    this.getCommandConfig = originalGetCommandConfig;

    return result as ClaudeResponse;
  }
}



================================================
FILE: src/agents/codex.ts
================================================
import { BaseAgent, BaseAgentConfig, AgentCommandConfig } from "./base";
import { ModelConfig } from "./utils";
import {
  AgentType,
  CodexConfig,
  CodexResponse,
  CodexStreamCallbacks,
  Conversation,
  ModelProvider,
} from "../types";

export class CodexAgent extends BaseAgent {
  private providerApiKey: string;
  private provider: ModelProvider;
  private model?: string;

  private escapePrompt(prompt: string): string {
    // Escape backticks and other special characters
    return prompt.replace(/[`"$\\]/g, "\\$&");
  }

  constructor(config: CodexConfig) {
    if (!config.sandboxConfig) {
      throw new Error("sandboxConfig is required");
    }

    const baseConfig: BaseAgentConfig = {
      githubToken: config.githubToken,
      repoUrl: config.repoUrl,
      sandboxConfig: config.sandboxConfig,
      secrets: config.secrets,
      sandboxId: config.sandboxId,
      telemetry: config.telemetry,
      workingDirectory: config.workingDirectory,
    };

    super(baseConfig);

    // Support new providerApiKey field with fallback to deprecated fields for backward compatibility
    this.providerApiKey = config.providerApiKey || "";
    this.provider = config.provider || "openai";
    this.model = config.model;

    if (!this.providerApiKey) {
      throw new Error(
        "Provider API key is required. Please provide providerApiKey, apiKey, or openaiApiKey."
      );
    }
  }

  protected getCommandConfig(
    prompt: string,
    mode?: "ask" | "code"
  ): AgentCommandConfig {
    let instruction: string;
    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }

    const escapedPrompt = this.escapePrompt(prompt);
    let _prompt = `${instruction}\n\nUser: ${escapedPrompt}`;

    return {
      command: `codex --full-auto${
        this.model ? ` --model ${this.model}` : ""
      }${
        this.provider ? ` --provider ${this.provider}` : ""
      } --quiet "${_prompt}"`,
      errorPrefix: "Codex",
      labelName: "codex",
      labelColor: "ededed",
      labelDescription: "Pull requests generated by Codex agent",
    };
  }

  protected getDefaultTemplate(): string {
    return "vibekit-codex";
  }

  protected getEnvironmentVariables(): Record<string, string> {
    const envKey = `${this.provider.toUpperCase()}_API_KEY`;
    return {
      [envKey]: this.providerApiKey,
    };
  }

  protected getApiKey(): string {
    return this.providerApiKey;
  }

  protected getAgentType(): AgentType {
    return "codex";
  }

  protected getModelConfig(): ModelConfig {
    return {
      provider: this.provider,
      apiKey: this.providerApiKey,
      model: this.model,
    };
  }

  // Override generateCode to support history in the prompt
  public async generateCode(
    prompt: string,
    mode?: "ask" | "code",
    branch?: string,
    history?: Conversation[],
    callbacks?: CodexStreamCallbacks,
    background?: boolean
  ): Promise<CodexResponse> {
    let instruction: string;

    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }

    const escapedPrompt = this.escapePrompt(prompt);
    let _prompt = `${instruction}\n\nUser: ${escapedPrompt}`;

    if (history) {
      _prompt += `\n\nConversation history: ${history
        .map((h) => `${h.role}\n ${h.content}`)
        .join("\n\n")}`;
    }
    // Override the command config with history-aware prompt
    const originalGetCommandConfig = this.getCommandConfig.bind(this);
    this.getCommandConfig = (p: string, m?: "ask" | "code") => ({
      ...originalGetCommandConfig(p, m),
      command: `codex --full-auto${
        this.model ? ` --model ${this.model}` : ""
      }${
        this.provider ? ` --provider ${this.provider}` : ""
      } --quiet "${_prompt}"`,
    });

    const result = await super.generateCode(
      prompt,
      mode,
      branch,
      history,
      callbacks,
      background
    );

    // Restore original method
    this.getCommandConfig = originalGetCommandConfig;

    return result as CodexResponse;
  }
}



================================================
FILE: src/agents/gemini.ts
================================================
import { BaseAgent, BaseAgentConfig, AgentCommandConfig } from "./base";
import { ModelConfig } from "./utils";
import {
  GeminiConfig,
  GeminiResponse,
  GeminiStreamCallbacks,
  Conversation,
  ModelProvider,
  AgentType,
} from "../types";

export class GeminiAgent extends BaseAgent {
  private geminiApiKey: string;
  private model?: string;

  private escapePrompt(prompt: string): string {
    // Escape backticks and other special characters
    return prompt.replace(/[`"$\\]/g, "\\$&");
  }

  constructor(config: GeminiConfig) {
    if (!config.sandboxConfig) {
      throw new Error("sandboxConfig is required");
    }

    const baseConfig: BaseAgentConfig = {
      githubToken: config.githubToken,
      repoUrl: config.repoUrl,
      sandboxConfig: config.sandboxConfig,
      secrets: config.secrets,
      sandboxId: config.sandboxId,
      telemetry: config.telemetry,
      workingDirectory: config.workingDirectory,
    };

    super(baseConfig);

    // Validate that provider is gemini or google if specified
    if (config.provider && !["gemini", "google"].includes(config.provider)) {
      throw new Error(
        "Gemini agent only supports 'gemini' or 'google' provider"
      );
    }

    this.geminiApiKey = config.providerApiKey || "";
    this.model = config.model;
  }

  protected getCommandConfig(
    prompt: string,
    mode?: "ask" | "code"
  ): AgentCommandConfig {
    let instruction: string;
    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }

    const escapedPrompt = this.escapePrompt(prompt);
    let _prompt = `${instruction}\n\nUser: ${escapedPrompt}`;

    return {
      command: `echo "${_prompt}" | gemini --model ${
        this.model || "gemini-2.5-pro-preview-05-06"
      } --yolo`,
      errorPrefix: "Gemini",
      labelName: "gemini",
      labelColor: "4285F4",
      labelDescription: "Generated by Gemini AI agent",
    };
  }

  protected getDefaultTemplate(): string {
    return "vibekit-gemini";
  }

  protected getEnvironmentVariables(): Record<string, string> {
    return {
      GEMINI_API_KEY: this.geminiApiKey,
      GOOGLE_API_KEY: this.geminiApiKey, // Some tools might expect this name
    };
  }

  protected getApiKey(): string {
    return this.geminiApiKey;
  }

  protected getAgentType(): AgentType {
    return "gemini";
  }

  protected getModelConfig(): ModelConfig {
    return {
      provider: "gemini",
      apiKey: this.geminiApiKey,
      model: this.model,
    };
  }

  // Override generateCode to support history in the instruction
  public async generateCode(
    prompt: string,
    mode?: "ask" | "code",
    branch?: string,
    history?: Conversation[],
    callbacks?: GeminiStreamCallbacks,
    background?: boolean
  ): Promise<GeminiResponse> {
    let instruction: string;
    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }

    if (history && history.length > 0) {
      instruction += `\n\nConversation history: ${history
        .map((h) => `${h.role}\n ${h.content}`)
        .join("\n\n")}`;
    }

    const escapedPrompt = this.escapePrompt(prompt);
    let _prompt = `${instruction}\n\nUser: ${escapedPrompt}`;

    // Override the command config with history-aware instruction
    const originalGetCommandConfig = this.getCommandConfig.bind(this);
    this.getCommandConfig = (p: string, m?: "ask" | "code") => ({
      ...originalGetCommandConfig(p, m),
      command: `echo "${_prompt}" | gemini --model ${
        this.model || "gemini-2.5-pro-preview-05-06"
      } --yolo`,
    });

    const result = await super.generateCode(
      prompt,
      mode,
      branch,
      history,
      callbacks,
      background
    );

    // Restore original method
    this.getCommandConfig = originalGetCommandConfig;

    return result as GeminiResponse;
  }
}



================================================
FILE: src/agents/opencode.ts
================================================
import { BaseAgent, BaseAgentConfig, AgentCommandConfig } from "./base";
import { ModelConfig } from "./utils";
import {
  OpenCodeConfig,
  OpenCodeResponse,
  OpenCodeStreamCallbacks,
  Conversation,
  ModelProvider,
  AgentType,
} from "../types";

export class OpenCodeAgent extends BaseAgent {
  private providerApiKey: string;
  private provider: ModelProvider;
  private model?: string;

  private escapePrompt(prompt: string): string {
    // Escape backticks and other special characters
    return prompt.replace(/[`"$\\]/g, "\\$&");
  }

  constructor(config: OpenCodeConfig) {
    if (!config.sandboxConfig) {
      throw new Error("sandboxConfig is required");
    }

    const baseConfig: BaseAgentConfig = {
      githubToken: config.githubToken,
      repoUrl: config.repoUrl,
      sandboxConfig: config.sandboxConfig,
      secrets: config.secrets,
      sandboxId: config.sandboxId,
      telemetry: config.telemetry,
      workingDirectory: config.workingDirectory,
    };

    super(baseConfig);

    // Support providerApiKey field
    this.providerApiKey = config.providerApiKey || "";
    this.provider = config.provider || "openai";
    this.model = config.model;

    if (!this.providerApiKey) {
      throw new Error(
        "Provider API key is required. Please provide providerApiKey."
      );
    }
  }

  protected getCommandConfig(
    prompt: string,
    mode?: "ask" | "code"
  ): AgentCommandConfig {
    let instruction: string;
    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }

    const escapedPrompt = this.escapePrompt(prompt);
    let _prompt = `${instruction}\n\nUser: ${escapedPrompt}`;

    return {
      command: `opencode run${
        this.model ? ` --model ${this.provider}/${this.model} --print-logs` : ""
      } "${_prompt}"`,
      errorPrefix: "OpenCode",
      labelName: "opencode",
      labelColor: "00D2FF",
      labelDescription: "Pull requests generated by OpenCode agent",
    };
  }

  protected getDefaultTemplate(): string {
    return "vibekit-opencode";
  }

  protected getEnvironmentVariables(): Record<string, string> {
    const envKey = `${this.provider.toUpperCase()}_API_KEY`;
    return {
      [envKey]: this.providerApiKey,
    };
  }

  protected getApiKey(): string {
    return this.providerApiKey;
  }

  protected getAgentType(): AgentType {
    return "opencode";
  }

  protected getModelConfig(): ModelConfig {
    return {
      provider: this.provider,
      apiKey: this.providerApiKey,
      model: this.model,
    };
  }

  // Override generateCode to support history in the prompt
  public async generateCode(
    prompt: string,
    mode?: "ask" | "code",
    branch?: string,
    history?: Conversation[],
    callbacks?: OpenCodeStreamCallbacks,
    background?: boolean
  ): Promise<OpenCodeResponse> {
    let instruction: string;

    if (mode === "ask") {
      instruction =
        "Research the repository and answer the user's questions. " +
        "Do NOT make any changes to any files in the repository.";
    } else {
      instruction =
        "Do the necessary changes to the codebase based on the users input.\n" +
        "Don't ask any follow up questions.";
    }

    const escapedPrompt = this.escapePrompt(prompt);
    let _prompt = `${instruction}\n\nUser: ${escapedPrompt}`;

    if (history) {
      _prompt += `\n\nConversation history: ${history
        .map((h) => `${h.role}\n ${h.content}`)
        .join("\n\n")}`;
    }

    // Override the command config with history-aware prompt
    const originalGetCommandConfig = this.getCommandConfig.bind(this);
    this.getCommandConfig = (p: string, m?: "ask" | "code") => ({
      ...originalGetCommandConfig(p, m),
      command: `opencode run${
        this.model ? ` --model ${this.provider}/${this.model} --print-logs` : ""
      } "${_prompt}"`,
    });

    const result = await super.generateCode(
      prompt,
      mode,
      branch,
      history,
      callbacks,
      background
    );

    // Restore original method
    this.getCommandConfig = originalGetCommandConfig;

    return result as OpenCodeResponse;
  }
}



================================================
FILE: src/agents/utils.ts
================================================
import { createAnthropic } from "@ai-sdk/anthropic";
import { createOpenAI } from "@ai-sdk/openai";
import { createOpenAICompatible } from "@ai-sdk/openai-compatible";
import { generateObject } from "ai";
import { z } from "zod";
import { ModelProvider } from "../types";

export interface ModelConfig {
  provider: ModelProvider;
  apiKey: string;
  model?: string;
  baseUrl?: string; // for custom providers like OpenAI compatible
}

function createProvider(config: ModelConfig) {
  switch (config.provider) {
    case "anthropic":
      return createAnthropic({ apiKey: config.apiKey });
    case "openai":
      return createOpenAI({ apiKey: config.apiKey });
    case "openrouter":
      return createOpenAICompatible({
        name: "openrouter",
        apiKey: config.apiKey,
        baseURL: "https://openrouter.ai/api/v1",
      });
    case "azure":
      if (!config.baseUrl) {
        throw new Error("baseUrl is required for Azure provider");
      }
      return createOpenAICompatible({
        name: "azure",
        apiKey: config.apiKey,
        baseURL: config.baseUrl,
      });
    case "gemini":
      return createOpenAICompatible({
        name: "gemini",
        apiKey: config.apiKey,
        baseURL: "https://generativelanguage.googleapis.com/v1beta/openai/",
      });
    case "ollama":
      return createOpenAICompatible({
        name: "ollama",
        apiKey: config.apiKey || "ollama", // Ollama often doesn't require a real key
        baseURL: config.baseUrl || "http://localhost:11434/v1",
      });
    case "mistral":
      return createOpenAICompatible({
        name: "mistral",
        apiKey: config.apiKey,
        baseURL: "https://api.mistral.ai/v1",
      });
    case "deepseek":
      return createOpenAICompatible({
        name: "deepseek",
        apiKey: config.apiKey,
        baseURL: "https://api.deepseek.com/v1",
      });
    case "xai":
      return createOpenAICompatible({
        name: "xai",
        apiKey: config.apiKey,
        baseURL: "https://api.x.ai/v1",
      });
    case "groq":
      return createOpenAICompatible({
        name: "groq",
        apiKey: config.apiKey,
        baseURL: "https://api.groq.com/openai/v1",
      });
    case "arceeai":
      return createOpenAICompatible({
        name: "arceeai",
        apiKey: config.apiKey,
        baseURL: "https://api.arcee.ai/v1",
      });
    default:
      throw new Error(`Unsupported provider: ${config.provider}`);
  }
}

function getDefaultModel(provider: ModelProvider): string {
  switch (provider) {
    case "anthropic":
      return "claude-3-5-sonnet-20240620";
    case "openai":
      return "gpt-4o-mini";
    case "openrouter":
      return "anthropic/claude-3.5-sonnet";
    case "azure":
      return "gpt-4"; // This would typically be the deployment name
    case "gemini":
      return "gemini-1.5-pro";
    case "google":
      return "gemini-1.5-pro";
    case "ollama":
      return "llama3.1";
    case "mistral":
      return "mistral-large-latest";
    case "deepseek":
      return "deepseek-chat";
    case "xai":
      return "grok-beta";
    case "groq":
      return "llama-3.1-70b-versatile";
    case "arceeai":
      return "arcee-lite";
    default:
      return "gpt-4o-mini";
  }
}

export async function generatePRMetadata(
  patch: string,
  modelConfig: ModelConfig,
  prompt: string
) {
  const _prompt = `You are tasked to create title and body for a pull request based on the following task:\n${prompt}\n\npatch:\n\n${patch}`;
  const provider = createProvider(modelConfig);
  const model = modelConfig.model || getDefaultModel(modelConfig.provider);

  const { object } = await generateObject({
    model: provider(model),
    prompt: _prompt,
    schema: z.object({
      title: z.string().describe("Suggested title for the pull request"),
      body: z.string().describe("Suggested body for the pull request"),
      branchName: z
        .string()
        .describe(`Suggested branch name, should be unique and descriptive`),
      commitMessage: z
        .string()
        .describe("Suggested commit message for the pull request"),
    }),
  });

  return object;
}

export async function generateCommitMessage(
  patch: string,
  modelConfig: ModelConfig,
  prompt: string
) {
  const _prompt = `You are tasked to create a commit message based on the following task:\n${prompt}\n\npatch:\n\n${patch}`;
  const provider = createProvider(modelConfig);
  const model = modelConfig.model || getDefaultModel(modelConfig.provider);

  const { object } = await generateObject({
    model: provider(model),
    prompt: _prompt,
    schema: z.object({
      commitMessage: z
        .string()
        .describe("Suggested commit message for the changes"),
    }),
  });

  return object;
}



================================================
FILE: src/cli/index.ts
================================================
#!/usr/bin/env node

import { Command } from 'commander';
import { initCommand } from './commands/init.js';
import { readFileSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const packageJson = JSON.parse(readFileSync(join(__dirname, '../../package.json'), 'utf8'));

const program = new Command();

program
  .name('vibekit')
  .description('VibeKit development environment manager')
  .version(packageJson.version);

program
  .command('init')
  .description('Initialize VibeKit providers')
  .action(initCommand);

program.parse(process.argv);


================================================
FILE: src/cli/commands/init.ts
================================================
import enquirer from "enquirer";
import chalk from "chalk";
import cfonts from "cfonts";
import { execa } from "execa";
import { installE2B } from "./providers/e2b.js";
import { installDaytona } from "./providers/daytona.js";
import { authenticate, checkAuth, isCliInstalled } from "../utils/auth.js";
import { AGENT_TEMPLATES, SANDBOX_PROVIDERS } from "../../constants/enums.js";

const { prompt } = enquirer;

// Add this type and registry after imports
type InstallConfig = {
  cpu: number;
  memory: number;
  disk: number; // Make required to match Daytona expectations
};

type ProviderInstaller = {
  isInstalled: () => Promise<boolean>;
  configTransform: (config: InstallConfig) => InstallConfig;
  install: (config: InstallConfig, templates: string[]) => Promise<boolean>;
};

const installers: Record<SANDBOX_PROVIDERS, ProviderInstaller> = {
  [SANDBOX_PROVIDERS.E2B]: {
    isInstalled: async () => await isCliInstalled("e2b"),
    configTransform: (config) => config,
    install: installE2B,
  },
  [SANDBOX_PROVIDERS.DAYTONA]: {
    isInstalled: async () => await isCliInstalled("daytona"),
    configTransform: (config) => ({
      ...config,
      memory: Math.floor(config.memory / 1024),
    }),
    install: installDaytona,
  },
};

async function checkDockerStatus(): Promise<{
  isInstalled: boolean;
  isRunning: boolean;
}> {
  try {
    // Check if Docker is installed
    await execa("docker", ["--version"]);

    try {
      // Check if Docker daemon is running
      await execa("docker", ["info"]);
      return { isInstalled: true, isRunning: true };
    } catch {
      return { isInstalled: true, isRunning: false };
    }
  } catch {
    return { isInstalled: false, isRunning: false };
  }
}

export async function initCommand() {
  try {
    // Display banner
    cfonts.say("VIBEKIT", {
      font: "block",
      align: "left",
      colors: ["#FFA500"],
      background: "transparent",
      letterSpacing: 1,
      lineHeight: 1,
      space: true,
      maxLength: "0",
      gradient: false,
      independentGradient: false,
      transitionGradient: false,
      env: "node",
    });

    // Show requirements
    console.log(chalk.blue("🖖 Welcome to VibeKit Setup! 🖖\n"));
    console.log(chalk.yellow("📋 Requirements:"));
    console.log(chalk.gray("  • Internet connection"));
    console.log(chalk.gray("  • Docker installed and running"));
    console.log(chalk.gray("  • Account on at least one sandbox provider\n"));

    // Prompt for provider selection
    console.log(chalk.gray("↑/↓: Navigate • Space: Select • Enter: Confirm\n"));

    const { providers } = await prompt<{ providers: SANDBOX_PROVIDERS[] }>({
      type: "multiselect",
      name: "providers",
      message: "Which providers would you like to set up?",
      choices: Object.entries(SANDBOX_PROVIDERS).map(([key, value]) => ({
        name: value,
        message: value,
      })),
    });

    if (providers.length === 0) {
      console.log(chalk.yellow("No providers selected. Exiting."));
      process.exit(0);
    }

    // Prompt for template selection
    const { templates } = await prompt<{ templates: string[] }>({
      type: "multiselect",
      name: "templates",
      message: "Which agent templates would you like to install?",
      choices: AGENT_TEMPLATES.map((template) => ({
        name: template.name,
        message: template.display,
      })),
    });

    if (templates.length === 0) {
      console.log(chalk.yellow("No templates selected"));
      return;
    }

    // Add this function before the prompts
    function getResourcePrompts(providers: SANDBOX_PROVIDERS[]) {
      const prompts = [
        {
          type: "input",
          name: "cpu",
          message: "CPU cores per provider (Recommended: 2-4 cores):",
          initial: "2",
          validate: (value: string) => {
            const num = parseInt(value);
            return !isNaN(num) && num > 0
              ? true
              : "Please enter a valid number";
          },
        },
        {
          type: "input",
          name: "memory",
          message: "Memory (MB) per provider (Recommended: 1024-4096 MB):",
          initial: "1024",
          validate: (value: string) => {
            const num = parseInt(value);
            return !isNaN(num) && num > 0
              ? true
              : "Please enter a valid number";
          },
        },
      ];

      if (providers.includes(SANDBOX_PROVIDERS.DAYTONA)) {
        prompts.push({
          type: "input",
          name: "disk",
          message: "Disk space (GB) for Daytona (Recommended: 1-3 GB):",
          initial: "1",
          validate: (value: string) => {
            const num = parseInt(value);
            return !isNaN(num) && num > 0
              ? true
              : "Please enter a valid number";
          },
        });
      }

      // Add more conditional prompts for other providers here in the future

      return prompts;
    }

    // Use the function for dynamic prompts
    console.log(
      chalk.gray("\nConfigure resource allocation for your providers:")
    );
    const resourceResponses = await prompt<{
      cpu: string;
      memory: string;
      disk?: string;
    }>(getResourcePrompts(providers));
    const { cpu, memory, disk } = resourceResponses;

    const config = {
      cpu: parseInt(cpu),
      memory: parseInt(memory),
      disk: parseInt(disk ?? "1"), // Default to 1 GB if not prompted
    };

    // Check Docker once upfront since all providers need it
    console.log(chalk.blue("\n🐳 Checking Docker..."));
    const dockerStatus = await checkDockerStatus();
    if (!dockerStatus.isInstalled) {
      console.log(
        chalk.red(
          "❌ Docker not found. Please install Docker from: https://docker.com/get-started and try again. Setup failed: Docker is required for all providers"
        )
      );
      return;
    }

    if (!dockerStatus.isRunning) {
      console.log(
        chalk.red(
          "❌ Docker is not running. Please start Docker and try again. Setup failed: Docker must be running to deploy templates"
        )
      );
      return;
    }

    console.log(chalk.green("✅ Docker is installed and running"));

    // Install selected providers
    let successfulProviders = 0;
    let failedProviders = 0;

    for (const provider of providers) {
      let isAuthenticated = false;

      // Use registry for provider-specific handlers
      const installer = installers[provider];

      // Check if we need to install the CLI first
      const needsInstall = !(await installer.isInstalled());
      if (needsInstall) {
        console.log(chalk.yellow(`\n🔧 ${provider} CLI needs to be installed`));
        const installed = await authenticate(provider);
        if (!installed) {
          console.log(
            chalk.yellow(`\nPlease install ${provider} CLI and try again.`)
          );
          failedProviders++;
          continue; // Skip to next provider
        }
      }

      // Now check authentication
      console.log(chalk.blue(`\n🔐 Checking ${provider} authentication...`));
      const authStatus = await checkAuth(provider);

      if (!authStatus.isAuthenticated) {
        console.log(chalk.yellow(`🔑 Authentication required for ${provider}`));
        const success = await authenticate(provider);
        if (!success) {
          console.log(
            chalk.yellow(
              `\nPlease authenticate with ${provider} and try again.`
            )
          );
          failedProviders++;
          continue; // Skip to next provider
        }

        // Verify authentication after login attempt
        const newAuthStatus = await checkAuth(provider);
        if (!newAuthStatus.isAuthenticated) {
          console.log(chalk.red(`❌ Failed to authenticate with ${provider}`));
          failedProviders++;
          continue; // Skip to next provider
        }
        isAuthenticated = true;
      } else {
        console.log(chalk.green(`✅ Already authenticated with ${provider}`));
        isAuthenticated = true;
      }

      if (!isAuthenticated) {
        failedProviders++;
        continue; // Skip to next provider if not authenticated
      }

      // Proceed with installation (Docker already verified)
      const transformedConfig = installer.configTransform(config);
      const installationSuccess = await installer.install(
        transformedConfig,
        templates
      );

      if (installationSuccess) {
        successfulProviders++;
      } else {
        failedProviders++;
      }
    }

    // Show final result based on success/failure
    if (successfulProviders > 0 && failedProviders === 0) {
      console.log(chalk.green("\n✅ Setup complete!\n"));
    } else if (successfulProviders > 0 && failedProviders > 0) {
      console.log(
        chalk.yellow(
          `\n⚠️  Setup partially complete: ${successfulProviders} succeeded, ${failedProviders} failed\n`
        )
      );
    } else {
      console.log(
        chalk.red(
          "\n❌ Setup failed: No providers were successfully configured\n"
        )
      );
    }
  } catch (error) {
    console.error(
      chalk.red("\n❌ Setup failed:"),
      error instanceof Error ? error.message : error
    );
    process.exit(1);
  }
}



================================================
FILE: src/cli/commands/providers/daytona.ts
================================================
import { execa } from 'execa';
import ora from 'ora';
import chalk from 'chalk';
import { AGENT_TEMPLATES } from '../../../constants/enums.js';

import { isCliInstalled } from '../../utils/auth.js';

import { installTemplates, InstallConfig } from '../../utils/install.js';

export async function installDaytona(config: InstallConfig, selectedTemplates?: string[]) {
  return installTemplates({
    provider: 'Daytona',
    cliCommand: 'daytona',
    isInstalled: async () => await isCliInstalled('daytona'),
    buildArgs: (template, config, tempDockerfile) => [
      'snapshots', 'create',
      template,
      '--cpu', config.cpu.toString(),
      '--memory', config.memory.toString(),
      '--disk', config.disk.toString(),
      '--dockerfile', tempDockerfile
    ],
    needsTempFile: true,
    dockerfilePathPrefix: 'images/Dockerfile.',
    config,
    selectedTemplates
  });
}




================================================
FILE: src/cli/commands/providers/e2b.ts
================================================
import { execa } from 'execa';
import ora from 'ora';
import chalk from 'chalk';
import { AGENT_TEMPLATES } from '../../../constants/enums.js';

import { isCliInstalled } from '../../utils/auth.js';

import { installTemplates, InstallConfig } from '../../utils/install.js';

export async function installE2B(config: InstallConfig, selectedTemplates?: string[]) {
  return installTemplates({
    provider: 'E2B',
    cliCommand: 'e2b',
    isInstalled: async () => await isCliInstalled('e2b'),
    buildArgs: (template, config, tempDockerfile) => [
      'template', 'build',
      '--cpu-count', config.cpu.toString(),
      '--memory-mb', config.memory.toString(),
      '--name', template,
      '--dockerfile', tempDockerfile
    ],
    needsTempFile: false,
    dockerfilePathPrefix: 'images/Dockerfile.',
    config,
    selectedTemplates
  });
}




================================================
FILE: src/cli/utils/auth.ts
================================================
import { execa, execaSync } from 'execa';
import enquirer from 'enquirer';
import ora from 'ora';
import chalk from 'chalk';
import open from 'open';

import { SANDBOX_PROVIDERS } from '../../constants/enums.js';

export interface AuthStatus {
  isAuthenticated: boolean;
  username?: string;
  provider: SANDBOX_PROVIDERS;
  needsInstall?: boolean;
}

type ProviderAuthConfig = {
  cliName: string;
  installInstructions: string;
  checkAuthCommand: string[];
  parseAuthOutput: (stdout: string, stderr: string) => { isAuthenticated: boolean; username?: string };
  loginCommand: string[];
  needsBrowserOpen?: boolean;
};

const authConfigs: Record<SANDBOX_PROVIDERS, ProviderAuthConfig> = {
  [SANDBOX_PROVIDERS.E2B]: {
    cliName: 'e2b',
    installInstructions: 'npm install -g @e2b/cli',
    checkAuthCommand: ['auth', 'info'],
    parseAuthOutput: (stdout) => ({
      isAuthenticated: !stdout.includes('Not logged in') && !stdout.includes('not logged in'),
      username: 'E2B User',
    }),
    loginCommand: ['auth', 'login'],
    needsBrowserOpen: true,
  },
  [SANDBOX_PROVIDERS.DAYTONA]: {
    cliName: 'daytona',
    installInstructions: process.platform === 'win32' ? 'powershell -Command "irm https://get.daytona.io/windows | iex"' : 'brew install daytonaio/cli/daytona',
    checkAuthCommand: ['organization', 'list'],
    parseAuthOutput: (stdout, stderr) => {
      const isAuthError = stderr && (
        stderr.toLowerCase().includes('authentication') ||
        stderr.toLowerCase().includes('login') ||
        stderr.toLowerCase().includes('unauthorized') ||
        stderr.toLowerCase().includes('not logged in')
      );
      let username = 'Daytona User';
      if (stdout) {
        const emailMatch = stdout.match(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/);
        if (emailMatch) username = emailMatch[0];
      }
      return { isAuthenticated: !isAuthError, username };
    },
    loginCommand: ['login'],
  },
};

export async function isCliInstalled(command: string): Promise<boolean> {
  try {
    await execa(command, ['--version']);
    return true;
  } catch (error) {
    return false;
  }
}

export async function checkAuth(provider: SANDBOX_PROVIDERS): Promise<AuthStatus> {
  const config = authConfigs[provider];
  const isInstalled = await isCliInstalled(config.cliName);
  
  if (!isInstalled) {
    return { isAuthenticated: false, provider, needsInstall: true };
  }

  try {
    const { stdout, stderr } = await execa(config.cliName, config.checkAuthCommand, { reject: false });
    const { isAuthenticated, username } = config.parseAuthOutput(stdout, stderr);
    return { isAuthenticated, username, provider };
  } catch (error) {
    console.error(chalk.gray(`Error checking ${provider} auth: ${error instanceof Error ? error.message : String(error)}`));
    return { isAuthenticated: false, provider };
  }
}

async function installE2BCli(): Promise<boolean> {
  const spinner = ora('Installing E2B CLI...').start();
  try {
    // Install E2B CLI via npm (cross-platform)
    await execa('npm', ['install', '-g', '@e2b/cli']);
    spinner.succeed('E2B CLI installed successfully');
    return true;
  } catch (error) {
    spinner.fail('Failed to install E2B CLI');
    console.error(chalk.red('Please install it manually: npm install -g @e2b/cli'));
    return false;
  }
}

async function installDaytonaCli(): Promise<boolean> {
  const spinner = ora('Installing Daytona CLI...').start();
  try {
    const platform = process.platform;
    
    if (platform === 'win32') {
      // Windows installation using the official PowerShell script
      await execa('powershell', ['-Command', 'irm https://get.daytona.io/windows | iex']);
    } else {
      // macOS and Linux installation using Homebrew
      // First check if Homebrew is installed
      try {
        await execa('brew', ['--version']);
      } catch (error) {
        spinner.fail('Homebrew is required to install Daytona CLI on macOS/Linux');
        console.error(chalk.red('Please install Homebrew first: https://brew.sh'));
        return false;
      }
      
      await execa('brew', ['install', 'daytonaio/cli/daytona']);
    }
    
    spinner.succeed('Daytona CLI installed successfully');
    return true;
  } catch (error) {
    spinner.fail('Failed to install Daytona CLI');
    const platform = process.platform;
    const installCmd = platform === 'win32' 
      ? 'powershell -Command "irm https://get.daytona.io/windows | iex"'
      : 'brew install daytonaio/cli/daytona';
    console.error(chalk.red(`Please install it manually: ${installCmd}`));
    return false;
  }
}

export async function authenticate(provider: SANDBOX_PROVIDERS): Promise<boolean> {
  const config = authConfigs[provider];
  const spinner = ora(`Authenticating with ${provider.toUpperCase()}...`).start();
  
  try {
    const isInstalled = await isCliInstalled(config.cliName);
    
    if (!isInstalled) {
      spinner.info(`${provider} CLI not found`);
      const { confirm } = await enquirer.prompt<{ confirm: boolean }>({
        type: 'confirm',
        name: 'confirm',
        message: `Would you like to install ${provider} CLI now?`,
        initial: true
      });
      
      if (confirm) {
        const installed = await installCli(provider);
        if (!installed) return false;
      } else {
        console.log(chalk.yellow(`\nPlease install ${provider} CLI manually: ${config.installInstructions}`));
        return false;
      }
    }

    // Run login
    spinner.text = `Running ${provider} login...`;
    await execa(config.cliName, config.loginCommand, { stdio: 'inherit' });
    
    // Verify with retries
    const maxRetries = 5;
    const retryDelay = 2000;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      const verifiedAuth = await checkAuth(provider);
      if (verifiedAuth.isAuthenticated) {
        spinner.succeed(`Successfully authenticated with ${provider} as ${verifiedAuth.username}`);
        return true;
      }
      if (attempt < maxRetries) {
        spinner.text = `Waiting for ${provider} authentication to complete (${attempt}/${maxRetries})...`;
        await new Promise(resolve => setTimeout(resolve, retryDelay));
      }
    }
    
    spinner.fail(`Failed to verify ${provider} authentication. Please try again.`);
    return false;
  } catch (error) {
    spinner.fail(chalk.red(`Failed to authenticate with ${provider.toUpperCase()}`));
    console.error(chalk.red(error instanceof Error ? error.message : 'Unknown error'));
    return false;
  }
}

async function installCli(provider: SANDBOX_PROVIDERS): Promise<boolean> {
  const config = authConfigs[provider];
  const spinner = ora(`Installing ${provider} CLI...`).start();
  try {
    if (provider === SANDBOX_PROVIDERS.E2B) {
      await execa('npm', ['install', '-g', '@e2b/cli']);
    } else {
      if (process.platform === 'win32') {
        await execa('powershell', ['-Command', 'irm https://get.daytona.io/windows | iex']);
      } else {
        await execa('brew', ['install', 'daytonaio/cli/daytona']);
      }
    }
    spinner.succeed(`${provider} CLI installed successfully`);
    return true;
  } catch (error) {
    spinner.fail(`Failed to install ${provider} CLI`);
    console.error(chalk.red(`Please install it manually: ${config.installInstructions}`));
    return false;
  }
}



================================================
FILE: src/cli/utils/exec.ts
================================================
[Empty file]


================================================
FILE: src/cli/utils/install.ts
================================================
import { execa } from 'execa';
import ora from 'ora';
import chalk from 'chalk';
import { AGENT_TEMPLATES } from '../../constants/enums.js';

export type InstallConfig = {
  cpu: number;
  memory: number;
  disk: number;
};

export async function installTemplates(options: {
  provider: string;
  cliCommand: string;
  isInstalled: () => Promise<boolean>;
  buildArgs: (template: string, config: InstallConfig, tempDockerfile: string) => string[];
  needsTempFile: boolean;
  dockerfilePathPrefix: string;
  config: InstallConfig;
  selectedTemplates?: string[];
}): Promise<boolean> {
  console.log(chalk.blue(`\n🔧 Setting up ${options.provider}...`));
  let spinner: ReturnType<typeof ora> | null = null;
  
  try {
    const isInstalled = await options.isInstalled();
    
    if (!isInstalled) {
      console.log(chalk.yellow(
        `❌ ${options.provider} CLI not found.\n` +
        `Please install it and try again.`
      ));
      return false;
    }

    const results = { successful: 0, failed: 0, errors: [] as string[] };
    
    // Filter templates based on selection (default to all if none specified)
    const templatesToInstall = options.selectedTemplates && options.selectedTemplates.length > 0
      ? AGENT_TEMPLATES.filter(template => options.selectedTemplates!.includes(template.name))
      : AGENT_TEMPLATES;
    
    // Install each selected template
    for (let i = 0; i < templatesToInstall.length; i++) {
      const template = templatesToInstall[i];
      console.log(chalk.blue(`\n🔨 [${i + 1}/${templatesToInstall.length}] Installing ${template.display} template...`));
      
      spinner = ora({
        text: '  Working...',
        color: 'blue',
        spinner: 'dots',
        indent: 2
      }).start();

      const fs = await import('fs/promises');
      let tempDockerfile = '';
      let tempFileCreated = false;

      try {
        // Check if Dockerfile exists
        const dockerfilePath = `${options.dockerfilePathPrefix}${template.name}`;
        try {
          await fs.access(dockerfilePath);
        } catch (error) {
          throw new Error(`Dockerfile not found at: ${dockerfilePath}`);
        }
        
        if (options.needsTempFile) {
          tempDockerfile = `Dockerfile.${template.name}.tmp`;
          await fs.copyFile(dockerfilePath, tempDockerfile);
          tempFileCreated = true;
        } else {
          tempDockerfile = dockerfilePath;
        }
        
        // Run setup with provided configuration
        await execa(options.cliCommand, options.buildArgs(template.name, options.config, tempDockerfile));

        spinner.succeed(chalk.green(`✅ ${template.display} template installed successfully`));
        results.successful++;
        
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        
        let friendlyMessage = `Failed to install ${template.display} template`;
        
        if (errorMessage.includes('already exists') || errorMessage.includes('already used')) {
          friendlyMessage = `${template.display} template already exists - skipping`;
          spinner.info(chalk.yellow(`⚠️  ${friendlyMessage}`));
        } else if (errorMessage.includes('Dockerfile not found')) {
          friendlyMessage = `${template.display} template files missing - skipping`;
          spinner.fail(chalk.red(`❌ ${friendlyMessage}`));
          results.errors.push(`${template.display}: Template files not found`);
          results.failed++;
        } else {
          spinner.fail(chalk.red(`❌ ${friendlyMessage}`));
          results.errors.push(`${template.display}: ${errorMessage}`);
          results.failed++;
        }
        
        console.log(chalk.gray('   Continuing with next template...'));
      } finally {
        spinner = null;
        if (tempFileCreated) {
          try {
            await fs.unlink(tempDockerfile);
          } catch (cleanupError) {
            // Ignore
          }
        }
      }
    }

    // Print summary
    console.log(chalk.blue('\n📊 Installation Summary:'));
    console.log(chalk.green(`✅ Successfully installed: ${results.successful} templates`));
    
    if (results.failed > 0) {
      console.log(chalk.red(`❌ Failed to install: ${results.failed} templates`));
      if (results.errors.length > 0) {
        console.log(chalk.gray('\nError details:'));
        results.errors.forEach(error => {
          console.log(chalk.gray(`  • ${error}`));
        });
      }
    }
    
    if (results.successful > 0) {
      return true;
    } else {
      console.log(chalk.yellow('\n⚠️  No templates were successfully installed.'));
      return false;
    }
  } catch (error) {
    console.error(chalk.red(`\n❌ Failed to set up ${options.provider}:`, error instanceof Error ? error.message : 'Unknown error'));
    return false;
  }
} 


================================================
FILE: src/cli/utils/logger.ts
================================================
[Empty file]


================================================
FILE: src/constants/enums.ts
================================================
// Provider enums
export enum SANDBOX_PROVIDERS {
  E2B = 'E2B',
  DAYTONA = 'Daytona'
}

// Agent configurations with display names and descriptions
export const AGENT_TEMPLATES = [
  { 
    name: 'claude', 
    display: 'Claude', 
    message: 'Claude - Anthropic\'s Claude Code agent' 
  },
  { 
    name: 'codex', 
    display: 'Codex', 
    message: 'Codex - OpenAI\'s Codex agent' 
  },
  { 
    name: 'gemini', 
    display: 'Gemini', 
    message: 'Gemini - Google\'s Gemini CLI agent' 
  },
  { 
    name: 'opencode', 
    display: 'OpenCode', 
    message: 'OpenCode - Open source coding agent' 
  }
];



================================================
FILE: src/core/vibekit.ts
================================================
import {
  VibeKitConfig,
  CodexConfig,
  CodexResponse,
  CodexStreamCallbacks,
  ClaudeConfig,
  ClaudeResponse,
  ClaudeStreamCallbacks,
  OpenCodeConfig,
  OpenCodeResponse,
  OpenCodeStreamCallbacks,
  Conversation,
  SandboxConfig,
  GeminiConfig,
  LabelOptions,
} from "../types";
import { CodexAgent } from "../agents/codex";
import { ClaudeAgent } from "../agents/claude";
import { OpenCodeAgent } from "../agents/opencode";
import { GeminiAgent } from "../agents/gemini";
import {
  BaseAgent,
  AgentResponse as BaseAgentResponse,
  StreamCallbacks,
} from "../agents/base";
import { TelemetryService } from "../services/telemetry";
import { createSandboxConfigFromEnvironment } from "../services/sandbox";

export type AgentResponse =
  | CodexResponse
  | ClaudeResponse
  | OpenCodeResponse
  | { code: string };

// Unified streaming callback interface
export interface VibeKitStreamCallbacks {
  onUpdate?: (message: string) => void;
  onError?: (error: string) => void;
}

// Pull request response interface
export interface PullRequestResponse {
  html_url: string;
  number: number;
  branchName: string;
  commitSha?: string;
}

export class VibeKit {
  private agent: BaseAgent;
  private setup: VibeKitConfig;
  private telemetryService?: TelemetryService;

  constructor(setup: VibeKitConfig) {
    this.setup = setup;

    // Initialize telemetry service if enabled
    if (setup.telemetry?.isEnabled) {
      this.telemetryService = new TelemetryService(
        setup.telemetry,
        setup.sessionId
      );
    }

    // Initialize the appropriate agent
    this.agent = this.createAgent(setup);
  }

  private createAgent(setup: VibeKitConfig): BaseAgent {
    // Create sandbox configuration from the environment
    const sandboxConfig = createSandboxConfigFromEnvironment(
      setup.environment,
      setup.agent.type,
      setup.workingDirectory
    );

    if (setup.agent.type === "codex") {
      const codexConfig: CodexConfig = {
        providerApiKey: setup.agent.model.apiKey,
        provider: setup.agent.model.provider,
        githubToken: setup.github?.token,
        repoUrl: setup.github?.repository,
        // Keep backward compatibility for E2B-specific configs
        e2bApiKey: sandboxConfig.type === "e2b" ? sandboxConfig.apiKey : "",
        e2bTemplateId: sandboxConfig.templateId,
        model: setup.agent.model.name,
        sandboxId: setup.sessionId,
        telemetry: setup.telemetry,
        // Add new sandbox config
        sandboxConfig,
        // Pass secrets to agent
        secrets: setup.secrets,
        workingDirectory: setup.workingDirectory,
      };
      return new CodexAgent(codexConfig);
    } else if (setup.agent.type === "claude") {
      const claudeConfig: ClaudeConfig = {
        providerApiKey: setup.agent.model.apiKey,
        provider: setup.agent.model.provider,
        githubToken: setup.github?.token,
        repoUrl: setup.github?.repository,
        // Keep backward compatibility for E2B-specific configs
        e2bApiKey: sandboxConfig.type === "e2b" ? sandboxConfig.apiKey : "",
        e2bTemplateId: sandboxConfig.templateId,
        model: setup.agent.model.name,
        sandboxId: setup.sessionId,
        telemetry: setup.telemetry,
        // Add new sandbox config
        sandboxConfig,
        // Pass secrets to agent
        secrets: setup.secrets,
        workingDirectory: setup.workingDirectory,
      };
      return new ClaudeAgent(claudeConfig);
    } else if (setup.agent.type === "opencode") {
      const openCodeConfig: OpenCodeConfig = {
        providerApiKey: setup.agent.model.apiKey,
        provider: setup.agent.model.provider,
        githubToken: setup.github?.token,
        repoUrl: setup.github?.repository,
        // Keep backward compatibility for E2B-specific configs
        e2bApiKey: sandboxConfig.type === "e2b" ? sandboxConfig.apiKey : "",
        e2bTemplateId: sandboxConfig.templateId,
        model: setup.agent.model.name,
        sandboxId: setup.sessionId,
        telemetry: setup.telemetry,
        // Add new sandbox config
        sandboxConfig,
        // Pass secrets to agent
        secrets: setup.secrets,
        workingDirectory: setup.workingDirectory,
      };
      return new OpenCodeAgent(openCodeConfig);
    } else if (setup.agent.type === "gemini") {
      const geminiConfig: GeminiConfig = {
        providerApiKey: setup.agent.model.apiKey,
        provider: setup.agent.model.provider,
        githubToken: setup.github?.token,
        repoUrl: setup.github?.repository,
        e2bApiKey: sandboxConfig.type === "e2b" ? sandboxConfig.apiKey : "",
        e2bTemplateId: sandboxConfig.templateId,
        model: setup.agent.model.name,
        sandboxId: setup.sessionId,
        telemetry: setup.telemetry,
        // Add new sandbox config
        sandboxConfig,
        // Pass secrets to agent
        secrets: setup.secrets,
        workingDirectory: setup.workingDirectory,
      };
      return new GeminiAgent(geminiConfig);
    } else {
      throw new Error(`Unsupported agent type: ${setup.agent.type}`);
    }
  }

  private getDataType(data: string): string {
    try {
      const parsed = JSON.parse(data);
      return parsed.type || "unknown";
    } catch {
      return "stream_output";
    }
  }

  async generateCode({
    prompt,
    mode,
    branch,
    history,
    callbacks,
    background,
  }: {
    prompt: string;
    mode: "ask" | "code";
    branch?: string;
    history?: Conversation[];
    background?: boolean;
    callbacks?: VibeKitStreamCallbacks;
  }): Promise<AgentResponse> {
    const agentType = this.setup.agent.type;

    // Track telemetry start
    await this.telemetryService?.trackStart(agentType, mode, prompt, {
      repoUrl: this.setup.github?.repository,
      model: this.setup.agent.model.name,
      hasHistory: !!history?.length,
    });

    if (callbacks) {
      // Wrap callbacks with telemetry tracking
      const wrappedCallbacks = {
        onUpdate: async (data: string) => {
          callbacks.onUpdate?.(data);
          await this.telemetryService?.trackStream(
            agentType,
            mode,
            prompt,
            data,
            undefined,
            this.setup.github?.repository,
            {
              dataType: this.getDataType(data),
            }
          );
        },
        onError: async (error: string) => {
          callbacks.onError?.(error);
          await this.telemetryService?.trackError(
            agentType,
            mode,
            prompt,
            error,
            {
              source: `${agentType}_agent`,
            }
          );
        },
      };

      try {
        const result = await this.agent.generateCode(
          prompt,
          mode,
          branch,
          history,
          wrappedCallbacks,
          background
        );

        await this.telemetryService?.trackEnd(
          agentType,
          mode,
          prompt,
          result.sandboxId,
          this.setup.github?.repository,
          {
            exitCode: result.exitCode,
            stdoutLength: result.stdout?.length || 0,
            stderrLength: result.stderr?.length || 0,
          }
        );

        return result;
      } catch (error) {
        const errorMessage = `${agentType} generation failed: ${
          error instanceof Error ? error.message : String(error)
        }`;

        await this.telemetryService?.trackError(
          agentType,
          mode,
          prompt,
          errorMessage,
          {
            errorType:
              error instanceof Error ? error.constructor.name : "UnknownError",
            source: "vibekit",
          }
        );

        throw error;
      }
    }

    // Non-streaming path
    try {
      const result = await this.agent.generateCode(
        prompt,
        mode,
        branch,
        history,
        undefined,
        background
      );

      await this.telemetryService?.trackEnd(
        agentType,
        mode,
        prompt,
        result.sandboxId,
        this.setup.github?.repository,
        {
          exitCode: result.exitCode,
          stdoutLength: result.stdout?.length || 0,
          stderrLength: result.stderr?.length || 0,
        }
      );

      return result;
    } catch (error) {
      const errorMessage = `${agentType} generation failed: ${
        error instanceof Error ? error.message : String(error)
      }`;

      await this.telemetryService?.trackError(
        agentType,
        mode,
        prompt,
        errorMessage,
        {
          errorType:
            error instanceof Error ? error.constructor.name : "UnknownError",
          source: "vibekit",
        }
      );

      throw error;
    }
  }

  /**
   * Create a Pull Request after generating code changes.
   * This method is available for both Codex and Claude agents and automatically labels
   * the pull request with the agent name ('codex' or 'claude').
   *
   * @returns Promise<PullRequestResponse> - Contains the PR URL, number, branch name, and commit SHA
   * @throws Error if the agent is not supported or if PR creation fails
   */
  async createPullRequest(
    labelOptions?: LabelOptions,
    branchPrefix?: string
  ): Promise<PullRequestResponse> {
    return this.agent.createPullRequest(labelOptions, branchPrefix);
  }

  /**
   * Run tests in the sandbox environment.
   * This method executes common test commands and automatically detects the appropriate test runner.
   *
   * @param branch - Optional branch to run tests on
   * @param history - Optional conversation history for context
   * @param callbacks - Optional callbacks for streaming updates and errors
   * @returns Promise<AgentResponse> - Contains the test execution results
   */
  async runTests({
    branch,
    history,
    callbacks,
  }: {
    branch?: string;
    history?: Conversation[];
    callbacks?: VibeKitStreamCallbacks;
  }): Promise<AgentResponse> {
    return this.agent.runTests(branch, history, callbacks);
  }

  async pushToBranch(branch?: string): Promise<void> {
    return this.agent.pushToBranch(branch);
  }

  /**
   * Kill the active sandbox.
   */
  async kill(): Promise<void> {
    return this.agent.killSandbox();
  }

  /**
   * Pause the active sandbox.
   */
  async pause(): Promise<void> {
    return this.agent.pauseSandbox();
  }

  /**
   * Resume the paused sandbox.
   */
  async resume(): Promise<void> {
    return this.agent.resumeSandbox();
  }

  /**
   * Get the current session ID from the sandbox.
   *
   * @returns Promise<string | null> - The sandbox session ID or null if not available
   */
  async getSession(): Promise<string | null> {
    return this.agent.getSession();
  }

  /**
   * Set the session ID for the sandbox.
   *
   * @param sessionId - The session ID to set
   */
  async setSession(sessionId: string): Promise<void> {
    return this.agent.setSession(sessionId);
  }

  /**
   * Get the host URL for a specific port in the sandbox.
   * Note: This method is only supported for Northflank & E2B sandboxes.
   *
   * @param port - The port number to get the host for
   * @returns Promise<string> - The host URL for the specified port
   * @throws Error if using Daytona sandbox (not implemented)
   */
  async getHost(port: number): Promise<string> {
    return this.agent.getHost(port);
  }

  /**
   * Set the GitHub token for repository operations.
   *
   * @param token - The GitHub token to set
   */
  setGithubToken(token: string): void {
    this.agent.setGithubToken(token);
    if (this.setup.github) {
      this.setup.github.token = token;
    } else {
      this.setup.github = { token, repository: "" };
    }
  }

  /**
   * Set the GitHub repository URL for operations.
   *
   * @param repoUrl - The repository URL (e.g., 'owner/repo')
   */
  setGithubRepository(repoUrl: string): void {
    this.agent.setGithubRepository(repoUrl);
    if (this.setup.github) {
      this.setup.github.repository = repoUrl;
    } else {
      this.setup.github = { token: "", repository: repoUrl };
    }
  }

  async executeCommand(
    command: string,
    options: {
      timeoutMs?: number;
      background?: boolean;
      callbacks?: VibeKitStreamCallbacks;
    } = {}
  ): Promise<BaseAgentResponse> {
    const { callbacks, ...agentOptions } = options;
    const agentType = this.setup.agent.type;

    // Track telemetry start
    await this.telemetryService?.trackStart(agentType, "ask", command, {
      repoUrl: this.setup.github?.repository,
      model: this.setup.agent.model.name,
      commandType: "execute",
    });

    if (callbacks) {
      // Wrap callbacks with telemetry tracking
      const wrappedCallbacks: StreamCallbacks = {
        onUpdate: async (data: string) => {
          callbacks.onUpdate?.(data);
          await this.telemetryService?.trackStream(
            agentType,
            "ask",
            command,
            data,
            undefined,
            this.setup.github?.repository,
            {
              dataType: this.getDataType(data),
              commandType: "execute",
            }
          );
        },
        onError: async (error: string) => {
          callbacks.onError?.(error);
          await this.telemetryService?.trackError(
            agentType,
            "ask",
            command,
            error,
            {
              source: `${agentType}_agent`,
              commandType: "execute",
            }
          );
        },
      };

      try {
        const result = await this.agent.executeCommand(command, {
          ...agentOptions,
          callbacks: wrappedCallbacks,
        });

        await this.telemetryService?.trackEnd(
          agentType,
          "ask",
          command,
          result.sandboxId,
          this.setup.github?.repository,
          {
            exitCode: result.exitCode,
            stdoutLength: result.stdout?.length || 0,
            stderrLength: result.stderr?.length || 0,
            commandType: "execute",
          }
        );

        return result;
      } catch (error) {
        const errorMessage = `Command execution failed: ${
          error instanceof Error ? error.message : String(error)
        }`;

        await this.telemetryService?.trackError(
          agentType,
          "ask",
          command,
          errorMessage,
          {
            errorType:
              error instanceof Error ? error.constructor.name : "UnknownError",
            source: "vibekit",
            commandType: "execute",
          }
        );

        throw error;
      }
    }

    // Non-streaming path
    try {
      const result = await this.agent.executeCommand(command, agentOptions);

      await this.telemetryService?.trackEnd(
        agentType,
        "ask",
        command,
        result.sandboxId,
        this.setup.github?.repository,
        {
          exitCode: result.exitCode,
          stdoutLength: result.stdout?.length || 0,
          stderrLength: result.stderr?.length || 0,
          commandType: "execute",
        }
      );

      return result;
    } catch (error) {
      const errorMessage = `Command execution failed: ${
        error instanceof Error ? error.message : String(error)
      }`;

      await this.telemetryService?.trackError(
        agentType,
        "ask",
        command,
        errorMessage,
        {
          errorType:
            error instanceof Error ? error.constructor.name : "UnknownError",
          source: "vibekit",
          commandType: "execute",
        }
      );

      throw error;
    }
  }
}



================================================
FILE: src/services/sandbox.ts
================================================
import { Sandbox as E2BSandbox } from "@e2b/code-interpreter";
import { Daytona, DaytonaConfig, Sandbox } from "@daytonaio/sdk";

import {
  AgentType,
  SandboxCommandOptions,
  SandboxCommands,
  SandboxConfig,
  SandboxInstance,
  SandboxProvider,
} from "../types";
import {
  ApiClient,
  ApiClientInMemoryContextProvider,
  GetServicePortsResult,
} from "@northflank/js-client";

// E2B implementation
export class E2BSandboxInstance implements SandboxInstance {
  constructor(private sandbox: E2BSandbox) {}

  get sandboxId(): string {
    return this.sandbox.sandboxId;
  }

  get commands(): SandboxCommands {
    return {
      run: async (command: string, options?: SandboxCommandOptions) => {
        // Extract our custom options and pass the rest to E2B
        const { background, ...e2bOptions } = options || {};

        // E2B has specific overloads for background vs non-background execution
        if (background) {
          // For background execution, E2B returns a CommandHandle, not a CommandResult
          const handle = await this.sandbox.commands.run(command, {
            ...e2bOptions,
            background: true,
            onStdout: (data) => console.log("stdout", data),
            onStderr: (data) => console.log("stderr", data),
          });
          // Since we need to return SandboxExecutionResult consistently,
          // return a placeholder result for background commands

          return {
            exitCode: 0,
            stdout: "Background command started successfully",
            stderr: "",
          };
        } else {
          // For non-background execution, E2B returns a CommandResult
          return await this.sandbox.commands.run(command, e2bOptions);
        }
      },
    };
  }

  async kill(): Promise<void> {
    await this.sandbox.kill();
  }

  async pause(): Promise<void> {
    await this.sandbox.pause();
  }

  async getHost(port: number): Promise<string> {
    return await this.sandbox.getHost(port);
  }
}

export class E2BSandboxProvider implements SandboxProvider {
  async create(
    config: SandboxConfig,
    envs?: Record<string, string>,
    agentType?: AgentType
  ): Promise<SandboxInstance> {
    // Determine default template based on agent type if not specified in config
    let templateId = config.templateId;
    if (!templateId) {
      if (agentType === "claude") {
        templateId = "vibekit-claude";
      } else if (agentType === "opencode") {
        templateId = "vibekit-opencode";
      } else if (agentType === "gemini") {
        templateId = "vibekit-gemini";
      } else {
        templateId = "vibekit-codex";
      }
    }

    const sandbox = await E2BSandbox.create(templateId, {
      envs,
      apiKey: config.apiKey,
      timeoutMs: 3600000, // 1 hour in milliseconds
    });
    return new E2BSandboxInstance(sandbox);
  }

  async resume(
    sandboxId: string,
    config: SandboxConfig
  ): Promise<SandboxInstance> {
    const sandbox = await E2BSandbox.resume(sandboxId, {
      timeoutMs: 3600000,
      apiKey: config.apiKey,
    });
    return new E2BSandboxInstance(sandbox);
  }
}

// Daytona implementation
class DaytonaSandboxInstance implements SandboxInstance {
  constructor(
    private workspace: Sandbox, // Daytona workspace object
    private daytona: Daytona, // Daytona client
    public sandboxId: string,
    private envs?: Record<string, string> // Store environment variables
  ) {}

  get commands(): SandboxCommands {
    return {
      run: async (command: string, options?: SandboxCommandOptions) => {
        const session = await this.workspace.process.getSession(this.sandboxId);
        // Check if background execution is requested - not supported in Daytona
        if (options?.background) {
          const response = await this.workspace.process.executeSessionCommand(
            session.sessionId, // sessionId - using a default session name
            {
              command: command,
              runAsync: true, // run asynchronously for background execution
            },
            undefined // timeout - use default working directory
          );

          // Set up logging for the background command
          this.workspace.process.getSessionCommandLogs(
            session.sessionId,
            response.cmdId!,
            (chunk) => {
              options?.onStdout?.(chunk);
            }
          );

          // Wait for the command to complete
          while (true) {
            const commandInfo = await this.workspace.process.getSessionCommand(
              session.sessionId,
              response.cmdId!
            );

            const exitCode = commandInfo.exitCode;
            if (exitCode !== null && exitCode !== undefined) {
              return {
                exitCode: exitCode,
                stdout: "Background command started successfully",
                stderr: "", // SessionExecuteResponse doesn't have stderr
              };
            }

            // Wait before checking again
            await new Promise((resolve) => setTimeout(resolve, 500));
          }
        }

        try {
          // Execute command using Daytona's process execution API
          // Format: executeCommand(command, cwd?, env?, timeout?)
          const response = await this.workspace.process.executeSessionCommand(
            session.sessionId, // sessionId - using a default session name
            {
              command: command,
              runAsync: false,
            },
            undefined // timeout - use default working directory
          );

          return {
            exitCode: response.exitCode || 0,
            stdout: response.output || "",
            stderr: "", // ExecuteResponse doesn't have stderr
          };
        } catch (error) {
          const errorMessage =
            error instanceof Error ? error.message : String(error);
          if (options?.onStderr) {
            options.onStderr(errorMessage);
          }
          return {
            exitCode: 1,
            stdout: "",
            stderr: errorMessage,
          };
        }
      },
    };
  }

  async kill(): Promise<void> {
    if (this.daytona && this.workspace) {
      await this.daytona.delete(this.workspace);
    }
  }

  async pause(): Promise<void> {
    // Daytona doesn't have a direct pause equivalent
    console.log(
      "Pause not directly supported for Daytona sandboxes - workspace remains active"
    );
  }

  async getHost(port: number): Promise<string> {
    const previewLink = await this.workspace.getPreviewLink(port);
    return previewLink.url;
  }
}

export class DaytonaSandboxProvider implements SandboxProvider {
  async create(
    config: SandboxConfig,
    envs?: Record<string, string>,
    agentType?: AgentType
  ): Promise<SandboxInstance> {
    try {
      // Dynamic import to avoid dependency issues if daytona-sdk is not installed
      const daytonaConfig: DaytonaConfig = {
        apiKey: config.apiKey,
        apiUrl: config.serverUrl || "https://app.daytona.io",
      };

      const daytona = new Daytona(daytonaConfig);

      // Determine default image based on agent type if not specified in config
      let image = config.image || getDockerImageFromAgentType(agentType);

      // Create workspace with specified image or default and environment variables
      const workspace = await daytona.create({
        image,
        envVars: envs || {},
      });

      await workspace.process.createSession(workspace.id);

      return new DaytonaSandboxInstance(workspace, daytona, workspace.id, envs);
    } catch (error) {
      if (
        error instanceof Error &&
        error.message.includes("Cannot resolve module")
      ) {
        throw new Error(
          "Daytona SDK not found. Please install daytona-sdk: npm install daytona-sdk"
        );
      }
      throw new Error(
        `Failed to create Daytona sandbox: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
    }
  }

  async resume(
    sandboxId: string,
    config: SandboxConfig
  ): Promise<SandboxInstance> {
    try {
      const daytonaConfig: DaytonaConfig = {
        apiKey: config.apiKey,
        apiUrl: config.serverUrl || "https://app.daytona.io",
      };

      const daytona = new Daytona(daytonaConfig);

      // Resume workspace by ID
      const workspace = await daytona.get(sandboxId);

      return new DaytonaSandboxInstance(
        workspace,
        daytona,
        sandboxId,
        undefined
      );
    } catch (error) {
      throw new Error(
        `Failed to resume Daytona sandbox: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
    }
  }
}

export class NorthflankSandboxInstance implements SandboxInstance {
  constructor(
    private apiClient: ApiClient,
    public sandboxId: string,
    private projectId: string,
    private workingDirectory: string
  ) {}

  get commands(): SandboxCommands {
    return {
      run: async (command: string, options?: SandboxCommandOptions) => {
        if (options?.background) {
          const handle = await this.apiClient.exec.execServiceSession(
            {
              projectId: this.projectId,
              serviceId: this.sandboxId,
            },
            {
              shell: `bash -c`,
              command,
            }
          );

          handle.stdErr.on("data", (data) =>
            options.onStderr?.(data.toString())
          );
          handle.stdOut.on("data", (data) =>
            options.onStdout?.(data.toString())
          );

          return {
            exitCode: 0,
            stdout: "Background command started successfully",
            stderr: "",
          };
        }

        const handle = await this.apiClient.exec.execServiceSession(
          {
            projectId: this.projectId,
            serviceId: this.sandboxId,
          },
          {
            shell: `bash -c`,
            command,
          }
        );

        const stdoutChunks: string[] = [];
        const stderrChunks: string[] = [];

        handle.stdOut.on("data", (data) => {
          const chunk = data.toString();
          stdoutChunks.push(chunk);
          options?.onStdout?.(chunk);
        });

        handle.stdErr.on("data", (data) => {
          const chunk = data.toString();
          stderrChunks.push(chunk);
          options?.onStderr?.(chunk);
        });

        const result = await handle.waitForCommandResult();

        const fullStdout = stdoutChunks.join("");
        const fullStderr = stderrChunks.join("");

        //TODO: handle streaming callbacks if provided

        return {
          exitCode: result.exitCode,
          stdout: fullStdout,
          stderr: fullStderr,
        };
      },
    };
  }

  async kill(): Promise<void> {
    if (this.apiClient && this.sandboxId) {
      await this.apiClient.delete.service({
        parameters: {
          projectId: this.projectId,
          serviceId: this.sandboxId,
        },
      });
    }
  }

  async pause(): Promise<void> {
    await this.apiClient.scale.service({
      parameters: {
        projectId: this.projectId,
        serviceId: this.sandboxId,
      },
      data: {
        instances: 0,
      },
    });
  }

  async getHost(port: number): Promise<string> {
    const existingPorts = await this.apiClient.get.service.ports({
      parameters: {
        projectId: this.projectId,
        serviceId: this.sandboxId,
      },
    });

    const existingPort = existingPorts.data.ports?.find(
      (p) => p.internalPort === port
    );
    if (existingPort) {
      const host = existingPort.dns;
      if (host) {
        return host;
      }
    }

    const input = [
      ...existingPorts.data.ports
        .filter((p) => p.internalPort === port)
        .map((port) => ({
          id: port.id,
          name: port.name,
          internalPort: port.internalPort,
          public: port.public,
          protocol: port.protocol,
          domains: port.domains.map((domain) => domain.name),
        })),
      {
        name: `p-${port}`,
        internalPort: port,
        public: true,
        protocol: "HTTP" as const,
      },
    ].filter(Boolean);

    await this.apiClient.update.service.ports({
      parameters: {
        projectId: this.projectId,
        serviceId: this.sandboxId,
      },
      data: {
        ports: input,
      },
    });

    const newPorts = await this.apiClient.get.service.ports({
      parameters: {
        projectId: this.projectId,
        serviceId: this.sandboxId,
      },
    });

    return (
      newPorts.data.ports?.find(
        (p: GetServicePortsResult["ports"][number]) => p.internalPort === port
      )?.dns || ""
    );
  }
}

export class NorthflankSandboxProvider implements SandboxProvider {
  private static readonly DefaultBillingPlan = "nf-compute-200";
  private static readonly DefaultPersistentVolume = "/var/vibe0";
  private static readonly DefaultPersistentVolumeStorage = 10240; // 10GiB
  private static readonly StatusPollInterval = 1_000; // 1 second
  private static readonly MaxPollTimeout = 300000; // 5 minutes

  private async buildAPIClient(projectId: string, apiKey: string) {
    const contextProvider = new ApiClientInMemoryContextProvider();
    await contextProvider.addContext({
      name: "vibekit",
      project: projectId,
      token: apiKey,
    });
    return new ApiClient(contextProvider, { throwErrorOnHttpErrorCode: true });
  }

  private async getServiceStatus(
    apiClient: ApiClient,
    sandboxId: string,
    projectId: string
  ) {
    const deployment = await apiClient.get.service({
      parameters: {
        projectId: projectId,
        serviceId: sandboxId,
      },
    });
    return deployment.data?.status?.deployment?.status;
  }

  private async waitForSandbox(
    apiClient: ApiClient,
    sandboxId: string,
    projectId: string
  ): Promise<void> {
    const startTime = Date.now();

    while (Date.now() - startTime < NorthflankSandboxProvider.MaxPollTimeout) {
      const status = await this.getServiceStatus(
        apiClient,
        sandboxId,
        projectId
      );

      if (status === "COMPLETED") {
        return;
      }

      if (status === "FAILED") {
        throw new Error(`Sandbox deployment failed for ${sandboxId}`);
      }

      await new Promise((resolve) =>
        setTimeout(resolve, NorthflankSandboxProvider.StatusPollInterval)
      );
    }

    throw new Error(`Timeout waiting for sandbox ${sandboxId} to be ready`);
  }

  private generateSandboxId(): string {
    const uuid = crypto.randomUUID().split("-");
    return `sandbox-${uuid[4]}`;
  }

  async create(
    config: SandboxConfig,
    envs?: Record<string, string>,
    agentType?: AgentType
  ): Promise<SandboxInstance> {
    if (!config.projectId || !config.apiKey) {
      throw new Error(
        "Northflank sandbox configuration missing one of required parameters: projectId, apiKey"
      );
    }

    const apiClient = await this.buildAPIClient(
      config.projectId,
      config.apiKey
    );

    const sandboxId = this.generateSandboxId();
    await apiClient.create.service.deployment({
      parameters: {
        projectId: config.projectId,
      },
      data: {
        name: sandboxId,
        billing: {
          deploymentPlan:
            config.billingPlan || NorthflankSandboxProvider.DefaultBillingPlan,
        },
        deployment: {
          instances: 0,
          external: {
            imagePath: config.image || getDockerImageFromAgentType(agentType),
          },
          storage: {
            ephemeralStorage: {
              storageSize: 2048,
            },
          },
        },
        runtimeEnvironment: envs || {},
      },
    });

    await apiClient.create.volume({
      parameters: {
        projectId: config.projectId,
      },
      data: {
        name: `Data-${sandboxId}`,
        mounts: [
          {
            containerMountPath:
              config.workingDirectory ||
              NorthflankSandboxProvider.DefaultPersistentVolume,
          },
        ],
        spec: {
          accessMode: "ReadWriteMany",
          storageClassName: "ssd",
          storageSize:
            config.persistentVolumeStorage ??
            NorthflankSandboxProvider.DefaultPersistentVolumeStorage,
        },
        attachedObjects: [
          {
            id: sandboxId,
            type: "service",
          },
        ],
      },
    });

    await apiClient.scale.service({
      parameters: {
        projectId: config.projectId,
        serviceId: sandboxId,
      },
      data: {
        instances: 1,
      },
    });

    await this.waitForSandbox(apiClient, sandboxId, config.projectId);

    return new NorthflankSandboxInstance(
      apiClient,
      sandboxId,
      config.projectId,
      config.workingDirectory ||
        NorthflankSandboxProvider.DefaultPersistentVolume
    );
  }

  async resume(
    sandboxId: string,
    config: SandboxConfig
  ): Promise<SandboxInstance> {
    if (!config.projectId || !config.apiKey) {
      throw new Error(
        "Northflank sandbox configuration missing one of required parameters: projectId, apiKey"
      );
    }

    const apiClient = await this.buildAPIClient(
      config.projectId,
      config.apiKey
    );
    await apiClient.scale.service({
      parameters: {
        projectId: config.projectId,
        serviceId: sandboxId,
      },
      data: {
        instances: 1,
      },
    });

    // Wait for the service to be ready before returning the instance
    await this.waitForSandbox(apiClient, sandboxId, config.projectId);

    return new NorthflankSandboxInstance(
      apiClient,
      sandboxId,
      config.projectId,
      config.workingDirectory ||
        NorthflankSandboxProvider.DefaultPersistentVolume
    );
  }
}

// Factory function to create appropriate sandbox provider
export function createSandboxProvider(
  type: "e2b" | "daytona" | "northflank"
): SandboxProvider {
  switch (type) {
    case "e2b":
      return new E2BSandboxProvider();
    case "daytona":
      return new DaytonaSandboxProvider();
    case "northflank":
      return new NorthflankSandboxProvider();
    default:
      throw new Error(`Unsupported sandbox type: ${type}`);
  }
}

// Helper function to create SandboxConfig from VibeKitConfig environment
export function createSandboxConfigFromEnvironment(
  environment: any,
  agentType?: AgentType,
  workingDirectory?: string
): SandboxConfig {
  const defaultImage = getDockerImageFromAgentType(agentType);
  if (environment.northflank) {
    return {
      type: "northflank",
      apiKey: environment.northflank.apiKey,
      image: environment.northflank.image || defaultImage,
      serverUrl: environment.northflank.serverUrl,
      projectId: environment.northflank.projectId,
      billingPlan: environment.northflank.billingPlan,
      persistentVolume: environment.northflank.persistentVolume,
      workingDirectory: workingDirectory || "/var/vibe0",
    };
  }

  // Try Daytona first if configured
  if (environment.daytona) {
    return {
      type: "daytona",
      apiKey: environment.daytona.apiKey,
      image: environment.daytona.image || defaultImage,
      serverUrl: environment.daytona.serverUrl,
    };
  }

  // Fall back to E2B if configured
  if (environment.e2b) {
    // Determine default template based on agent type
    let defaultTemplate = "vibekit-codex"; // fallback
    if (agentType === "claude") {
      defaultTemplate = "vibekit-claude";
    } else if (agentType === "opencode") {
      defaultTemplate = "vibekit-opencode";
    }

    return {
      type: "e2b",
      apiKey: environment.e2b.apiKey,
      templateId: environment.e2b.templateId || defaultTemplate,
    };
  }

  throw new Error("No sandbox configuration found in environment config");
}

const getDockerImageFromAgentType = (agentType?: AgentType) => {
  if (agentType === "codex") {
    return "superagentai/vibekit-codex:1.0";
  } else if (agentType === "claude") {
    return "superagentai/vibekit-claude:1.0";
  } else if (agentType === "opencode") {
    return "superagentai/vibekit-opencode:1.0";
  } else if (agentType === "gemini") {
    return "superagentai/vibekit-gemini:1.0";
  }
  return "ubuntu:22.04";
};



================================================
FILE: src/services/telemetry.ts
================================================
import { TelemetryConfig } from "../types";
import { NodeSDK } from "@opentelemetry/sdk-node";
import { OTLPTraceExporter } from "@opentelemetry/exporter-trace-otlp-http";
import { resourceFromAttributes } from "@opentelemetry/resources";
import {
  ATTR_SERVICE_NAME,
  ATTR_SERVICE_VERSION,
} from "@opentelemetry/semantic-conventions";
import { trace, SpanStatusCode, SpanKind } from "@opentelemetry/api";

export interface TelemetryData {
  sessionId?: string;
  agentType: string;
  mode: string;
  prompt: string;
  timestamp: number;
  sandboxId?: string;
  repoUrl?: string;
  streamData?: string;
  eventType: "start" | "stream" | "end" | "error";
  metadata?: Record<string, any>;
}

export class TelemetryService {
  private config: TelemetryConfig;
  private sessionId: string;
  private tracer: any;
  private sdk?: NodeSDK;

  constructor(config: TelemetryConfig, sessionId?: string) {
    this.config = config;
    this.sessionId = sessionId || this.generateSessionId();

    if (this.config.isEnabled) {
      this.initializeOpenTelemetry();
    }
  }

  private generateSessionId(): string {
    return `vibekit-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  private shouldSample(): boolean {
    if (this.config.samplingRatio === undefined) return true;
    return Math.random() < this.config.samplingRatio;
  }

  private initializeOpenTelemetry(): void {
    if (!this.config.endpoint || !this.shouldSample()) {
      return;
    }

    try {
      // Create resource with service information and custom attributes
      const resource = resourceFromAttributes({
        [ATTR_SERVICE_NAME]: this.config.serviceName || "vibekit",
        [ATTR_SERVICE_VERSION]: this.config.serviceVersion || "1.0.0",
        ...this.config.resourceAttributes,
      });

      // Create OTLP trace exporter
      const traceExporter = new OTLPTraceExporter({
        url: this.config.endpoint,
        headers: this.config.headers || {},
        timeoutMillis: this.config.timeout || 5000,
      });

      // Initialize OpenTelemetry SDK
      this.sdk = new NodeSDK({
        resource: resource,
        traceExporter: traceExporter,
        instrumentations: [], // No auto-instrumentations needed for this use case
      });

      // Start the SDK
      this.sdk.start();

      // Get tracer
      this.tracer = trace.getTracer("vibekit", "1.0.0");
    } catch (error) {
      console.warn("Failed to initialize OpenTelemetry:", error);
    }
  }

  private createSpan(
    name: string,
    agentType: string,
    mode: string,
    prompt: string,
    metadata?: Record<string, any>
  ): any {
    if (!this.tracer) return null;

    const span = this.tracer.startSpan(name, {
      kind: SpanKind.INTERNAL,
      attributes: {
        "vibekit.session_id": this.sessionId,
        "vibekit.agent_type": agentType,
        "vibekit.mode": mode,
        "vibekit.event_type": name.replace("vibekit.", ""),
        "vibekit.prompt_length": prompt.length,
        ...metadata,
      },
    });

    return span;
  }

  public async trackStart(
    agentType: string,
    mode: string,
    prompt: string,
    metadata?: Record<string, any>
  ): Promise<void> {
    if (!this.config.isEnabled || !this.tracer) {
      return;
    }

    try {
      const span = this.createSpan(
        `vibekit.start`,
        agentType,
        mode,
        prompt,
        metadata
      );

      if (span) {
        // Add event to span
        span.addEvent("operation_started", {
          "vibekit.event_type": "start",
          timestamp: Date.now(),
        });

        // End span immediately for start events
        span.setStatus({ code: SpanStatusCode.OK });
        span.end();
      }
    } catch (error) {
      console.warn("Failed to track start event:", error);
    }
  }

  public async trackStream(
    agentType: string,
    mode: string,
    prompt: string,
    streamData: string,
    sandboxId?: string,
    repoUrl?: string,
    metadata?: Record<string, any>
  ): Promise<void> {
    if (!this.config.isEnabled || !this.tracer) {
      return;
    }

    try {
      const span = this.createSpan(`vibekit.stream`, agentType, mode, prompt, {
        "vibekit.sandbox_id": sandboxId || "",
        "vibekit.repo_url": repoUrl || "",
        "vibekit.stream_data_length": streamData.length,
        ...metadata,
      });

      if (span) {
        // Add stream data as an event
        span.addEvent("stream_data", {
          "vibekit.event_type": "stream",
          "stream.data": streamData,
          timestamp: Date.now(),
        });

        // End span immediately for stream events
        span.setStatus({ code: SpanStatusCode.OK });
        span.end();
      }
    } catch (error) {
      console.warn("Failed to track stream event:", error);
    }
  }

  public async trackEnd(
    agentType: string,
    mode: string,
    prompt: string,
    sandboxId?: string,
    repoUrl?: string,
    metadata?: Record<string, any>
  ): Promise<void> {
    if (!this.config.isEnabled || !this.tracer) {
      return;
    }

    try {
      const span = this.createSpan(`vibekit.end`, agentType, mode, prompt, {
        "vibekit.sandbox_id": sandboxId || "",
        "vibekit.repo_url": repoUrl || "",
        ...metadata,
      });

      if (span) {
        // Add event to span
        span.addEvent("operation_completed", {
          "vibekit.event_type": "end",
          timestamp: Date.now(),
        });

        // End span
        span.setStatus({ code: SpanStatusCode.OK });
        span.end();
      }
    } catch (error) {
      console.warn("Failed to track end event:", error);
    }
  }

  public async trackError(
    agentType: string,
    mode: string,
    prompt: string,
    error: string,
    metadata?: Record<string, any>
  ): Promise<void> {
    if (!this.config.isEnabled || !this.tracer) {
      return;
    }

    try {
      const span = this.createSpan(
        `vibekit.error`,
        agentType,
        mode,
        prompt,
        metadata
      );

      if (span) {
        // Record the error
        span.recordException(new Error(error));

        // Add error event
        span.addEvent("error_occurred", {
          "vibekit.event_type": "error",
          "error.message": error,
          timestamp: Date.now(),
        });

        // Set error status
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: error,
        });

        span.end();
      }
    } catch (err) {
      console.warn("Failed to track error event:", err);
    }
  }

  /**
   * Gracefully shutdown the OpenTelemetry SDK
   */
  public async shutdown(): Promise<void> {
    if (this.sdk) {
      try {
        await this.sdk.shutdown();
      } catch (error) {
        console.warn("Failed to shutdown OpenTelemetry SDK:", error);
      }
    }
  }
}



================================================
FILE: templates/codex-clone/README.md
================================================
# CloneDex

An OpenAI Codex clone built with Next.js, VibeKit SDK, and Inngest. This application allows you to generate code using AI models with real-time updates and GitHub integration.

## 🔗 Demo 

[https://clonedex.vercel.app/](https://clonedex.vercel.app/)

## ✨ Features

- 🤖 AI-powered code generation using OpenAI
- 🔄 Real-time task updates with Inngest
- 🐙 GitHub integration for repository management
- 🌍 E2B sandboxed environment execution
- 🎨 Modern UI with Tailwind CSS and shadcn/ui
- 📝 Markdown rendering with syntax highlighting
- 🗃️ Zustand state management (easily replaceable with any remote database)

## 🚀 Prerequisites

Before you begin, make sure you have:

- **Node.js** (v18 or higher)
- **npm** or **yarn**
- **Inngest CLI** (required for local development)
- An **OpenAI API key**
- An **E2B API key**
- A **GitHub OAuth app** (for GitHub integration)

## 📦 Installation

### 1. Install Dependencies

```bash
npm install
```

### 2. Install Inngest CLI

The Inngest CLI is essential for running background functions locally:

```bash
# Install globally
npm install -g inngest

# Or using npx (recommended)
npx inngest-cli@latest
```

### 3. Set Up Environment Variables

Create a `.env.local` file in the root directory with the following variables:

```bash
# OpenAI Configuration
OPENAI_API_KEY=your_openai_api_key_here

# E2B Configuration (for sandboxed environments)
E2B_API_KEY=your_e2b_api_key_here

# GitHub OAuth Configuration
GITHUB_CLIENT_ID=your_github_client_id
GITHUB_CLIENT_SECRET=your_github_client_secret
```

#### Getting API Keys:

- **OpenAI API Key**: Get it from [OpenAI Platform](https://platform.openai.com/api-keys)
- **E2B API Key**: Sign up at [E2B](https://e2b.dev/) and get your API key
- **GitHub OAuth**: Create a new OAuth app in your [GitHub Developer Settings](https://github.com/settings/developers)

## 🛠️ Development

### 1. Start the Inngest Dev Server

In one terminal, start the Inngest development server:

```bash
npx inngest-cli@latest dev
```

This will start the Inngest development server on `http://localhost:8288`.

### 2. Start the Next.js Development Server

In another terminal, start the Next.js application:

```bash
npm run dev
```

The application will be available at `http://localhost:3000`.

## 📋 Available Scripts

- `npm run dev` - Start the development server with Turbopack
- `npm run build` - Build the application for production
- `npm start` - Start the production server
- `npm run lint` - Run ESLint for code quality

## 🏗️ Project Structure

```
├── app/                    # Next.js App Router
│   ├── _components/        # Page-specific components
│   ├── actions/           # Server actions
│   ├── api/               # API routes
│   └── auth/              # Authentication routes
├── components/            # Reusable UI components
│   └── ui/                # shadcn/ui components
├── hooks/                 # Custom React hooks
├── lib/                   # Utility libraries and configurations
├── stores/                # Zustand state management
└── public/                # Static assets
```

## 🔧 Configuration

### Inngest Functions

The application uses Inngest for background task processing. The main function is defined in `lib/inngest.ts`:

- **`createTask`**: Handles AI code generation with real-time updates
- **Task Channel**: Manages real-time communication for task status and updates

### VibeKit Integration

The app integrates with VibeKit SDK for AI code generation, supporting:

- Multiple AI models (currently OpenAI)
- E2B sandboxed environments
- GitHub repository integration
- Real-time streaming updates

## 🌐 Deployment

### Environment Variables for Production

Make sure to set all required environment variables in your production environment:

```bash
GITHUB_CLIENT_ID=
GITHUB_CLIENT_SECRET=
E2B_API_KEY=
OPENAI_API_KEY=
ANTHROPIC_API_KEY=
```

### Deploy to Vercel

1. Connect your repository to Vercel
2. Set the environment variables in the Vercel dashboard
3. Deploy

### Inngest in Production

For production, you'll need to configure Inngest properly:

1. Set up an Inngest account at [inngest.com](https://inngest.com)
2. Configure your production Inngest endpoint
3. Update your deployment to use the production Inngest configuration

## 🤝 Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## 📄 License

This project is licensed under the MIT License.

## 🆘 Troubleshooting

### Common Issues

1. **Inngest functions not working**: Make sure the Inngest CLI is running (`npx inngest-cli@latest dev`)
2. **API key errors**: Verify all environment variables are set correctly
3. **GitHub OAuth issues**: Check your GitHub OAuth app configuration and callback URLs
4. **E2B connection problems**: Ensure your E2B API key is valid and has sufficient credits

### Getting Help

- Check the [Inngest Documentation](https://www.inngest.com/docs)
- Visit [VibeKit Documentation](https://vibekit.dev/docs)
- Review [Next.js Documentation](https://nextjs.org/docs)

---

Built with ❤️ using Next.js, VibeKit, and Inngest



================================================
FILE: templates/codex-clone/components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}


================================================
FILE: templates/codex-clone/eslint.config.mjs
================================================
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;



================================================
FILE: templates/codex-clone/next.config.ts
================================================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;



================================================
FILE: templates/codex-clone/package.json
================================================
{
  "name": "codex-clone",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@ai-sdk/openai": "^1.3.22",
    "@inngest/realtime": "^0.3.1",
    "@radix-ui/react-dialog": "^1.1.14",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-scroll-area": "^1.2.9",
    "@radix-ui/react-select": "^2.2.5",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slot": "^1.2.3",
    "@radix-ui/react-tabs": "^1.1.12",
    "@radix-ui/react-tooltip": "^1.2.7",
    "@vibe-kit/sdk": "^0.0.21",
    "ai": "^4.3.16",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "framer-motion": "^12.16.0",
    "inngest": "^3.39.1",
    "lucide-react": "^0.513.0",
    "next": "15.3.3",
    "next-themes": "^0.4.6",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-markdown": "^10.1.0",
    "react-syntax-highlighter": "^15.6.1",
    "rehype-raw": "^7.0.0",
    "remark-gfm": "^4.0.1",
    "tailwind-merge": "^3.3.0",
    "zod": "^3.25.56",
    "zustand": "^5.0.5"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/react-syntax-highlighter": "^15.5.13",
    "eslint": "^9",
    "eslint-config-next": "15.3.3",
    "tailwindcss": "^4",
    "tw-animate-css": "^1.3.4",
    "typescript": "^5"
  }
}



================================================
FILE: templates/codex-clone/postcss.config.mjs
================================================
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;



================================================
FILE: templates/codex-clone/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}



================================================
FILE: templates/codex-clone/.env.example
================================================
#Github OAuth app credentials
GITHUB_CLIENT_ID=
GITHUB_CLIENT_SECRET=

# Sandbox
E2B_API_KEY=

# If using Codex
OPENAI_API_KEY=

# If using Claude Code
ANTHROPIC_API_KEY=


================================================
FILE: templates/codex-clone/app/client-page.tsx
================================================
"use client";

import Navbar from "@/components/navbar";
import TaskList from "./_components/task-list";
import TaskForm from "./_components/task-form";

export default function ClientPage() {
  return (
    <div className="flex flex-col px-4 py-2 h-screen gap-y-4">
      <Navbar />
      <TaskForm />
      <TaskList />
    </div>
  );
}



================================================
FILE: templates/codex-clone/app/container.tsx
================================================
"use client";
import { useInngestSubscription } from "@inngest/realtime/hooks";
import { useEffect } from "react";

import { fetchRealtimeSubscriptionToken } from "@/app/actions/inngest";
import { useTaskStore } from "@/stores/tasks";

export default function Container({ children }: { children: React.ReactNode }) {
  const { updateTask, getTaskById } = useTaskStore();
  const { latestData } = useInngestSubscription({
    refreshToken: fetchRealtimeSubscriptionToken,
    bufferInterval: 0,
    enabled: true,
  });

  useEffect(() => {
    if (latestData?.channel === "tasks" && latestData.topic === "status") {
      updateTask(latestData.data.taskId, {
        status: latestData.data.status,
        hasChanges: true,
        sessionId: latestData.data.sessionId,
      });
    }

    if (latestData?.channel === "tasks" && latestData.topic === "update") {
      if (latestData.data.message.type === "git") {
        updateTask(latestData.data.taskId, {
          statusMessage: latestData.data.message.output as string,
        });
      }

      if (latestData.data.message.type === "local_shell_call") {
        const task = getTaskById(latestData.data.taskId);
        updateTask(latestData.data.taskId, {
          statusMessage: `Running command ${(
            latestData.data.message as { action: { command: string[] } }
          ).action.command.join(" ")}`,
          messages: [
            ...(task?.messages || []),
            {
              role: "assistant",
              type: "local_shell_call",
              data: latestData.data.message,
            },
          ],
        });
      }

      if (latestData.data.message.type === "local_shell_call_output") {
        const task = getTaskById(latestData.data.taskId);
        updateTask(latestData.data.taskId, {
          messages: [
            ...(task?.messages || []),
            {
              role: "assistant",
              type: "local_shell_call_output",
              data: latestData.data.message,
            },
          ],
        });
      }

      if (
        latestData.data.message.type === "message" &&
        latestData.data.message.status === "completed" &&
        latestData.data.message.role === "assistant"
      ) {
        const task = getTaskById(latestData.data.taskId);

        updateTask(latestData.data.taskId, {
          messages: [
            ...(task?.messages || []),
            {
              role: "assistant",
              type: "message",
              data: (latestData.data.message.content as { text: string }[])[0],
            },
          ],
        });
      }
    }
  }, [latestData]);

  return children;
}



================================================
FILE: templates/codex-clone/app/globals.css
================================================
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
  --color-sidebar-ring: var(--sidebar-ring);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar: var(--sidebar);
  --color-chart-5: var(--chart-5);
  --color-chart-4: var(--chart-4);
  --color-chart-3: var(--chart-3);
  --color-chart-2: var(--chart-2);
  --color-chart-1: var(--chart-1);
  --color-ring: var(--ring);
  --color-input: var(--input);
  --color-border: var(--border);
  --color-destructive: var(--destructive);
  --color-accent-foreground: var(--accent-foreground);
  --color-accent: var(--accent);
  --color-muted-foreground: var(--muted-foreground);
  --color-muted: var(--muted);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-secondary: var(--secondary);
  --color-primary-foreground: var(--primary-foreground);
  --color-primary: var(--primary);
  --color-popover-foreground: var(--popover-foreground);
  --color-popover: var(--popover);
  --color-card-foreground: var(--card-foreground);
  --color-card: var(--card);
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.145 0 0);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.145 0 0);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.145 0 0);
  --primary: oklch(0.205 0 0);
  --primary-foreground: oklch(0.985 0 0);
  --secondary: oklch(0.97 0 0);
  --secondary-foreground: oklch(0.205 0 0);
  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);
  --accent: oklch(0.97 0 0);
  --accent-foreground: oklch(0.205 0 0);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.922 0 0);
  --input: oklch(0.922 0 0);
  --ring: oklch(0.708 0 0);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: oklch(0.145 0 0);
  --sidebar-primary: oklch(0.205 0 0);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: oklch(0.205 0 0);
  --sidebar-border: oklch(0.922 0 0);
  --sidebar-ring: oklch(0.708 0 0);
}

.dark {
  --background: oklch(0.145 0 0);
  --foreground: oklch(0.985 0 0);
  --card: oklch(0.205 0 0);
  --card-foreground: oklch(0.985 0 0);
  --popover: oklch(0.205 0 0);
  --popover-foreground: oklch(0.985 0 0);
  --primary: oklch(0.922 0 0);
  --primary-foreground: oklch(0.205 0 0);
  --secondary: oklch(0.269 0 0);
  --secondary-foreground: oklch(0.985 0 0);
  --muted: oklch(0.269 0 0);
  --muted-foreground: oklch(0.708 0 0);
  --accent: oklch(0.269 0 0);
  --accent-foreground: oklch(0.985 0 0);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.556 0 0);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.205 0 0);
  --sidebar-foreground: oklch(0.985 0 0);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.269 0 0);
  --sidebar-accent-foreground: oklch(0.985 0 0);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.556 0 0);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}

@layer utilities {
  /* Custom animations for chat messages */
  @keyframes slide-in-from-left {
    0% {
      transform: translateX(-20px);
      opacity: 0;
    }
    100% {
      transform: translateX(0);
      opacity: 1;
    }
  }

  @keyframes slide-in-from-right {
    0% {
      transform: translateX(20px);
      opacity: 0;
    }
    100% {
      transform: translateX(0);
      opacity: 1;
    }
  }

  @keyframes slide-in-from-bottom {
    0% {
      transform: translateY(10px);
      opacity: 0;
    }
    100% {
      transform: translateY(0);
      opacity: 1;
    }
  }

  .animate-in {
    animation-fill-mode: both;
  }

  .slide-in-from-left {
    animation-name: slide-in-from-left;
  }

  .slide-in-from-right {
    animation-name: slide-in-from-right;
  }

  .slide-in-from-bottom {
    animation-name: slide-in-from-bottom;
  }

  .duration-300 {
    animation-duration: 300ms;
  }

  /* Custom scrollbar styling */
  .scroll-area-custom::-webkit-scrollbar {
    width: 6px;
  }

  .scroll-area-custom::-webkit-scrollbar-track {
    background: transparent;
  }

  .scroll-area-custom::-webkit-scrollbar-thumb {
    @apply bg-muted-foreground/20 rounded-full;
  }

  .scroll-area-custom::-webkit-scrollbar-thumb:hover {
    @apply bg-muted-foreground/30;
  }

  /* Smooth transitions for theme switching */
  * {
    @apply transition-colors duration-200;
  }
}



================================================
FILE: templates/codex-clone/app/layout.tsx
================================================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import { ThemeProvider } from "next-themes";
import "./globals.css";
import "./streaming.css";

import Container from "./container";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "VibeX | An open-source OpenAI Codex clone",
  description:
    "Codex UI is a modern, open-source, and fully customizable UI for OpenAI Codex.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <ThemeProvider
          attribute="class"
          defaultTheme="system"
          enableSystem
          disableTransitionOnChange
        >
          <Container>{children}</Container>
        </ThemeProvider>
      </body>
    </html>
  );
}



================================================
FILE: templates/codex-clone/app/page.tsx
================================================
import ClientPage from "./client-page";

export default function Home() {
  return <ClientPage />;
}



================================================
FILE: templates/codex-clone/app/streaming.css
================================================
@keyframes shimmer {
  0% { 
    transform: translateX(-100%); 
  }
  100% { 
    transform: translateX(100%); 
  }
}


================================================
FILE: templates/codex-clone/app/_components/task-form.tsx
================================================
"use client";
import { HardDrive, Split } from "lucide-react";
import { useRef, useEffect, useState } from "react";

import { Button } from "@/components/ui/button";
import { useEnvironmentStore } from "@/stores/environments";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useGitHubAuth } from "@/hooks/use-github-auth";
import { useTaskStore } from "@/stores/tasks";
import { createTaskAction } from "@/app/actions/inngest";
import Link from "next/link";

export default function TaskForm() {
  const { environments } = useEnvironmentStore();
  const { addTask } = useTaskStore();
  const { branches, fetchBranches } = useGitHubAuth();
  const [selectedBranch, setSelectedBranch] = useState<string>(
    branches.find((branch) => branch.isDefault)?.name || ""
  );
  const [selectedEnvironment, setSelectedEnvironment] = useState<string>(
    environments[0]?.id || ""
  );
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const [value, setValue] = useState("");

  const adjustHeight = () => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.style.height = "100px"; // Reset to min height
      textarea.style.height = Math.max(100, textarea.scrollHeight) + "px";
    }
  };

  const handleAddTask = async (mode: "code" | "ask") => {
    if (value) {
      const task = addTask({
        title: value,
        hasChanges: false,
        description: "",
        messages: [],
        status: "IN_PROGRESS",
        branch: selectedBranch,
        sessionId: "",
        repository:
          environments.find((env) => env.id === selectedEnvironment)
            ?.githubRepository || "",
        mode,
      });
      await createTaskAction({ task });
      setValue("");
    }
  };

  useEffect(() => {
    adjustHeight();
  }, [value]);

  // Set initial environment when environments load
  useEffect(() => {
    if (environments.length > 0 && !selectedEnvironment) {
      setSelectedEnvironment(environments[0].id);
    }
  }, [environments, selectedEnvironment]);

  useEffect(() => {
    if (selectedEnvironment) {
      const environment = environments.find(
        (env) => env.id === selectedEnvironment
      );

      if (environment?.githubRepository) {
        fetchBranches(environment.githubRepository);
      }
    }
  }, [selectedEnvironment]);

  useEffect(() => {
    if (branches.length > 0) {
      setSelectedBranch(
        branches.find((branch) => branch.isDefault)?.name || ""
      );
    }
  }, [branches]);

  return (
    <div className="max-w-3xl mx-auto w-full flex flex-col gap-y-10 mt-14">
      <h1 className="text-4xl text-center font-bold">
        Ready to ship something new?
      </h1>
      <div className="p-0.5 rounded-lg bg-muted">
        <div className="flex flex-col gap-y-2 border bg-background rounded-lg p-4">
          <textarea
            ref={textareaRef}
            value={value}
            onChange={(e) => setValue(e.target.value)}
            placeholder="Describe a task you want to ship..."
            className="w-full min-h-[100px] resize-none border-none p-0 focus:outline-none focus:border-transparent overflow-hidden"
          />
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-x-2">
              {environments.length > 0 ? (
                <Select
                  onValueChange={(value) => setSelectedEnvironment(value)}
                  value={selectedEnvironment || ""}
                >
                  <SelectTrigger>
                    <HardDrive />
                    <SelectValue placeholder="Choose a repository" />
                  </SelectTrigger>
                  <SelectContent>
                    {environments.map((environment) => (
                      <SelectItem key={environment.id} value={environment.id}>
                        <div className="flex w-full">
                          <span className="truncate max-w-[150px]">
                            {environment.githubRepository}
                          </span>
                        </div>
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              ) : (
                <Link passHref href="/environments">
                  <Button className="rounded-lg" variant="outline">
                    <HardDrive />
                    Create an environment
                  </Button>
                </Link>
              )}
              {selectedEnvironment && (
                <Select
                  onValueChange={(value) => setSelectedBranch(value)}
                  value={selectedBranch}
                >
                  <SelectTrigger>
                    <Split />
                    <SelectValue placeholder="Branch..." />
                  </SelectTrigger>
                  <SelectContent>
                    {branches.map((branch) => (
                      <SelectItem key={branch.name} value={branch.name}>
                        <div className="flex w-full">
                          <span>{branch.name}</span>
                        </div>
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              )}
            </div>
            {value && (
              <div className="flex items-center gap-x-2">
                <Button variant="outline" onClick={() => handleAddTask("ask")}>
                  Ask
                </Button>
                <Button onClick={() => handleAddTask("code")}>Code</Button>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: templates/codex-clone/app/_components/task-list.tsx
================================================
"use client";
import { Archive, Check, Dot, Trash2 } from "lucide-react";
import { formatDistanceToNow } from "date-fns";
import { useEffect, useState } from "react";

import { useTaskStore } from "@/stores/tasks";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { TextShimmer } from "@/components/ui/text-shimmer";
import Link from "next/link";

export default function TaskList() {
  const [isHydrated, setIsHydrated] = useState(false);
  const { getActiveTasks, getArchivedTasks, archiveTask, removeTask } =
    useTaskStore();
  const activeTasks = getActiveTasks();
  const archivedTasks = getArchivedTasks();

  useEffect(() => {
    setIsHydrated(true);
  }, []);

  return (
    <div className="max-w-3xl mx-auto w-full p-1 rounded-lg bg-muted">
      <Tabs defaultValue="active">
        <TabsList>
          <TabsTrigger value="active">
            <Check />
            Tasks
          </TabsTrigger>
          <TabsTrigger value="archived">
            <Archive />
            Archive
          </TabsTrigger>
        </TabsList>
        <TabsContent value="active">
          <div className="flex flex-col gap-1">
            {!isHydrated ? (
              <p className="text-muted-foreground p-2">Loading tasks...</p>
            ) : activeTasks.length === 0 ? (
              <p className="text-muted-foreground p-2">No active tasks yet.</p>
            ) : (
              activeTasks.map((task) => (
                <div
                  key={task.id}
                  className="border rounded-lg bg-background p-4 flex items-center justify-between hover:bg-sidebar"
                >
                  <Link href={`/task/${task.id}`} className="flex-1">
                    <div>
                      <div className="flex items-center gap-x-2">
                        {task.hasChanges && (
                          <div className="size-2 rounded-full bg-blue-500 " />
                        )}
                        <h3 className="font-medium">{task.title}</h3>
                      </div>
                      {task.status === "IN_PROGRESS" ? (
                        <div>
                          <TextShimmer className="text-sm">
                            {`${
                              task.statusMessage || "Working on your task"
                            }...`}
                          </TextShimmer>
                        </div>
                      ) : (
                        <div className="flex items-center gap-0">
                          <p className="text-sm text-muted-foreground">
                            {task.createdAt
                              ? formatDistanceToNow(new Date(task.createdAt), {
                                  addSuffix: true,
                                })
                              : "Just now"}
                          </p>
                          <Dot className="size-4 text-muted-foreground" />
                          <p className="text-sm text-muted-foreground">
                            {task.repository}
                          </p>
                        </div>
                      )}
                    </div>
                  </Link>
                  {task.status === "DONE" && (
                    <Button
                      variant="outline"
                      size="icon"
                      onClick={() => archiveTask(task.id)}
                    >
                      <Archive />
                    </Button>
                  )}
                </div>
              ))
            )}
          </div>
        </TabsContent>
        <TabsContent value="archived">
          <div className="flex flex-col gap-1">
            {!isHydrated ? (
              <p className="text-muted-foreground p-2">Loading tasks...</p>
            ) : archivedTasks.length === 0 ? (
              <p className="text-muted-foreground p-2">
                No archived tasks yet.
              </p>
            ) : (
              archivedTasks.map((task) => (
                <div
                  key={task.id}
                  className="border rounded-lg p-4 flex items-center justify-between bg-background"
                >
                  <div>
                    <h3 className="font-medium text-muted-foreground">
                      {task.title}
                    </h3>
                    <p className="text-sm text-muted-foreground">
                      Status: {task.status} • Branch: {task.branch}
                    </p>
                  </div>
                  <Button
                    variant="outline"
                    size="icon"
                    onClick={(e) => {
                      e.stopPropagation();
                      removeTask(task.id);
                    }}
                  >
                    <Trash2 />
                  </Button>
                </div>
              ))
            )}
          </div>
        </TabsContent>
      </Tabs>
    </div>
  );
}



================================================
FILE: templates/codex-clone/app/actions/inngest.ts
================================================
"use server";
import { cookies } from "next/headers";
import { getSubscriptionToken, Realtime } from "@inngest/realtime";

import { inngest } from "@/lib/inngest";
import { Task } from "@/stores/tasks";
import { getInngestApp, taskChannel } from "@/lib/inngest";

export type TaskChannelToken = Realtime.Token<
  typeof taskChannel,
  ["status", "update"]
>;

export const createTaskAction = async ({
  task,
  sessionId,
  prompt,
}: {
  task: Task;
  sessionId?: string;
  prompt?: string;
}) => {
  const cookieStore = await cookies();
  const githubToken = cookieStore.get("github_access_token")?.value;

  if (!githubToken) {
    throw new Error("No GitHub token found. Please authenticate first.");
  }

  await inngest.send({
    name: "clonedex/create.task",
    data: {
      task,
      token: githubToken,
      sessionId: sessionId,
      prompt: prompt,
    },
  });
};

export const createPullRequestAction = async ({
  sessionId,
}: {
  sessionId?: string;
}) => {
  const cookieStore = await cookies();
  const githubToken = cookieStore.get("github_access_token")?.value;

  if (!githubToken) {
    throw new Error("No GitHub token found. Please authenticate first.");
  }

  await inngest.send({
    name: "clonedex/create.pull-request",
    data: {
      token: githubToken,
      sessionId: sessionId,
    },
  });
};

export async function fetchRealtimeSubscriptionToken(): Promise<TaskChannelToken> {
  const token = await getSubscriptionToken(getInngestApp(), {
    channel: taskChannel(),
    topics: ["status", "update"],
  });

  return token;
}



================================================
FILE: templates/codex-clone/app/actions/vibekit.ts
================================================
"use server";

import { cookies } from "next/headers";
import { VibeKit, VibeKitConfig } from "@vibe-kit/sdk";
import { Task } from "@/stores/tasks";

export const createPullRequestAction = async ({ task }: { task: Task }) => {
  const cookieStore = await cookies();
  const githubToken = cookieStore.get("github_access_token")?.value;

  if (!githubToken) {
    throw new Error("No GitHub token found. Please authenticate first.");
  }

  const config: VibeKitConfig = {
    agent: {
      type: "codex",
      model: {
        apiKey: process.env.OPENAI_API_KEY!,
      },
    },
    environment: {
      e2b: {
        apiKey: process.env.E2B_API_KEY!,
      },
    },
    github: {
      token: githubToken,
      repository: task.repository,
    },
    sessionId: task.sessionId,
  };

  const vibekit = new VibeKit(config);

  const pr = await vibekit.createPullRequest();

  return pr;
};



================================================
FILE: templates/codex-clone/app/api/auth/github/branches/route.ts
================================================
import { NextRequest, NextResponse } from "next/server";

interface GitHubBranch {
  name: string;
  commit: {
    sha: string;
    url: string;
  };
  protected: boolean;
}

export async function GET(request: NextRequest) {
  try {
    // Get the access token from the httpOnly cookie
    const accessToken = request.cookies.get("github_access_token")?.value;

    if (!accessToken) {
      return NextResponse.json({ error: "Not authenticated" }, { status: 401 });
    }

    // Get repository from query parameters
    const { searchParams } = new URL(request.url);
    const owner = searchParams.get("owner");
    const repo = searchParams.get("repo");

    if (!owner || !repo) {
      return NextResponse.json(
        { error: "Owner and repo parameters are required" },
        { status: 400 }
      );
    }

    // First fetch repository info to get the default branch
    const repoResponse = await fetch(
      `https://api.github.com/repos/${owner}/${repo}`,
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          Accept: "application/vnd.github.v3+json",
        },
      }
    );

    if (!repoResponse.ok) {
      if (repoResponse.status === 404) {
        return NextResponse.json(
          { error: "Repository not found" },
          { status: 404 }
        );
      }
      throw new Error(`Failed to fetch repository: ${repoResponse.statusText}`);
    }

    const repoData = await repoResponse.json();
    const defaultBranch = repoData.default_branch;

    // Fetch branches from GitHub API
    const response = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/branches`,
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          Accept: "application/vnd.github.v3+json",
        },
      }
    );

    if (!response.ok) {
      if (response.status === 404) {
        return NextResponse.json(
          { error: "Repository not found" },
          { status: 404 }
        );
      }
      throw new Error(`Failed to fetch branches: ${response.statusText}`);
    }

    const branches: GitHubBranch[] = await response.json();

    return NextResponse.json({
      branches: branches.map((branch: GitHubBranch) => ({
        name: branch.name,
        commit: {
          sha: branch.commit.sha,
          url: branch.commit.url,
        },
        protected: branch.protected || false,
        isDefault: branch.name === defaultBranch,
      })),
    });
  } catch (error) {
    console.error("Error fetching branches:", error);
    return NextResponse.json(
      { error: "Failed to fetch branches" },
      { status: 500 }
    );
  }
}



================================================
FILE: templates/codex-clone/app/api/auth/github/callback/route.ts
================================================
import { NextRequest, NextResponse } from "next/server";
import { githubAuth } from "@/lib/github";

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const code = searchParams.get("code");
  const error = searchParams.get("error");

  // Handle OAuth errors
  if (error) {
    return NextResponse.redirect(new URL(`/?error=${error}`, request.url));
  }

  if (!code) {
    return NextResponse.redirect(new URL("/?error=missing_code", request.url));
  }

  try {
    // Exchange code for access token
    const accessToken = await githubAuth.exchangeCodeForToken(code);

    // Get user info
    const user = await githubAuth.getUser(accessToken);

    // Create the response with a redirect to close the popup
    const response = NextResponse.redirect(
      new URL("/auth/success", request.url)
    );

    // Set the access token in an httpOnly cookie (secure)
    response.cookies.set("github_access_token", accessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "lax",
      maxAge: 60 * 60 * 24 * 7, // 7 days
    });

    // Set user info in a readable cookie for the frontend
    response.cookies.set(
      "github_user",
      JSON.stringify({
        id: user.id,
        login: user.login,
        avatar_url: user.avatar_url,
        name: user.name,
      }),
      {
        secure: process.env.NODE_ENV === "production",
        sameSite: "lax",
        maxAge: 60 * 60 * 24 * 7, // 7 days
      }
    );

    return response;
  } catch (error) {
    console.error("GitHub OAuth error:", error);
    return NextResponse.redirect(new URL("/?error=oauth_failed", request.url));
  }
}



================================================
FILE: templates/codex-clone/app/api/auth/github/repositories/route.ts
================================================
import { NextRequest, NextResponse } from "next/server";
import { githubAuth } from "@/lib/github";

export async function GET(request: NextRequest) {
  try {
    // Get the access token from the httpOnly cookie
    const accessToken = request.cookies.get("github_access_token")?.value;

    if (!accessToken) {
      return NextResponse.json({ error: "Not authenticated" }, { status: 401 });
    }

    // Fetch repositories
    const repositories = await githubAuth.getUserRepositories(accessToken);

    // Filter to only include repositories the user has push access to
    const userRepos = repositories.filter(
      (repo) =>
        !repo.fork && // Exclude forks
        repo.permissions?.push !== false // Only repos with push access
    );

    return NextResponse.json({
      repositories: userRepos.map((repo) => ({
        id: repo.id,
        name: repo.name,
        full_name: repo.full_name,
        private: repo.private,
        description: repo.description,
        html_url: repo.html_url,
        default_branch: repo.default_branch,
      })),
    });
  } catch (error) {
    console.error("Error fetching repositories:", error);
    return NextResponse.json(
      { error: "Failed to fetch repositories" },
      { status: 500 }
    );
  }
}



================================================
FILE: templates/codex-clone/app/api/auth/github/url/route.ts
================================================
import { NextResponse } from "next/server";
import { githubAuth } from "@/lib/github";

export async function GET() {
  try {
    const authUrl = githubAuth.getAuthUrl();

    return NextResponse.json({ url: authUrl });
  } catch (error) {
    console.error("Error generating auth URL:", error);
    return NextResponse.json(
      { error: "Failed to generate auth URL" },
      { status: 500 }
    );
  }
}



================================================
FILE: templates/codex-clone/app/api/inngest/route.ts
================================================
import { serve } from "inngest/next";
import { inngest, createTask } from "@/lib/inngest";

export const maxDuration = 800;

export const { GET, POST, PUT } = serve({
  client: inngest,
  functions: [createTask],
});



================================================
FILE: templates/codex-clone/app/auth/success/page.tsx
================================================
"use client";

import { useEffect } from "react";

export default function AuthSuccessPage() {
  useEffect(() => {
    // Close the popup and notify the parent window
    if (window.opener) {
      window.opener.postMessage({ type: "GITHUB_AUTH_SUCCESS" }, "*");
      window.close();
    } else {
      // If not in a popup, redirect to home
      window.location.href = "/";
    }
  }, []);

  return (
    <div className="flex items-center justify-center min-h-screen">
      <div className="text-center">
        <h1 className="text-2xl font-bold mb-4">Authentication Successful!</h1>
        <p className="text-muted-foreground">
          This window will close automatically...
        </p>
      </div>
    </div>
  );
}



================================================
FILE: templates/codex-clone/app/environments/client-page.tsx
================================================
"use client";
import Navbar from "@/components/navbar";
import EnvironmentsList from "./_components/environments-list";

export default function EnvironmentsClientPage() {
  return (
    <div className="flex flex-col gap-y-4 px-4 py-2 h-screen">
      <Navbar />
      <EnvironmentsList />
    </div>
  );
}



================================================
FILE: templates/codex-clone/app/environments/page.tsx
================================================
import EnvironmentsClientPage from "./client-page";

export default function EnvironmentsPage() {
  return <EnvironmentsClientPage />;
}



================================================
FILE: templates/codex-clone/app/environments/_components/create-environment-dialog.tsx
================================================
"use client";
import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { useEnvironmentStore } from "@/stores/environments";
import { useGitHubAuth } from "@/hooks/use-github-auth";

interface CreateEnvironmentDialogProps {
  isOpen: boolean;
  onOpenChange: (open: boolean) => void;
}

export function CreateEnvironmentDialog({
  isOpen,
  onOpenChange,
}: CreateEnvironmentDialogProps) {
  const { isAuthenticated, repositories, fetchRepositories } = useGitHubAuth();
  const { createEnvironment } = useEnvironmentStore();

  // Form state
  const [formData, setFormData] = useState({
    name: "",
    description: "",
    selectedRepository: "",
  });
  const [isCreating, setIsCreating] = useState(false);

  useEffect(() => {
    if (isAuthenticated && isOpen) {
      fetchRepositories();
    }
  }, [isAuthenticated, isOpen, fetchRepositories]);

  const resetForm = () => {
    setFormData({
      name: "",
      description: "",
      selectedRepository: "",
    });
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!formData.name.trim() || !formData.selectedRepository) {
      return;
    }

    setIsCreating(true);

    try {
      // Get GitHub access token from cookies
      const githubTokenCookie = document.cookie
        .split("; ")
        .find((row) => row.startsWith("github_access_token="));

      const githubToken = githubTokenCookie?.split("=")[1] || "";

      // Parse organization and repository from full_name (owner/repo)
      const [githubOrganization] = formData.selectedRepository.split("/");

      // Create the environment
      createEnvironment({
        name: formData.name.trim(),
        description: formData.description.trim(),
        githubOrganization,
        githubToken,
        githubRepository: formData.selectedRepository,
      });

      // Reset form and close dialog
      resetForm();
      onOpenChange(false);
    } catch (error) {
      console.error("Failed to create environment:", error);
    } finally {
      setIsCreating(false);
    }
  };

  const isFormValid = formData.name.trim() && formData.selectedRepository;

  return (
    <Dialog
      open={isOpen}
      onOpenChange={(open) => {
        onOpenChange(open);
        if (!open) {
          resetForm();
        }
      }}
    >
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Create a new environment</DialogTitle>
        </DialogHeader>
        <form onSubmit={handleSubmit} className="flex flex-col gap-y-4">
          <div className="flex flex-col gap-y-2">
            <label htmlFor="name" className="text-sm font-medium">
              Environment name *
            </label>
            <input
              id="name"
              type="text"
              value={formData.name}
              onChange={(e) =>
                setFormData((prev) => ({ ...prev, name: e.target.value }))
              }
              placeholder="Enter environment name"
              className="w-full h-9 px-3 py-2 text-sm border border-input rounded-md bg-background focus:outline-none focus:ring-[3px] focus:ring-ring/50 focus:border-ring disabled:cursor-not-allowed disabled:opacity-50"
              required
            />
          </div>

          <div className="flex flex-col gap-y-2">
            <label htmlFor="description" className="text-sm font-medium">
              Description
            </label>
            <textarea
              id="description"
              value={formData.description}
              onChange={(e) =>
                setFormData((prev) => ({
                  ...prev,
                  description: e.target.value,
                }))
              }
              placeholder="Enter environment description"
              rows={3}
              className="w-full px-3 py-2 text-sm border border-input rounded-md bg-background focus:outline-none focus:ring-[3px] focus:ring-ring/50 focus:border-ring disabled:cursor-not-allowed disabled:opacity-50 resize-none"
            />
          </div>

          <div className="flex flex-col gap-y-2">
            <label htmlFor="repository" className="text-sm font-medium">
              Select your Github repository *
            </label>
            <Select
              value={formData.selectedRepository}
              onValueChange={(value) =>
                setFormData((prev) => ({
                  ...prev,
                  selectedRepository: value,
                }))
              }
            >
              <SelectTrigger className="w-full">
                <SelectValue placeholder="Choose a repository" />
              </SelectTrigger>
              <SelectContent>
                {repositories.map((repo) => (
                  <SelectItem key={repo.id} value={repo.full_name}>
                    <div className="flex">
                      <span>{repo.full_name}</span>
                    </div>
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div className="flex justify-end gap-2 pt-4">
            <Button
              type="button"
              variant="outline"
              onClick={() => onOpenChange(false)}
              disabled={isCreating}
            >
              Cancel
            </Button>
            <Button type="submit" disabled={!isFormValid || isCreating}>
              {isCreating ? "Creating..." : "Create Environment"}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
}



================================================
FILE: templates/codex-clone/app/environments/_components/environments-list.tsx
================================================
"use client";
import { Dot, FolderGit, GithubIcon, Plus, Trash2 } from "lucide-react";
import { useState } from "react";
import { format } from "date-fns";

import { Button } from "@/components/ui/button";
import { useEnvironmentStore } from "@/stores/environments";
import { useGitHubAuth } from "@/hooks/use-github-auth";
import { Skeleton } from "@/components/ui/skeleton";
import Link from "next/link";
import { CreateEnvironmentDialog } from "./create-environment-dialog";

export default function EnvironmentsList() {
  const { isAuthenticated, login, isLoading } = useGitHubAuth();
  const { environments, deleteEnvironment } = useEnvironmentStore();
  const [isDialogOpen, setIsDialogOpen] = useState<boolean>(false);

  const handleGitHubAuth = async () => {
    await login();
  };

  const handleDeleteEnvironment = (environmentId: string) => {
    if (confirm("Are you sure you want to delete this environment?")) {
      deleteEnvironment(environmentId);
    }
  };

  if (isLoading) {
    return (
      <div className="max-w-2xl mx-auto w-full flex flex-col gap-y-10 mt-14">
        <div className="flex items-center justify-between">
          <p className="font-medium">Environments</p>
          <Skeleton className="w-22 h-9" />
        </div>
        <div className="flex flex-col gap-y-4">
          {Array.from({ length: 5 }).map((_, index) => (
            <Skeleton className="h-20 w-full" key={index} />
          ))}
        </div>
      </div>
    );
  }

  console.log(isAuthenticated);

  return (
    <>
      <div className="max-w-2xl mx-auto w-full flex flex-col gap-y-10 mt-14">
        <div className="flex items-center justify-between">
          <p className="font-medium">Environments</p>
          {isAuthenticated ? (
            <Button onClick={() => setIsDialogOpen(true)}>
              <Plus />
              Add new
            </Button>
          ) : (
            <Button onClick={handleGitHubAuth}>
              <GithubIcon />
              Connect your Github account
            </Button>
          )}
        </div>
        {isAuthenticated ? (
          <div className="flex flex-col gap-y-4">
            {environments.map((environment) => (
              <div
                key={environment.id}
                className="flex items-center justify-between border rounded-lg p-4"
              >
                <div className="flex flex-col">
                  <p className="font-medium">{environment.name}</p>
                  <div className="flex items-center gap-x-0">
                    <Link
                      href={`https://github.com/${environment.githubRepository}`}
                      passHref
                    >
                      <div className="flex items-center gap-x-1">
                        <FolderGit className="size-4 text-muted-foreground" />
                        <p className="text-muted-foreground hover:text-primary transition-colors text-sm">
                          {environment.githubOrganization}
                        </p>
                      </div>
                    </Link>
                    {environment.createdAt && (
                      <>
                        <Dot className="text-muted-foreground/40" />
                        <p className="text-muted-foreground text-sm">
                          Created{" "}
                          {format(
                            new Date(environment.createdAt),
                            "MMM d, yyyy"
                          )}
                        </p>
                      </>
                    )}
                  </div>
                </div>
                <Button
                  variant="outline"
                  size="icon"
                  onClick={() => handleDeleteEnvironment(environment.id)}
                >
                  <Trash2 className="h-4 w-4" />
                </Button>
              </div>
            ))}
          </div>
        ) : (
          <div className="flex flex-col gap-y-4">
            <p className="text-muted-foreground">
              Connect your Github account to get started
            </p>
          </div>
        )}
      </div>
      <CreateEnvironmentDialog
        isOpen={isDialogOpen}
        onOpenChange={setIsDialogOpen}
      />
    </>
  );
}



================================================
FILE: templates/codex-clone/app/task/[id]/client-page.tsx
================================================
"use client";
import { useInngestSubscription } from "@inngest/realtime/hooks";
import { useEffect, useRef, useState } from "react";

import TaskNavbar from "./_components/navbar";
import MessageInput from "./_components/message-input";
import { ScrollArea } from "@/components/ui/scroll-area";
import { fetchRealtimeSubscriptionToken } from "@/app/actions/inngest";
import { useTaskStore } from "@/stores/tasks";
import { Terminal, Bot, User, Loader } from "lucide-react";
import { TextShimmer } from "@/components/ui/text-shimmer";
import { Markdown } from "@/components/markdown";
import { StreamingIndicator } from "@/components/streaming-indicator";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { cn } from "@/lib/utils";

interface Props {
  id: string;
}

interface StreamingMessage {
  role: "user" | "assistant";
  type: string;
  data: Record<string, unknown> & {
    text?: string;
    isStreaming?: boolean;
    streamId?: string;
    chunkIndex?: number;
    totalChunks?: number;
  };
}

interface IncomingMessage {
  role: "user" | "assistant";
  type: string;
  data: Record<string, unknown> & {
    text?: string;
    isStreaming?: boolean;
    streamId?: string;
    chunkIndex?: number;
    totalChunks?: number;
    call_id?: string;
    action?: {
      command?: string[];
    };
    output?: string;
  };
}

// Type guard to check if a message has streaming properties
function isStreamingMessage(message: unknown): message is IncomingMessage & {
  data: { isStreaming: true; streamId: string };
} {
  return (
    typeof message === "object" &&
    message !== null &&
    "type" in message &&
    message.type === "message" &&
    "data" in message &&
    typeof message.data === "object" &&
    message.data !== null &&
    "isStreaming" in message.data &&
    message.data.isStreaming === true &&
    "streamId" in message.data &&
    typeof message.data.streamId === "string"
  );
}

// Type guard to check if a message is a completed stream
function isCompletedStreamMessage(
  message: unknown
): message is IncomingMessage & {
  data: { streamId: string; isStreaming: false };
} {
  return (
    typeof message === "object" &&
    message !== null &&
    "type" in message &&
    message.type === "message" &&
    "data" in message &&
    typeof message.data === "object" &&
    message.data !== null &&
    "streamId" in message.data &&
    typeof message.data.streamId === "string" &&
    (!("isStreaming" in message.data) || message.data.isStreaming === false)
  );
}

// Type guard to check if message is a valid incoming message
function isValidIncomingMessage(message: unknown): message is IncomingMessage {
  return (
    typeof message === "object" &&
    message !== null &&
    "role" in message &&
    "type" in message &&
    "data" in message &&
    (message.role === "user" || message.role === "assistant") &&
    typeof message.type === "string" &&
    typeof message.data === "object"
  );
}

export default function TaskClientPage({ id }: Props) {
  const { getTaskById, updateTask } = useTaskStore();
  const task = getTaskById(id);
  const scrollAreaRef = useRef<HTMLDivElement>(null);
  const chatScrollAreaRef = useRef<HTMLDivElement>(null);
  const [subscriptionEnabled, setSubscriptionEnabled] = useState(true);
  const [streamingMessages, setStreamingMessages] = useState<
    Map<string, StreamingMessage>
  >(new Map());

  // Function to get the output message for a given shell call message
  const getOutputForCall = (callId: string) => {
    return task?.messages.find(
      (message) =>
        message.type === "local_shell_call_output" &&
        message.data?.call_id === callId
    );
  };

  const { latestData } = useInngestSubscription({
    refreshToken: fetchRealtimeSubscriptionToken,
    bufferInterval: 0,
    enabled: subscriptionEnabled,
  });

  useEffect(() => {
    if (latestData?.channel === "tasks" && latestData.topic === "update") {
      const { taskId, message } = latestData.data;

      if (taskId === id && message && isValidIncomingMessage(message)) {
        // Handle streaming messages
        if (isStreamingMessage(message)) {
          const streamId = message.data.streamId;

          setStreamingMessages((prev) => {
            const newMap = new Map(prev);
            const existingMessage = newMap.get(streamId);

            if (existingMessage) {
              // Append to existing streaming message
              newMap.set(streamId, {
                ...existingMessage,
                data: {
                  ...existingMessage.data,
                  text:
                    (existingMessage.data.text || "") +
                    (message.data.text || ""),
                  chunkIndex: message.data.chunkIndex,
                  totalChunks: message.data.totalChunks,
                },
              });
            } else {
              // New streaming message
              newMap.set(streamId, message as StreamingMessage);
            }

            return newMap;
          });
        } else if (isCompletedStreamMessage(message)) {
          // Stream ended, move to regular messages
          const streamId = message.data.streamId;
          const streamingMessage = streamingMessages.get(streamId);

          if (streamingMessage) {
            updateTask(id, {
              messages: [
                ...(task?.messages || []),
                {
                  ...streamingMessage,
                  data: {
                    ...streamingMessage.data,
                    text: message.data.text || streamingMessage.data.text,
                    isStreaming: false,
                  },
                },
              ],
            });

            setStreamingMessages((prev) => {
              const newMap = new Map(prev);
              newMap.delete(streamId);
              return newMap;
            });
          }
        } else {
          // Regular non-streaming message
          updateTask(id, {
            messages: [...(task?.messages || []), message],
          });
        }
      }
    }
  }, [latestData, id, task?.messages, streamingMessages, updateTask]);

  // Auto-scroll to bottom when messages change or streaming messages update
  useEffect(() => {
    if (chatScrollAreaRef.current) {
      const viewport = chatScrollAreaRef.current.querySelector(
        "[data-radix-scroll-area-viewport]"
      );
      if (viewport) {
        viewport.scrollTo({
          top: viewport.scrollHeight,
          behavior: "smooth",
        });
      }
    }
  }, [task?.messages, streamingMessages]);

  useEffect(() => {
    if (task) {
      updateTask(task.id, {
        hasChanges: false,
      });
    }
  }, []);

  // Cleanup subscription on unmount to prevent stream cancellation errors
  useEffect(() => {
    return () => {
      setSubscriptionEnabled(false);
    };
  }, []);

  return (
    <div className="flex flex-col h-screen">
      <TaskNavbar id={id} />
      <div className="flex flex-1 overflow-hidden">
        {/* Sidebar for chat messages */}
        <div className="w-full max-w-3xl mx-auto border-r border-border bg-gradient-to-b from-background to-muted/5 flex flex-col h-full">
          <ScrollArea
            ref={chatScrollAreaRef}
            className="flex-1 overflow-y-auto scroll-area-custom"
          >
            <div className="p-6 flex flex-col gap-y-6">
              {/* Initial task message */}
              <div className="flex justify-end animate-in slide-in-from-right duration-300">
                <div className="max-w-[85%] flex gap-3">
                  <div className="bg-primary text-primary-foreground rounded-2xl px-5 py-3 shadow-sm">
                    <p className="text-sm leading-relaxed">{task?.title}</p>
                  </div>
                  <div className="flex-shrink-0">
                    <div className="w-8 h-8 rounded-full bg-primary/10 flex items-center justify-center">
                      <User className="w-4 h-4 text-primary" />
                    </div>
                  </div>
                </div>
              </div>
              {/* Render regular messages */}
              {task?.messages
                .filter(
                  (message) =>
                    (message.role === "assistant" || message.role === "user") &&
                    message.type === "message"
                )
                .map((message, index) => {
                  const isAssistant = message.role === "assistant";
                  return (
                    <div
                      key={
                        (message.data as { id?: string })?.id ||
                        `message-${index}-${message.role}` ||
                        index
                      }
                      className={cn(
                        "flex gap-3 animate-in duration-300",
                        isAssistant
                          ? "justify-start slide-in-from-left"
                          : "justify-end slide-in-from-right"
                      )}
                    >
                      {isAssistant && (
                        <div className="flex-shrink-0">
                          <div className="w-8 h-8 rounded-full bg-muted flex items-center justify-center border border-border">
                            <Bot className="w-4 h-4 text-muted-foreground" />
                          </div>
                        </div>
                      )}
                      <div
                        className={cn(
                          "max-w-[85%] rounded-2xl px-5 py-3 shadow-sm",
                          isAssistant
                            ? "bg-card border border-border"
                            : "bg-primary text-primary-foreground"
                        )}
                      >
                        {isAssistant ? (
                          <div className="prose prose-sm dark:prose-invert max-w-none overflow-hidden">
                            <Markdown
                              repoUrl={
                                task?.repository
                                  ? `https://github.com/${task.repository}`
                                  : undefined
                              }
                              branch={task?.branch}
                            >
                              {message.data?.text as string}
                            </Markdown>
                          </div>
                        ) : (
                          <p className="text-sm leading-relaxed break-words">
                            {message.data?.text as string}
                          </p>
                        )}
                      </div>
                      {!isAssistant && (
                        <div className="flex-shrink-0">
                          <div className="w-8 h-8 rounded-full bg-primary/10 flex items-center justify-center">
                            <User className="w-4 h-4 text-primary" />
                          </div>
                        </div>
                      )}
                    </div>
                  );
                })}

              {/* Render streaming messages */}
              {Array.from(streamingMessages.values()).map((message) => {
                const isAssistant = message.role === "assistant";
                return (
                  <div
                    key={message.data.streamId as string}
                    className={cn(
                      "flex gap-3 animate-in duration-300",
                      isAssistant
                        ? "justify-start slide-in-from-left"
                        : "justify-end slide-in-from-right"
                    )}
                  >
                    {isAssistant && (
                      <div className="flex-shrink-0">
                        <div className="w-8 h-8 rounded-full bg-muted flex items-center justify-center border border-border relative overflow-hidden">
                          <Bot className="w-4 h-4 text-muted-foreground z-10 relative" />
                          <div
                            className="absolute inset-0 bg-gradient-to-r from-transparent via-primary/20 to-transparent"
                            style={{
                              animation: "shimmer 2s linear infinite",
                              backgroundSize: "200% 100%",
                            }}
                          />
                        </div>
                      </div>
                    )}
                    <div
                      className={cn(
                        "max-w-[85%] rounded-2xl px-5 py-3 shadow-sm",
                        isAssistant
                          ? "bg-card border border-border"
                          : "bg-primary text-primary-foreground"
                      )}
                    >
                      {isAssistant ? (
                        <div className="prose prose-sm dark:prose-invert max-w-none overflow-hidden">
                          <Markdown
                            repoUrl={
                              task?.repository
                                ? `https://github.com/${task.repository}`
                                : undefined
                            }
                            branch={task?.branch}
                          >
                            {message.data?.text as string}
                          </Markdown>
                          {/* Enhanced streaming indicator */}
                          <span className="inline-flex items-center gap-2 ml-1">
                            <StreamingIndicator size="sm" variant="cursor" />
                            {typeof message.data.chunkIndex === "number" &&
                              typeof message.data.totalChunks === "number" && (
                                <span className="text-[10px] text-muted-foreground/60 font-mono">
                                  {Math.round(
                                    ((message.data.chunkIndex + 1) /
                                      message.data.totalChunks) *
                                      100
                                  )}
                                  %
                                </span>
                              )}
                          </span>
                        </div>
                      ) : (
                        <p className="text-sm leading-relaxed break-words">
                          {message.data?.text as string}
                        </p>
                      )}
                    </div>
                    {!isAssistant && (
                      <div className="flex-shrink-0">
                        <div className="w-8 h-8 rounded-full bg-primary/10 flex items-center justify-center">
                          <User className="w-4 h-4 text-primary" />
                        </div>
                      </div>
                    )}
                  </div>
                );
              })}

              {task?.status === "IN_PROGRESS" &&
                streamingMessages.size === 0 && (
                  <div className="flex justify-start animate-in slide-in-from-left duration-300">
                    <div className="flex gap-3">
                      <div className="flex-shrink-0">
                        <div className="w-8 h-8 rounded-full bg-muted flex items-center justify-center border border-border animate-pulse">
                          <Bot className="w-4 h-4 text-muted-foreground" />
                        </div>
                      </div>
                      <div className="bg-card border border-border rounded-2xl px-5 py-3 shadow-sm">
                        <div className="flex items-center gap-2">
                          <Loader className="w-4 h-4 text-muted-foreground animate-spin" />
                          <TextShimmer className="text-sm">
                            {task?.statusMessage
                              ? `${task.statusMessage}`
                              : "Working on task..."}
                          </TextShimmer>
                        </div>
                      </div>
                    </div>
                  </div>
                )}
            </div>
          </ScrollArea>

          {/* Message input component - fixed at bottom */}
          <div className="flex-shrink-0">
            <MessageInput task={task!} />
          </div>
        </div>

        {/* Right panel for details */}
        <div className="flex-1 bg-gradient-to-br from-muted/50 to-background relative">
          {/* Fade overlay at the top */}
          <div className="absolute top-0 left-0 right-0 h-20 bg-gradient-to-b from-muted/50 to-transparent pointer-events-none z-10" />
          <ScrollArea ref={scrollAreaRef} className="h-full scroll-area-custom">
            <div className="max-w-4xl mx-auto w-full py-10 px-6">
              {/* Details content will go here */}
              <div className="flex flex-col gap-y-10">
                {task?.messages.map((message) => {
                  if (message.type === "local_shell_call") {
                    const output = getOutputForCall(
                      message.data?.call_id as string
                    );
                    return (
                      <div
                        key={message.data?.call_id as string}
                        className="flex flex-col"
                      >
                        <div className="flex items-start gap-x-2">
                          <TooltipProvider>
                            <Tooltip>
                              <TooltipTrigger asChild>
                                <p className="font-medium font-mono text-sm -mt-1 truncate max-w-md cursor-help">
                                  {(
                                    message.data as {
                                      action?: { command?: string[] };
                                    }
                                  )?.action?.command
                                    ?.slice(1)
                                    .join(" ")}
                                </p>
                              </TooltipTrigger>
                              <TooltipContent>
                                <p className="max-w-sm break-words">
                                  {(
                                    message.data as {
                                      action?: { command?: string[] };
                                    }
                                  )?.action?.command
                                    ?.slice(1)
                                    .join(" ")}
                                </p>
                              </TooltipContent>
                            </Tooltip>
                          </TooltipProvider>
                        </div>
                        {output && (
                          <div className="mt-3 animate-in slide-in-from-bottom duration-300">
                            <div className="rounded-xl bg-card border-2 border-border shadow-sm overflow-hidden transition-all duration-200 hover:shadow-md">
                              <div className="flex items-center gap-2 bg-muted/50 border-b px-4 py-3">
                                <Terminal className="size-4 text-muted-foreground" />
                                <span className="font-medium text-sm text-muted-foreground">
                                  Output
                                </span>
                              </div>
                              <ScrollArea className="max-h-[400px]">
                                <pre className="whitespace-pre-wrap font-mono text-xs leading-relaxed p-4 text-muted-foreground">
                                  {(() => {
                                    try {
                                      const parsed = JSON.parse(
                                        (output.data as { output?: string })
                                          ?.output || "{}"
                                      );
                                      return parsed.output || "No output";
                                    } catch {
                                      return "Failed to parse output";
                                    }
                                  })()}
                                </pre>
                              </ScrollArea>
                            </div>
                          </div>
                        )}
                      </div>
                    );
                  }
                  return null;
                })}
              </div>
            </div>
          </ScrollArea>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: templates/codex-clone/app/task/[id]/page.tsx
================================================
import TaskClientPage from "./client-page";

interface Props {
  params: Promise<{ id: string }>;
}

export default async function TaskPage({ params }: Props) {
  const { id } = await params;

  return <TaskClientPage id={id} />;
}



================================================
FILE: templates/codex-clone/app/task/[id]/_components/message-input.tsx
================================================
"use client";
import { useEffect, useRef, useState } from "react";
import { Send } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Task } from "@/stores/tasks";
import { createTaskAction } from "@/app/actions/inngest";
import { useTaskStore } from "@/stores/tasks";

export default function MessageInput({ task }: { task: Task }) {
  const { updateTask } = useTaskStore();
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const [messageValue, setMessageValue] = useState("");

  const adjustHeight = () => {
    const textarea = textareaRef.current;
    if (textarea) {
      textarea.style.height = "60px"; // Reset to min height
      textarea.style.height = Math.max(60, textarea.scrollHeight) + "px";
    }
  };

  const handleSendMessage = async () => {
    if (messageValue.trim()) {
      await createTaskAction({
        task,
        prompt: messageValue,
        sessionId: task.sessionId,
      });

      updateTask(task.id, {
        ...task,
        status: "IN_PROGRESS",
        statusMessage: "Working on task",
        messages: [
          ...task.messages,
          {
            role: "user",
            type: "message",
            data: { text: messageValue, id: crypto.randomUUID() },
          },
        ],
      });

      setMessageValue("");
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  useEffect(() => {
    adjustHeight();
  }, [messageValue]);

  return (
    <div className="p-6 border-t border-border bg-background">
      <div className="relative">
        <div className="bg-card border-2 border-border rounded-2xl shadow-lg transition-all duration-200 hover:shadow-xl focus-within:border-primary/50 focus-within:shadow-xl">
          <div className="flex flex-col gap-y-3 p-4">
            <textarea
              ref={textareaRef}
              value={messageValue}
              onChange={(e) => setMessageValue(e.target.value)}
              onKeyPress={handleKeyPress}
              placeholder="Type your message..."
              className="w-full min-h-[60px] max-h-[200px] resize-none border-none p-0 focus:outline-none bg-transparent placeholder:text-muted-foreground/60 text-sm leading-relaxed"
              style={{ scrollbarWidth: "thin" }}
            />
            <div className="flex items-center justify-between">
              <span className="text-xs text-muted-foreground">
                Press Enter to send, Shift+Enter for new line
              </span>
              <Button
                size="sm"
                onClick={handleSendMessage}
                disabled={!messageValue.trim()}
                className="rounded-xl transition-all duration-200 hover:scale-105"
              >
                <Send className="size-4 mr-1" />
                Send
              </Button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}



================================================
FILE: templates/codex-clone/app/task/[id]/_components/navbar.tsx
================================================
"use client";
import Link from "next/link";
import {
  Archive,
  ArrowLeft,
  Dot,
  GitBranchPlus,
  GithubIcon,
  Loader,
} from "lucide-react";
import { formatDistanceToNow } from "date-fns";
import { useCallback, useState } from "react";

import { Button } from "@/components/ui/button";
import { useTaskStore } from "@/stores/tasks";
import { createPullRequestAction } from "@/app/actions/vibekit";

interface Props {
  id: string;
}

export default function TaskNavbar({ id }: Props) {
  const [isCreatingPullRequest, setIsCreatingPullRequest] = useState(false);
  const { getTaskById, updateTask } = useTaskStore();
  const task = getTaskById(id);

  const handleCreatePullRequest = useCallback(async () => {
    if (!task) return;

    setIsCreatingPullRequest(true);

    const pr = await createPullRequestAction({ task });

    updateTask(id, {
      pullRequest: pr,
    });

    setIsCreatingPullRequest(false);
  }, [task, id, updateTask]);

  const handleArchiveTask = useCallback(() => {
    if (!task) return;

    updateTask(id, {
      isArchived: !task.isArchived,
    });
  }, [task, id, updateTask]);

  return (
    <div className="h-14 border-b flex items-center justify-between px-4">
      <div className="flex items-center gap-x-2">
        <Link href="/">
          <Button variant="ghost" size="icon">
            <ArrowLeft />
          </Button>
        </Link>
        <div className="h-8 border-r" />
        <div className="flex flex-col gap-x-2 ml-4">
          <h3 className=" font-medium">{task?.title}</h3>
          <div className="flex items-center gap-x-0">
            <p className="text-sm text-muted-foreground">
              {task?.createdAt
                ? formatDistanceToNow(new Date(task.createdAt), {
                    addSuffix: true,
                  })
                : "Loading..."}
            </p>
            <Dot className="size-4 text-muted-foreground" />
            <p className="text-sm text-muted-foreground">{task?.repository}</p>
          </div>
        </div>
      </div>
      <div className="flex items-center gap-x-2">
        {task?.isArchived ? (
          <Button
            variant="outline"
            className="rounded-full"
            onClick={handleArchiveTask}
          >
            <Archive />
            Unarchive
          </Button>
        ) : (
          <Button
            variant="outline"
            className="rounded-full"
            onClick={handleArchiveTask}
          >
            <Archive />
            Archive
          </Button>
        )}
        {task?.pullRequest ? (
          <Link href={task.pullRequest.html_url} target="_blank">
            <Button className="rounded-full">
              <GithubIcon />
              View Pull Request
            </Button>
          </Link>
        ) : (
          <Button
            className="rounded-full"
            onClick={handleCreatePullRequest}
            disabled={isCreatingPullRequest}
          >
            {isCreatingPullRequest ? (
              <Loader className="animate-spin size-4" />
            ) : (
              <GitBranchPlus />
            )}
            Create Pull Request
          </Button>
        )}
      </div>
    </div>
  );
}



================================================
FILE: templates/codex-clone/components/markdown.tsx
================================================
import React, { memo, useState } from "react";
import ReactMarkdown, { type Components } from "react-markdown";
import remarkGfm from "remark-gfm";
import rehypeRaw from "rehype-raw";
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter";
import { CopyIcon, CheckIcon } from "lucide-react";
import { useTheme } from "next-themes";
import {
  oneDark,
  oneLight,
} from "react-syntax-highlighter/dist/cjs/styles/prism";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { Separator } from "@/components/ui/separator";
import {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
} from "@/components/ui/table";
import { ScrollArea, ScrollBar } from "@/components/ui/scroll-area";

type CodeComponentProps = React.ComponentPropsWithoutRef<"code"> & {
  inline?: boolean;
  className?: string;
  children?: React.ReactNode;
  style?: React.CSSProperties;
};

export const CodeComponent: React.FC<CodeComponentProps> = ({
  inline,
  className,
  children,
  ...props
}) => {
  const match = /language-(\w+)/.exec(className || "");
  const { theme } = useTheme();
  const [copied, setCopied] = useState(false);

  if (inline) {
    return (
      <code
        className="text-sm bg-background dark:bg-zinc-800 py-0.5 px-1 rounded-md"
        style={{ wordBreak: "break-all" }}
        {...props}
      >
        {children}
      </code>
    );
  }

  // Code block with language
  if (match) {
    return (
      <div className="border rounded-lg bg-background my-2 overflow-hidden">
        <div className="flex items-center justify-between bg-sidebar px-2 py-1 border-b">
          <span className="text-xs text-muted-foreground">{match[1]}</span>
          <Button
            variant="ghost"
            size="icon"
            className="size-7"
            onClick={() => {
              navigator.clipboard.writeText(String(children));
              setCopied(true);
              setTimeout(() => setCopied(false), 2000);
            }}
          >
            {copied ? (
              <CheckIcon className="w-4 h-4 text-green-500" />
            ) : (
              <CopyIcon className="w-4 h-4" />
            )}
          </Button>
        </div>
        <ScrollArea className="max-w-full">
          <div className="px-4 py-2" style={{ maxWidth: "100%" }}>
            <SyntaxHighlighter
              language={match[1]}
              style={theme === "dark" ? oneDark : oneLight}
              customStyle={{
                fontSize: "12.5px",
                backgroundColor: "transparent",
                padding: "0",
                margin: "0",
                background: "none",
                overflow: "visible",
              }}
              wrapLongLines={false}
              PreTag="div"
              codeTagProps={{
                style: {
                  whiteSpace: "pre",
                  display: "block",
                },
              }}
            >
              {String(children).replace(/\n$/, "")}
            </SyntaxHighlighter>
          </div>
        </ScrollArea>
      </div>
    );
  }

  // Code block without language
  return (
    <code
      className="relative rounded !bg-sidebar border border-muted-foreground/20 px-[0.3rem] py-[0.2rem] font-mono text-xs"
      style={{ wordBreak: "break-word" }}
    >
      {children}
    </code>
  );
};

const components: Partial<Components> = {
  code: CodeComponent,
  pre: ({ children }) => <>{children}</>,
  ol: ({ children, ...props }) => (
    <ol className="list-decimal list-outside ml-4" {...props}>
      {children}
    </ol>
  ),
  li: ({ children, ...props }) => (
    <li className="py-1" {...props}>
      {children}
    </li>
  ),
  ul: ({ children, ...props }) => (
    <ul className="list-disc list-outside ml-4" {...props}>
      {children}
    </ul>
  ),
  strong: ({ children, ...props }) => (
    <span className="font-semibold" {...props}>
      {children}
    </span>
  ),
  p: ({ children, ...props }) => (
    <p
      className="mb-2"
      style={{ wordBreak: "break-word", overflowWrap: "break-word" }}
      {...props}
    >
      {children}
    </p>
  ),
  a: ({ children, href, ...props }) => {
    // Check if the URL is external (starts with http/https) or internal
    const isExternal = href?.startsWith("http") || href?.startsWith("https");

    if (isExternal) {
      return (
        <a
          className="text-blue-500 hover:underline"
          style={{
            wordBreak: "break-word",
            overflowWrap: "break-word",
          }}
          href={href}
          target="_blank"
          rel="noreferrer"
          {...props}
        >
          {children}
        </a>
      );
    }

    return (
      <Link
        passHref
        className="text-blue-500 hover:underline"
        style={{
          wordBreak: "break-word",
          overflowWrap: "break-word",
        }}
        href={href || "#"}
        target="_blank"
        rel="noreferrer"
        {...props}
      >
        {children}
      </Link>
    );
  },
  h1: ({ children, ...props }) => (
    <h1
      className="text-3xl font-semibold mt-6 mb-2"
      style={{ wordBreak: "break-word" }}
      {...props}
    >
      {children}
    </h1>
  ),
  h2: ({ children, ...props }) => (
    <h2
      className="text-2xl font-semibold mt-6 mb-2"
      style={{ wordBreak: "break-word" }}
      {...props}
    >
      {children}
    </h2>
  ),
  h3: ({ children, ...props }) => (
    <h3
      className="text-xl font-semibold mt-6 mb-2"
      style={{ wordBreak: "break-word" }}
      {...props}
    >
      {children}
    </h3>
  ),
  h4: ({ children, ...props }) => (
    <h4
      className="text-lg font-semibold mt-6 mb-2"
      style={{ wordBreak: "break-word" }}
      {...props}
    >
      {children}
    </h4>
  ),
  h5: ({ children, ...props }) => (
    <h5
      className="text-base font-semibold mt-6 mb-2"
      style={{ wordBreak: "break-word" }}
      {...props}
    >
      {children}
    </h5>
  ),
  h6: ({ children, ...props }) => (
    <h6
      className="text-sm font-semibold mt-6 mb-2"
      style={{ wordBreak: "break-word" }}
      {...props}
    >
      {children}
    </h6>
  ),
  img: ({ alt, src, title, ...props }) => (
    <img
      className="max-w-full h-auto my-2 rounded"
      alt={alt}
      src={src}
      title={title}
      {...props}
    />
  ),
  blockquote: ({ children, ...props }) => (
    <blockquote
      className="border-l-4 border-gray-300 dark:border-gray-700 pl-4 italic my-4"
      style={{ wordBreak: "break-word" }}
      {...props}
    >
      {children}
    </blockquote>
  ),
  table: ({ children, ...props }) => (
    <ScrollArea className="w-140 border rounded-lg my-4">
      <Table className="w-full" {...props}>
        {children}
      </Table>
      <ScrollBar orientation="horizontal" />
    </ScrollArea>
  ),
  thead: ({ children, ...props }) => (
    <TableHeader {...props}>{children}</TableHeader>
  ),
  tbody: ({ children, ...props }) => (
    <TableBody {...props}>{children}</TableBody>
  ),
  tfoot: ({ children, ...props }) => (
    <TableFooter {...props}>{children}</TableFooter>
  ),
  tr: ({ children, ...props }) => <TableRow {...props}>{children}</TableRow>,
  th: ({ children, ...props }) => <TableHead {...props}>{children}</TableHead>,
  td: ({ children, ...props }) => <TableCell {...props}>{children}</TableCell>,
  hr: () => <Separator className="my-8 h-1" />,
};

const remarkPlugins = [remarkGfm];
const rehypePlugins = [rehypeRaw];

// Function to process citations and convert them to proper format
const processCitations = (
  content: string,
  repoUrl?: string,
  branch?: string
): string => {
  // Match citations in format 【F:filename†L1-L1】
  const citationRegex = /【F:([^†]+)†L(\d+)-L(\d+)】/g;

  return content.replace(
    citationRegex,
    (match, filename, startLine, endLine) => {
      const displayText =
        startLine === endLine
          ? `${filename}:${startLine}`
          : `${filename}:${startLine}-${endLine}`;

      const repoBaseUrl = repoUrl ? `${repoUrl}/blob/${branch || "main"}` : "#";
      const linkUrl =
        startLine === endLine
          ? `${repoBaseUrl}/${filename}#L${startLine}`
          : `${repoBaseUrl}/${filename}#L${startLine}-L${endLine}`;

      return `[${displayText}](${linkUrl}) `;
    }
  );
};

interface MarkdownProps {
  children: string;
  repoUrl?: string;
  branch?: string;
}

const NonMemoizedMarkdown = ({ children, repoUrl, branch }: MarkdownProps) => {
  const processedContent = processCitations(children, repoUrl, branch);

  return (
    <div style={{ width: "100%", maxWidth: "100%" }}>
      <ReactMarkdown
        remarkPlugins={remarkPlugins}
        rehypePlugins={rehypePlugins}
        components={components}
      >
        {processedContent}
      </ReactMarkdown>
    </div>
  );
};

export const Markdown = memo(
  NonMemoizedMarkdown,
  (prevProps, nextProps) =>
    prevProps.children === nextProps.children &&
    prevProps.repoUrl === nextProps.repoUrl &&
    prevProps.branch === nextProps.branch
);



================================================
FILE: templates/codex-clone/components/navbar.tsx
================================================
import { Dot } from "lucide-react";
import Link from "next/link";

import { ThemeToggle } from "@/components/ui/theme-toggle";

export default function Navbar() {
  return (
    <div className="flex justify-between items-center">
      <Link href="/" passHref>
        <h1 className="text-lg font-bold">VibeX</h1>
      </Link>
      <div className="flex items-center gap-2">
        <div className="flex items-center gap-0">
          <Link
            href="/"
            className="hover:opacity-45 transition-opacity duration-300"
          >
            Home
          </Link>
          <Dot className="text-muted-foreground/40" />
          <Link
            href="/environments"
            className="hover:opacity-45 transition-opacity duration-300"
          >
            Environments
          </Link>
        </div>
        <ThemeToggle />
      </div>
    </div>
  );
}



================================================
FILE: templates/codex-clone/components/streaming-indicator.tsx
================================================
import { cn } from "@/lib/utils"

interface StreamingIndicatorProps {
  className?: string
  size?: "sm" | "md" | "lg"
  variant?: "dots" | "cursor" | "wave"
}

export function StreamingIndicator({ 
  className, 
  size = "md", 
  variant = "dots" 
}: StreamingIndicatorProps) {
  const sizeClasses = {
    sm: "gap-0.5",
    md: "gap-1",
    lg: "gap-1.5"
  }

  const dotSizeClasses = {
    sm: "w-1 h-1",
    md: "w-1.5 h-1.5",
    lg: "w-2 h-2"
  }

  if (variant === "cursor") {
    return (
      <span className={cn(
        "inline-block w-0.5 h-4 bg-primary animate-pulse",
        className
      )} />
    )
  }

  if (variant === "wave") {
    return (
      <div className={cn("flex items-center", sizeClasses[size], className)}>
        {[0, 1, 2].map((i) => (
          <div
            key={i}
            className={cn(
              "bg-primary/70 rounded-full animate-bounce",
              dotSizeClasses[size]
            )}
            style={{
              animationDelay: `${i * 0.15}s`,
              animationDuration: "1s"
            }}
          />
        ))}
      </div>
    )
  }

  // Default dots variant
  return (
    <div className={cn("flex items-center", sizeClasses[size], className)}>
      {[0, 1, 2].map((i) => (
        <div
          key={i}
          className={cn(
            "bg-primary/60 rounded-full animate-pulse",
            dotSizeClasses[size]
          )}
          style={{
            animationDelay: `${i * 0.2}s`,
            animationDuration: "1.4s"
          }}
        />
      ))}
    </div>
  )
}


================================================
FILE: templates/codex-clone/components/ui/button.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }



================================================
FILE: templates/codex-clone/components/ui/dialog.tsx
================================================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  showCloseButton = true,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content> & {
  showCloseButton?: boolean
}) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        {showCloseButton && (
          <DialogPrimitive.Close
            data-slot="dialog-close"
            className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4"
          >
            <XIcon />
            <span className="sr-only">Close</span>
          </DialogPrimitive.Close>
        )}
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}



================================================
FILE: templates/codex-clone/components/ui/scroll-area.tsx
================================================
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }



================================================
FILE: templates/codex-clone/components/ui/select.tsx
================================================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  size = "default",
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger> & {
  size?: "sm" | "default"
}) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      data-size={size}
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("text-muted-foreground px-2 py-1.5 text-xs", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}



================================================
FILE: templates/codex-clone/components/ui/separator.tsx
================================================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }



================================================
FILE: templates/codex-clone/components/ui/skeleton.tsx
================================================
import { cn } from "@/lib/utils"

function Skeleton({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="skeleton"
      className={cn("bg-accent animate-pulse rounded-md", className)}
      {...props}
    />
  )
}

export { Skeleton }



================================================
FILE: templates/codex-clone/components/ui/table.tsx
================================================
"use client"

import * as React from "react"

import { cn } from "@/lib/utils"

function Table({ className, ...props }: React.ComponentProps<"table">) {
  return (
    <div
      data-slot="table-container"
      className="relative w-full overflow-x-auto"
    >
      <table
        data-slot="table"
        className={cn("w-full caption-bottom text-sm", className)}
        {...props}
      />
    </div>
  )
}

function TableHeader({ className, ...props }: React.ComponentProps<"thead">) {
  return (
    <thead
      data-slot="table-header"
      className={cn("[&_tr]:border-b", className)}
      {...props}
    />
  )
}

function TableBody({ className, ...props }: React.ComponentProps<"tbody">) {
  return (
    <tbody
      data-slot="table-body"
      className={cn("[&_tr:last-child]:border-0", className)}
      {...props}
    />
  )
}

function TableFooter({ className, ...props }: React.ComponentProps<"tfoot">) {
  return (
    <tfoot
      data-slot="table-footer"
      className={cn(
        "bg-muted/50 border-t font-medium [&>tr]:last:border-b-0",
        className
      )}
      {...props}
    />
  )
}

function TableRow({ className, ...props }: React.ComponentProps<"tr">) {
  return (
    <tr
      data-slot="table-row"
      className={cn(
        "hover:bg-muted/50 data-[state=selected]:bg-muted border-b transition-colors",
        className
      )}
      {...props}
    />
  )
}

function TableHead({ className, ...props }: React.ComponentProps<"th">) {
  return (
    <th
      data-slot="table-head"
      className={cn(
        "text-foreground h-10 px-2 text-left align-middle font-medium whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCell({ className, ...props }: React.ComponentProps<"td">) {
  return (
    <td
      data-slot="table-cell"
      className={cn(
        "p-2 align-middle whitespace-nowrap [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
        className
      )}
      {...props}
    />
  )
}

function TableCaption({
  className,
  ...props
}: React.ComponentProps<"caption">) {
  return (
    <caption
      data-slot="table-caption"
      className={cn("text-muted-foreground mt-4 text-sm", className)}
      {...props}
    />
  )
}

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}



================================================
FILE: templates/codex-clone/components/ui/tabs.tsx
================================================
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }



================================================
FILE: templates/codex-clone/components/ui/text-shimmer.tsx
================================================
"use client";
import React, { useMemo, type JSX } from "react";
import { motion } from "framer-motion";
import { cn } from "@/lib/utils";

interface TextShimmerProps {
  children: string;
  as?: React.ElementType;
  className?: string;
  duration?: number;
  spread?: number;
}

export function TextShimmer({
  children,
  as: Component = "p",
  className,
  duration = 2,
  spread = 2,
}: TextShimmerProps) {
  const MotionComponent = motion(Component as keyof JSX.IntrinsicElements);

  const dynamicSpread = useMemo(() => {
    return children.length * spread;
  }, [children, spread]);

  return (
    <MotionComponent
      className={cn(
        "relative inline-block bg-[length:250%_100%,auto] bg-clip-text",
        "text-transparent [--base-color:#a1a1aa] [--base-gradient-color:#000]",
        "[--bg:linear-gradient(90deg,#0000_calc(50%-var(--spread)),var(--base-gradient-color),#0000_calc(50%+var(--spread)))] [background-repeat:no-repeat,padding-box]",
        "dark:[--base-color:#71717a] dark:[--base-gradient-color:#ffffff] dark:[--bg:linear-gradient(90deg,#0000_calc(50%-var(--spread)),var(--base-gradient-color),#0000_calc(50%+var(--spread)))]",
        className
      )}
      initial={{ backgroundPosition: "100% center" }}
      animate={{ backgroundPosition: "0% center" }}
      transition={{
        repeat: Infinity,
        duration,
        ease: "linear",
      }}
      style={
        {
          "--spread": `${dynamicSpread}px`,
          backgroundImage: `var(--bg), linear-gradient(var(--base-color), var(--base-color))`,
        } as React.CSSProperties
      }
    >
      {children}
    </MotionComponent>
  );
}



================================================
FILE: templates/codex-clone/components/ui/theme-toggle.tsx
================================================
"use client"

import * as React from "react"
import { Moon, Sun } from "lucide-react"
import { useTheme } from "next-themes"

import { Button } from "@/components/ui/button"

export function ThemeToggle() {
  const { theme, setTheme } = useTheme()
  const [mounted, setMounted] = React.useState(false)

  React.useEffect(() => {
    setMounted(true)
  }, [])

  if (!mounted) {
    return (
      <Button variant="ghost" size="icon" disabled>
        <Sun className="h-[1.2rem] w-[1.2rem]" />
        <span className="sr-only">Toggle theme</span>
      </Button>
    )
  }

  return (
    <Button
      variant="ghost"
      size="icon"
      onClick={() => setTheme(theme === "light" ? "dark" : "light")}
    >
      <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
      <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
      <span className="sr-only">Toggle theme</span>
    </Button>
  )
}


================================================
FILE: templates/codex-clone/components/ui/tooltip.tsx
================================================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }



================================================
FILE: templates/codex-clone/hooks/use-github-auth.ts
================================================
"use client";

import { useState, useEffect } from "react";
import { GitHubRepository, GitHubUser, GitHubBranch } from "@/lib/github";

interface UseGitHubAuthReturn {
  isAuthenticated: boolean;
  user: GitHubUser | null;
  repositories: GitHubRepository[];
  branches: GitHubBranch[];
  isLoading: boolean;
  error: string | null;
  login: () => Promise<void>;
  logout: () => void;
  fetchRepositories: () => Promise<void>;
  fetchBranches: (repositoryName: string) => Promise<void>;
}

export function useGitHubAuth(): UseGitHubAuthReturn {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [user, setUser] = useState<GitHubUser | null>(null);
  const [repositories, setRepositories] = useState<GitHubRepository[]>([]);
  const [branches, setBranches] = useState<GitHubBranch[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Check authentication status on mount
  useEffect(() => {
    const abortController = new AbortController();
    
    const checkAuth = async () => {
      try {
        setIsLoading(true);
        const userCookie = document.cookie
          .split("; ")
          .find((row) => row.startsWith("github_user="));

        if (userCookie) {
          const userData = JSON.parse(
            decodeURIComponent(userCookie.split("=")[1])
          );

          // Verify the access token is still valid by making a test API call
          const response = await fetch("/api/auth/github/repositories", {
            signal: abortController.signal,
          });

          if (response.ok) {
            setUser(userData);
            setIsAuthenticated(true);
          } else {
            // Token is invalid, clear cookies and auth state
            document.cookie =
              "github_access_token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
            document.cookie =
              "github_user=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
            setIsAuthenticated(false);
            setUser(null);
          }
        } else {
          setIsAuthenticated(false);
          setUser(null);
        }
      } catch (error) {
        if (error instanceof Error && error.name === 'AbortError') {
          // Ignore abort errors
          return;
        }
        console.error("Error checking auth status:", error);
        setIsAuthenticated(false);
        setUser(null);
      } finally {
        if (!abortController.signal.aborted) {
          setIsLoading(false);
        }
      }
    };

    checkAuth();
    
    return () => {
      abortController.abort("Component unmounted");
    };
  }, []);

  // Listen for auth success from popup
  useEffect(() => {
    const handleMessage = (event: MessageEvent) => {
      if (event.data.type === "GITHUB_AUTH_SUCCESS") {
        // Wait a bit for cookies to be set, then check auth status
        setTimeout(() => {
          // Instead of reloading the page, just check auth status again
          const userCookie = document.cookie
            .split("; ")
            .find((row) => row.startsWith("github_user="));

          if (userCookie) {
            try {
              const userData = JSON.parse(
                decodeURIComponent(userCookie.split("=")[1])
              );
              setUser(userData);
              setIsAuthenticated(true);
              setIsLoading(false);
            } catch (error) {
              console.error("Error parsing user data:", error);
              setIsAuthenticated(false);
              setUser(null);
              setIsLoading(false);
            }
          }
        }, 1000);
      }
    };

    window.addEventListener("message", handleMessage);
    return () => window.removeEventListener("message", handleMessage);
  }, []);

  const login = async (): Promise<void> => {
    try {
      setIsLoading(true);
      setError(null);

      // Get the auth URL from our API
      const response = await fetch("/api/auth/github/url");
      const { url } = await response.json();

      // Open popup window for OAuth (centered on screen)
      const width = 600;
      const height = 700;
      const left = (window.screen.width - width) / 2;
      const top = (window.screen.height - height) / 2;

      const popup = window.open(
        url,
        "github-oauth",
        `width=${width},height=${height},left=${left},top=${top},scrollbars=yes,resizable=yes`
      );

      // Check if popup was blocked
      if (!popup) {
        throw new Error("Popup blocked. Please allow popups for this site.");
      }

      // Wait for popup to close
      const checkClosed = setInterval(() => {
        if (popup.closed) {
          clearInterval(checkClosed);
          setIsLoading(false);
        }
      }, 1000);
    } catch (error) {
      setError(
        error instanceof Error ? error.message : "Authentication failed"
      );
      setIsLoading(false);
    }
  };

  const logout = (): void => {
    // Clear cookies
    document.cookie =
      "github_access_token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
    document.cookie =
      "github_user=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";

    setIsAuthenticated(false);
    setUser(null);
    setRepositories([]);
    setBranches([]);
  };

  const fetchRepositories = async (): Promise<void> => {
    if (!isAuthenticated) return;
    console.log("isAuthenticated", isAuthenticated);
    
    try {
      setIsLoading(true);
      setError(null);

      const response = await fetch("/api/auth/github/repositories");

      if (!response.ok) {
        throw new Error("Failed to fetch repositories");
      }

      const data = await response.json();
      setRepositories(data.repositories || []);
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        // Ignore abort errors
        return;
      }
      setError(
        error instanceof Error ? error.message : "Failed to fetch repositories"
      );
    } finally {
      setIsLoading(false);
    }
  };

  const fetchBranches = async (repositoryName: string): Promise<void> => {
    try {
      setIsLoading(true);
      setError(null);

      // Parse repository name to extract owner and repo
      // Repository name should be in format "owner/repo"
      const [owner, repo] = repositoryName.split("/");

      if (!owner || !repo) {
        throw new Error('Repository name must be in format "owner/repo"');
      }

      const response = await fetch(
        `/api/auth/github/branches?owner=${encodeURIComponent(
          owner
        )}&repo=${encodeURIComponent(repo)}`
      );

      if (!response.ok) {
        throw new Error("Failed to fetch branches");
      }

      const data = await response.json();
      setBranches(data.branches || []);
    } catch (error) {
      setError(
        error instanceof Error ? error.message : "Failed to fetch branches"
      );
    } finally {
      setIsLoading(false);
    }
  };

  return {
    isAuthenticated,
    user,
    repositories,
    branches,
    isLoading,
    error,
    login,
    logout,
    fetchRepositories,
    fetchBranches,
  };
}



================================================
FILE: templates/codex-clone/lib/github.ts
================================================
export interface GitHubBranch {
  name: string;
  commit: {
    sha: string;
    url: string;
  };
  protected: boolean;
  isDefault: boolean;
}

export interface GitHubRepository {
  id: number;
  name: string;
  full_name: string;
  private: boolean;
  description?: string;
  html_url: string;
  default_branch: string;
  fork: boolean;
  permissions?: {
    admin: boolean;
    push: boolean;
    pull: boolean;
  };
}

export interface GitHubUser {
  id: number;
  login: string;
  avatar_url: string;
  name?: string;
  email?: string;
}

export class GitHubAuth {
  private clientId: string;
  private clientSecret: string;
  private redirectUri: string;

  constructor() {
    this.clientId = process.env.GITHUB_CLIENT_ID!;
    this.clientSecret = process.env.GITHUB_CLIENT_SECRET!;
    this.redirectUri =
      process.env.NODE_ENV === "production"
        ? "https://clonedex.vercel.app/api/auth/github/callback"
        : "http://localhost:3000/api/auth/github/callback";
  }

  // Generate GitHub OAuth URL
  getAuthUrl(state?: string): string {
    const params = new URLSearchParams({
      client_id: this.clientId,
      redirect_uri: this.redirectUri,
      scope: "repo user:email",
      state: state || Math.random().toString(36).substring(7),
    });

    return `https://github.com/login/oauth/authorize?${params.toString()}`;
  }

  // Exchange code for access token
  async exchangeCodeForToken(code: string): Promise<string> {
    const response = await fetch(
      "https://github.com/login/oauth/access_token",
      {
        method: "POST",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          client_id: this.clientId,
          client_secret: this.clientSecret,
          code,
        }),
      }
    );

    const data = await response.json();

    if (data.error) {
      throw new Error(`GitHub OAuth error: ${data.error_description}`);
    }

    return data.access_token;
  }

  // Get user information
  async getUser(accessToken: string): Promise<GitHubUser> {
    const response = await fetch("https://api.github.com/user", {
      headers: {
        Authorization: `Bearer ${accessToken}`,
        Accept: "application/vnd.github.v3+json",
      },
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch user: ${response.statusText}`);
    }

    return response.json();
  }

  // Get user repositories
  async getUserRepositories(accessToken: string): Promise<GitHubRepository[]> {
    const response = await fetch(
      "https://api.github.com/user/repos?sort=updated&per_page=100",
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          Accept: "application/vnd.github.v3+json",
        },
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to fetch repositories: ${response.statusText}`);
    }

    return response.json();
  }

  // Create a pull request
  async createPullRequest(
    accessToken: string,
    owner: string,
    repo: string,
    title: string,
    body: string,
    head: string,
    base: string = "main"
  ) {
    const response = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/pulls`,
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${accessToken}`,
          Accept: "application/vnd.github.v3+json",
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          title,
          body,
          head,
          base,
        }),
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to create pull request: ${response.statusText}`);
    }

    return response.json();
  }
}

export const githubAuth = new GitHubAuth();



================================================
FILE: templates/codex-clone/lib/inngest.ts
================================================
import { Inngest } from "inngest";
import { realtimeMiddleware, channel, topic } from "@inngest/realtime";
import { VibeKit, VibeKitConfig } from "@vibe-kit/sdk";

// Create a client to send and receive events
export const inngest = new Inngest({
  id: "clonedex",
  middleware: [realtimeMiddleware()],
});

export const taskChannel = channel("tasks")
  .addTopic(
    topic("status").type<{
      taskId: string;
      status: "IN_PROGRESS" | "DONE" | "MERGED";
      sessionId: string;
    }>()
  )
  .addTopic(
    topic("update").type<{
      taskId: string;
      message: Record<string, unknown>;
    }>()
  );

// Helper function to simulate streaming by chunking text
function* chunkText(text: string, chunkSize: number = 10): Generator<string, void, unknown> {
  const words = text.split(' ');
  for (let i = 0; i < words.length; i += chunkSize) {
    yield words.slice(i, i + chunkSize).join(' ') + (i + chunkSize < words.length ? ' ' : '');
  }
}

export const createTask = inngest.createFunction(
  { id: "create-task" },
  { event: "clonedex/create.task" },
  async ({ event, step, publish }) => {
    const { task, token, sessionId, prompt } = event.data;
    const config: VibeKitConfig = {
      agent: {
        type: "codex",
        model: {
          apiKey: process.env.OPENAI_API_KEY!,
        },
      },
      environment: {
        e2b: {
          apiKey: process.env.E2B_API_KEY!,
        },
      },
      github: {
        token,
        repository: task.repository,
      },
    };

    const result = await step.run("generate-code", async () => {
      const vibekit = new VibeKit(config);

      if (sessionId) {
        await vibekit.setSession(sessionId);
      }

      const response = await vibekit.generateCode({
        prompt: prompt || task.title,
        mode: task.mode,
        callbacks: {
          onUpdate(message) {
            try {
              const parsedMessage = JSON.parse(message);
              
              // For assistant messages, implement streaming
              if (parsedMessage.type === "message" && parsedMessage.role === "assistant") {
                const messageId = parsedMessage.data?.id || crypto.randomUUID();
                const fullText = parsedMessage.data?.text || "";
                
                // Stream the message in chunks
                let accumulatedText = "";
                const chunks = Array.from(chunkText(fullText, 5)); // 5 words per chunk
                
                chunks.forEach((chunk, index) => {
                  accumulatedText += chunk;
                  
                  setTimeout(() => {
                    publish(
                      taskChannel().update({
                        taskId: task.id,
                        message: {
                          ...parsedMessage,
                          data: {
                            ...parsedMessage.data,
                            id: messageId,
                            text: accumulatedText,
                            isStreaming: index < chunks.length - 1,
                            streamId: messageId,
                            chunkIndex: index,
                            totalChunks: chunks.length,
                          }
                        },
                      })
                    );
                  }, index * 50); // 50ms delay between chunks for smooth streaming
                });
              } else {
                // Non-message updates (like git operations, etc.)
                publish(
                  taskChannel().update({
                    taskId: task.id,
                    message: parsedMessage,
                  })
                );
              }
            } catch {
              // If it's not JSON, it might be raw streaming output
              // Create a streaming message for it
              const streamId = `stream-${Date.now()}`;
              publish(
                taskChannel().update({
                  taskId: task.id,
                  message: {
                    type: "message",
                    role: "assistant",
                    data: {
                      text: message,
                      isStreaming: true,
                      streamId: streamId,
                      raw: true
                    }
                  },
                })
              );
            }
          },
        },
      });

      await vibekit.pause();

      return response;
    });

    if ("stdout" in result) {
      const lines = result.stdout.trim().split("\n");
      const parsedLines = lines.map((line) => JSON.parse(line));
      await publish(
        taskChannel().status({
          taskId: task.id,
          status: "DONE",
          sessionId: result.sandboxId,
        })
      );

      return { message: parsedLines };
    } else {
      return { message: result };
    }
  }
);

let app: Inngest | undefined;

export const getInngestApp = () => {
  return (app ??= new Inngest({
    id: typeof window !== "undefined" ? "client" : "server",
    middleware: [realtimeMiddleware()],
  }));
};



================================================
FILE: templates/codex-clone/lib/utils.ts
================================================
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}



================================================
FILE: templates/codex-clone/stores/environments.ts
================================================
import { create } from "zustand";
import { persist } from "zustand/middleware";

export interface Environment {
  id: string;
  name: string;
  description: string;
  githubOrganization: string;
  githubToken: string;
  githubRepository: string;
  createdAt: Date;
  updatedAt: Date;
}

interface EnvironmentStore {
  environments: Environment[];
  createEnvironment: (
    environment: Omit<Environment, "id" | "createdAt" | "updatedAt">
  ) => void;
  updateEnvironment: (
    id: string,
    updates: Partial<Omit<Environment, "id" | "createdAt" | "updatedAt">>
  ) => void;
  deleteEnvironment: (id: string) => void;
  listEnvironments: () => Environment[];
}

export const useEnvironmentStore = create<EnvironmentStore>()(
  persist(
    (set, get) => ({
      environments: [],

      createEnvironment: (environment) => {
        const now = new Date();
        const newEnvironment = {
          ...environment,
          id: crypto.randomUUID(),
          createdAt: now,
          updatedAt: now,
        };
        set((state) => ({
          environments: [...state.environments, newEnvironment],
        }));
      },

      updateEnvironment: (id, updates) => {
        set((state) => ({
          environments: state.environments.map((env) =>
            env.id === id ? { ...env, ...updates, updatedAt: new Date() } : env
          ),
        }));
      },

      deleteEnvironment: (id) => {
        set((state) => ({
          environments: state.environments.filter((env) => env.id !== id),
        }));
      },

      listEnvironments: () => get().environments,
    }),
    {
      name: "environments",
    }
  )
);



================================================
FILE: templates/codex-clone/stores/tasks.ts
================================================
// stores/useTaskStore.ts
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { PullRequestResponse } from "@vibe-kit/sdk";

type TaskStatus = "IN_PROGRESS" | "DONE" | "MERGED";

export interface Task {
  id: string;
  title: string;
  description: string;
  messages: {
    role: "user" | "assistant";
    type: string;
    data: Record<string, unknown>;
  }[];
  status: TaskStatus;
  branch: string;
  sessionId: string;
  repository: string;
  createdAt: string;
  updatedAt: string;
  statusMessage?: string;
  isArchived: boolean;
  mode: "code" | "ask";
  hasChanges: boolean;
  pullRequest?: PullRequestResponse;
}

interface TaskStore {
  tasks: Task[];
  addTask: (
    task: Omit<Task, "id" | "createdAt" | "updatedAt" | "isArchived">
  ) => Task;
  updateTask: (
    id: string,
    updates: Partial<Omit<Task, "id" | "createdAt">>
  ) => void;
  setTasks: (tasks: Task[]) => void;
  removeTask: (id: string) => void;
  archiveTask: (id: string) => void;
  unarchiveTask: (id: string) => void;
  clear: () => void;
  getTasks: () => Task[];
  getActiveTasks: () => Task[];
  getArchivedTasks: () => Task[];
  getTaskById: (id: string) => Task | undefined;
  getTasksByStatus: (status: TaskStatus) => Task[];
  getTasksBySessionId: (sessionId: string) => Task[];
}

export const useTaskStore = create<TaskStore>()(
  persist(
    (set, get) => ({
      tasks: [],
      addTask: (task) => {
        const now = new Date().toISOString();
        const id = crypto.randomUUID();
        const newTask = {
          ...task,
          id,
          createdAt: now,
          updatedAt: now,
          isArchived: false,
        };
        set((state) => ({
          tasks: [...state.tasks, newTask],
        }));
        return newTask;
      },
      updateTask: (id, updates) => {
        set((state) => ({
          tasks: state.tasks.map((task) =>
            task.id === id
              ? { ...task, ...updates, updatedAt: new Date().toISOString() }
              : task
          ),
        }));
      },
      setTasks: (tasks) => set(() => ({ tasks })),
      removeTask: (id) => {
        set((state) => ({
          tasks: state.tasks.filter((task) => task.id !== id),
        }));
      },
      archiveTask: (id) => {
        set((state) => ({
          tasks: state.tasks.map((task) =>
            task.id === id
              ? {
                  ...task,
                  isArchived: true,
                  updatedAt: new Date().toISOString(),
                }
              : task
          ),
        }));
      },
      unarchiveTask: (id) => {
        set((state) => ({
          tasks: state.tasks.map((task) =>
            task.id === id
              ? {
                  ...task,
                  isArchived: false,
                  updatedAt: new Date().toISOString(),
                }
              : task
          ),
        }));
      },
      clear: () => set({ tasks: [] }),
      getTasks: () => get().tasks,
      getActiveTasks: () =>
        get()
          .tasks.filter((task) => !task.isArchived)
          .reverse(),
      getArchivedTasks: () => get().tasks.filter((task) => task.isArchived),
      getTaskById: (id) => get().tasks.find((task) => task.id === id),
      getTasksByStatus: (status) =>
        get().tasks.filter((task) => task.status === status),
      getTasksBySessionId: (sessionId) =>
        get().tasks.filter((task) => task.sessionId === sessionId),
    }),
    {
      name: "task-store", // key in localStorage
      // Optionally, customize storage or partialize which fields to persist
      // storage: () => sessionStorage, // for sessionStorage instead
    }
  )
);



================================================
FILE: templates/v0-clone/README.md
================================================
# Vibe0 (v0-clone)

A Next.js app template powered by VibeKit SDK, Inngest, Convex, and Anthropic Claude. This application enables collaborative AI-driven development with real-time updates, GitHub integration, and sandboxed code execution using Northflank.

## ✨ Features

- 🤖 AI-powered code generation using Anthropic Claude
- 🔄 Real-time task updates with Inngest
- 🐙 GitHub integration for repository management
- 🏗️ Sandboxed environment execution with Northflank
- 📦 State management with Convex
- 🎨 Modern UI with Tailwind CSS and shadcn/ui
- 🗃️ TypeScript-first, modular architecture

## 🚀 Prerequisites

Before you begin, make sure you have:

- **Node.js** (v18 or higher)
- **npm** or **yarn**
- **Inngest CLI** (for local development)
- **Convex account** (for state management)
- **Anthropic API key**
- **Northflank API key and project ID**
- **GitHub OAuth app** (for GitHub integration)

## 📦 Installation

### 1. Install Dependencies

```bash
npm install
```

### 2. Install Inngest CLI

The Inngest CLI is required for running background functions locally:

```bash
# Install globally
npm install -g inngest

# Or using npx (recommended)
npx inngest-cli@latest
```

### 3. Set Up Environment Variables

Create a `.env.local` file in the root directory with the following variables:

```bash
# Anthropic Claude API Key
ANTHROPIC_API_KEY=your_anthropic_api_key_here

# Northflank Configuration
NORTHFLANK_API_KEY=your_northflank_api_key_here
NORTHFLANK_PROJECT_ID=your_northflank_project_id_here

# Convex Configuration
NEXT_PUBLIC_CONVEX_URL=your_convex_url_here

# GitHub OAuth Configuration
AUTH_GITHUB_ID=your_github_client_id
AUTH_GITHUB_SECRET=your_github_client_secret
```

#### Getting API Keys:

- **Anthropic API Key**: Get it from [Anthropic Console](https://console.anthropic.com/)
- **Northflank API Key/Project ID**: [Northflank Dashboard](https://northflank.com/)
- **Convex URL**: [Convex Console](https://dashboard.convex.dev/)
- **GitHub OAuth**: Create a new OAuth app in your [GitHub Developer Settings](https://github.com/settings/developers)

## 🛠️ Development

### 1. Start the Inngest Dev Server

In one terminal, start the Inngest development server:

```bash
npx inngest-cli@latest dev
```

This will start the Inngest development server on `http://localhost:8288`.

### 2. Start the Next.js Development Server

In another terminal, start the Next.js application:

```bash
npm run dev
```

The application will be available at `http://localhost:3000`.

## 📋 Available Scripts

- `npm run dev` - Start the development server
- `npm run build` - Build the application for production
- `npm start` - Start the production server
- `npm run lint` - Run ESLint for code quality

## 🏗️ Project Structure

```
├── app/                    # Next.js App Router
│   ├── actions/            # Server actions
│   ├── api/                # API routes
│   └── session/            # Session pages
├── components/             # Reusable UI components
│   └── ui/                 # shadcn/ui components
├── convex/                 # Convex schema and functions
├── lib/                    # Utility libraries and configurations
├── providers/              # React providers (auth, convex, theme)
├── public/                 # Static assets
```

## 🔧 Configuration

### Inngest Functions

The application uses Inngest for background task processing. Main functions are defined in `lib/inngest.ts` and handle AI code generation, session management, and real-time updates.

### VibeKit Integration

The app integrates with VibeKit SDK for AI code generation, supporting:

- Anthropic Claude as the AI model
- Northflank for sandboxed environments
- GitHub repository integration
- Real-time streaming updates

### Convex

Convex is used for state management and real-time data sync. See the `convex/` directory for schema and server functions.

## 🌐 Deployment

### Environment Variables for Production

Set all required environment variables in your production environment:

```bash
AUTH_GITHUB_ID=
AUTH_GITHUB_SECRET=
NORTHFLANK_API_KEY=
NORTHFLANK_PROJECT_ID=
NEXT_PUBLIC_CONVEX_URL=
ANTHROPIC_API_KEY=
```

### Deploy to Vercel

1. Connect your repository to Vercel
2. Set the environment variables in the Vercel dashboard
3. Deploy

### Inngest in Production

For production, configure Inngest properly:

1. Set up an Inngest account at [inngest.com](https://inngest.com)
2. Configure your production Inngest endpoint
3. Update your deployment to use the production Inngest configuration

## 🤝 Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## 📄 License

This project is licensed under the MIT License.

## 🆘 Troubleshooting

### Common Issues

1. **Inngest functions not working**: Make sure the Inngest CLI is running (`npx inngest-cli@latest dev`)
2. **API key errors**: Verify all environment variables are set correctly
3. **GitHub OAuth issues**: Check your GitHub OAuth app configuration and callback URLs
4. **Northflank connection problems**: Ensure your Northflank API key and project ID are valid
5. **Convex issues**: Make sure your Convex URL is correct and your account is active

### Getting Help

- Check the [Inngest Documentation](https://www.inngest.com/docs)
- Visit [VibeKit Documentation](https://vibekit.dev/docs)
- Review [Next.js Documentation](https://nextjs.org/docs)
- See [Convex Documentation](https://docs.convex.dev/)
- Explore [Anthropic API Docs](https://docs.anthropic.com/claude)
- Visit [Northflank Docs](https://northflank.com/docs)

---

Built with ❤️ using Next.js, VibeKit, Inngest, Convex, and Anthropic Claude



================================================
FILE: templates/v0-clone/components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}


================================================
FILE: templates/v0-clone/config.ts
================================================
export interface Template {
  id: string;
  name: string;
  description: string;
  repository: string;
  logos: string[];
  image?: string;
  startCommands: {
    command: string;
    status: "INSTALLING_DEPENDENCIES" | "STARTING_DEV_SERVER";
    background?: boolean;
  }[];
  secrets?: Record<string, string>;
  systemPrompt: string;
}

export const templates: Template[] = [
  {
    id: "nextjs",
    name: "Next.js",
    description:
      "Build scalable web applications with server-side rendering, static site generation, and API routes",
    repository: "https://github.com/superagent-ai/vibekit-nextjs",
    logos: ["nextjs.svg"],
    startCommands: [
      {
        command: "npm i",
        status: "INSTALLING_DEPENDENCIES",
      },
      {
        command: "npm run dev",
        status: "STARTING_DEV_SERVER",
        background: true,
      },
    ],
    systemPrompt:
      "# GOAL\nYou are an helpful assistant that is tasked with helping the user build a NextJS app.\n" +
      "- The NextJS dev server is running on port 3000.\n" +
      "- ShadCN UI is installed, togehter with all the ShadCN components.\n",
  },
  {
    id: "nextjs-supabase-auth",
    name: "Next.js + Supabase + Auth",
    description:
      "Build a production-ready SaaS with authentication, database, and real-time features out of the box",
    repository:
      "https://github.com/vercel/next.js/tree/canary/examples/with-supabase",
    logos: ["nextjs.svg", "supabase.jpeg"],
    startCommands: [
      {
        command: "npm i",
        status: "INSTALLING_DEPENDENCIES",
      },
      {
        command: "npm run dev",
        status: "STARTING_DEV_SERVER",
        background: true,
      },
    ],
    systemPrompt:
      "# GOAL\nYou are an helpful assistant that is tasked with helping the user build a NextJS app.\n" +
      "- The NextJS dev server is running on port 3000.\n" +
      "- ShadCN UI is installed, togehter with all the ShadCN components.\n" +
      "- Supabase CLI and Auth is installed and ready to be used if needed.\n",
  },
  {
    id: "nextjs-convex-clerk",
    name: "Next.js + Convex + Clerk",
    description:
      "Create collaborative apps with real-time sync, instant auth, and seamless user management",
    repository: "https://github.com/get-convex/convex-clerk-users-table",
    logos: ["nextjs.svg", "convex.webp", "clerk.svg"],
    startCommands: [
      {
        command: "npm i",
        status: "INSTALLING_DEPENDENCIES",
      },
      {
        command: "npm run dev",
        status: "STARTING_DEV_SERVER",
        background: true,
      },
      {
        command: "npx convex dev",
        status: "STARTING_DEV_SERVER",
        background: true,
      },
    ],
    systemPrompt:
      "# GOAL\nYou are an helpful assistant that is tasked with helping the user build a NextJS app.\n" +
      "- The NextJS dev server is running on port 3000.\n" +
      "- The convex command npx convex dev is running\n" +
      "- ShadCN UI is installed, togehter with all the ShadCN components.\n" +
      "- Convex CLI is is installed and ready to be used if needed.\n",
  },
  {
    id: "shopify-hydrogen",
    name: "Shopify",
    description:
      "Build fast headless commerce storefronts with Shopify's official framework Hydrogen.",
    repository: "superagent-ai/vibekit-shopify",
    logos: ["shopify.jpeg"],
    startCommands: [
      {
        command: "npm i",
        status: "INSTALLING_DEPENDENCIES",
      },
      {
        command: "npm i -g @shopify/cli@latest",
        status: "INSTALLING_DEPENDENCIES",
      },
      {
        command: "echo 'SESSION_SECRET=\"foobar\"' > .env",
        status: "INSTALLING_DEPENDENCIES",
      },
      {
        command: "shopify hydrogen dev --codegen --host",
        background: true,
        status: "STARTING_DEV_SERVER",
      },
    ],
    secrets: {
      SESSION_SECRET: "foobar",
    },
    systemPrompt:
      "# GOAL\nYou are an helpful assistant that is tasked with helping the user build a Shopify Hydrogen app.\n" +
      "- The hydrogen server is running on port 3000.\n" +
      "- The Shopify CLI is installed and ready to be used if needed.\n",
  },
  {
    id: "fastapi-nextjs",
    name: "FastAPI + Next.js",
    description:
      "Build modern full-stack apps with FastAPI backend and Next.js frontend.",
    repository: "tiangolo/full-stack-fastapi-template",
    logos: ["nextjs.svg", "fastapi.jpg"],
    startCommands: [
      {
        command: "npm i",
        status: "INSTALLING_DEPENDENCIES",
      },
      {
        command: "npm run dev",
        status: "STARTING_DEV_SERVER",
        background: true,
      },
    ],
    systemPrompt:
      "# GOAL\nYou are an helpful assistant that is tasked with helping the user build a FastAPI and Next.js app.\n" +
      "- The NextJS dev server is running on port 3000.\n" +
      "- The FastAPI server is running on port 8000.\n" +
      "- ShadCN UI is installed, togehter with all the ShadCN components.\n",
  },
];



================================================
FILE: templates/v0-clone/eslint.config.mjs
================================================
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __fil